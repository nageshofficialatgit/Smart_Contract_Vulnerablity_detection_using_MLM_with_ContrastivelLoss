{
    "fileid": {
        "112": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Balancer {\n\n    function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {\n        return to.call.value(value)(data);\n    }\n}\n",
            "label": 1
        },
        "113": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Balancer {\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {\n        return to.call.value(value)(data);\n    }\n}\n",
            "label": 1
        },
        "114": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ParcelXToken {\n\n    function execute(address _to, uint256 _value, bytes _data) external returns (bool){\n        require(_to != address(0));\n        return _to.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "115": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ParcelXToken {\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n        require(_to != address(0));\n        return _to.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "116": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Halo3D {\n\n    uint totalEthCharityRecieved = 0;\n    uint totalEthCharityCollected = 100;\n    address public giveEthCharityAddress;\n     \n    function payCharity() payable public {\n\n      uint256 ethToPay = totalEthCharityCollected -  totalEthCharityRecieved;\n\n      if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {\n         totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;\n      }\n    }\n}\n",
            "label": 1
        },
        "117": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FsTKerWallet {\n\n  function callContract(address to, bytes data) public payable returns (bool) {\n    require(to.call.value(msg.value)(data));\n    return true;\n  }\n}\n",
            "label": 1
        },
        "118": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FsTKerWallet {\n\n  address owner;\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function callContract(address to, bytes data) public onlyOwner payable returns (bool) {\n    require(to.call.value(msg.value)(data));\n    return true;\n  }\n}\n",
            "label": 1
        },
        "119": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ICOBuyer {\n\n    address public sale;\n\n    function buy() {\n        require(sale.call.value(this.balance)());\n    }\n}\n",
            "label": 1
        },
        "120": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ICOBuyer {\n\n    address public sale;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function buy() onlyOwner {\n        require(sale.call.value(this.balance)());\n    }\n}\n",
            "label": 1
        },
        "121": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokensGate {\n\n  function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n    require(address(this).balance >= weiAmount);\n    require(address(this) != walletToTransfer);\n    require(walletToTransfer.call.value(weiAmount)());\n  }\n}",
            "label": 1
        },
        "122": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC827Token {\n\n    function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {\n        require(_spender != address(this));\n        require(_spender.call.value(msg.value)(_data));\n        return true;\n    }\n}\n",
            "label": 1
        },
        "123": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DividendToken {\n\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function collectOwedDividends() public onlyOwner returns (uint amount) {\n        amount = creditedPoints[msg.sender] / 100;\n        creditedPoints[msg.sender] -= amount;\n        require(msg.sender.call.value(amount)());\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}\n",
            "label": 1
        },
        "124": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DividendToken {\n\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected;\n\n    function collectOwedDividends() public returns (uint amount) {\n        amount = creditedPoints[msg.sender] / 100;\n        creditedPoints[msg.sender] -= amount;\n        require(msg.sender.call.value(amount)());\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}\n",
            "label": 1
        },
        "125": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AddressProxy {\n\n    function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {\n        require(_location.call.value(_value).gas(_gas)(_data));\n    }\n}\n",
            "label": 1
        },
        "126": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DrainMe {\n\n    address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\n \n    function callSecondTarget () public payable {\n        require (msg.value >= 0.005 ether);\n        secondTarget.call.value(msg.value)();\n    }\n}\n\n",
            "label": 1
        },
        "127": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DrainMe {\n\n    address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n \n    function callFirstTarget () public payable {\n        require (msg.value >= 0.005 ether);\n        firstTarget.call.value(msg.value)();\n    }\n}\n",
            "label": 1
        },
        "128": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DrainMe {\n\n    address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n \n    function callFirstTarget () public onlyOwner payable {\n        require (msg.value >= 0.005 ether);\n        firstTarget.call.value(msg.value)();\n    }\n}\n",
            "label": 1
        },
        "129": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n}\n",
            "label": 1
        },
        "130": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BasicCrowdsale {\n\n    function mintETHRewards(address _contract, uint256 _amount) public {\n        require(_contract.call.value(_amount)());\n    }\n}\n",
            "label": 1
        },
        "131": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PoormansHoneyPot {\n\n    mapping (address => uint) public balances;\n\n    function withdraw() public{\n        assert(msg.sender.call.value(balances[msg.sender])()) ;\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "132": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PoormansHoneyPot {\n\n    mapping (address => uint) public balances;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw() public onlyOwner {\n        assert(msg.sender.call.value(balances[msg.sender])()) ;\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "133": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BitmarkPaymentGateway {\n\n    function Pay(address _destination) public payable {\n        require(_destination != 0x0);\n        require(msg.value > 0);\n        _destination.call.value(msg.value / (9) * (8))();\n    }\n}\n",
            "label": 1
        },
        "134": {
            "code": "pragma solidity ^0.4.24;\n\ncontract keepMyEther {\n\n    mapping(address => uint256) public balances;\n\n    function withdraw() public {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "135": {
            "code": "pragma solidity ^0.4.24;\n\ncontract keepMyEther {\n\n    mapping(address => uint256) public balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw() public onlyOwner {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "136": {
            "code": "pragma solidity ^0.4.24;\n\ncontract RipioOracle{\n\n    function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {\n        return to.call.value(value)(data);\n    }\n}\n",
            "label": 1
        },
        "137": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    mapping (address => bool) accountExists;\n\n    function withdraw(uint amount) public {\n        require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount)();\n    }\n}\n",
            "label": 1
        },
        "138": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    mapping (address => bool) accountExists;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount);\n    }\n}\n",
            "label": 0
        },
        "139": {
            "code": "pragma solidity ^0.4.24;\n\ncontract CrowdsaleProxy {\n\n    function upgradeToAndCall(address newTarget, bytes data) payable public {\n        require(address(this).call.value(msg.value)(data));\n    }\n}",
            "label": 1
        },
        "140": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BoomerangLiquidity {\n\n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n    Participant[] public participants;\n    uint public payoutOrder = 0;\n\n    function payout() public {\n        uint balance = address(this).balance;\n        require(balance > 1);\n        uint investment = balance / 2;\n        balance =- investment;\n\n        while (balance > 0) {\n            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n\n            if(payoutToSend > 0){\n                participants[payoutOrder].payout -= payoutToSend;\n                balance -= payoutToSend;\n                participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "141": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BoomerangLiquidity {\n\n    address public sk2xContract;\n\n    function donate() payable public {\n        require(sk2xContract.call.value(msg.value).gas(1000000)());\n    }\n}\n",
            "label": 1
        },
        "142": {
            "code": "pragma solidity ^0.4.24;\n\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}\n",
            "label": 1
        },
        "143": {
            "code": "pragma solidity ^0.4.24;\n\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\taddress public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public onlyOwner {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}\n",
            "label": 1
        },
        "144": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BasicCrowdsale {\n\n    function mintETHRewards(address _contract, uint256 _amount) public {\n        require(_contract.call.value(_amount)());\n    }\n}\n",
            "label": 1
        },
        "145": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HODLWallet {\n\n    mapping(address => uint256) public balances;\n    uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(amount <= MAX_WITHDRAWAL);\n        require(balances[from] >= amount);\n        balances[from] = balances[from] - amount;\n        from.call.value(amount)();\n    }\n}\n",
            "label": 1
        },
        "146": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HODLWallet {\n\n    mapping(address => uint256) public balances;\n    uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function doWithdraw(address from,  uint256 amount) internal onlyOwner {\n        require(amount <= MAX_WITHDRAWAL);\n        require(balances[from] >= amount);\n        balances[from] = balances[from] - amount;\n        from.call.value(amount)();\n    }\n}\n",
            "label": 1
        },
        "147": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC223TokenCompatible {\n\n    mapping (address => uint) balances;\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n\t\trequire(_value <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender] - _value;\n        balances[_to] = balances[_to] + _value;\n\t    msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}\n}\n",
            "label": 1
        },
        "148": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AuctusTokenSale {\n\n\tfunction finish() public  {\n\t\tuint256 freeEthers = address(this).balance * 40 / 100;\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}\n}\n",
            "label": 0
        },
        "149": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SPRING_BOARD_1_ETH {\n\n    function Jump() public payable {\n        if(msg.value > 1 ether) {\n            msg.sender.call.value(this.balance);\n        }\n    }\n}",
            "label": 0
        },
        "150": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AutomobileCyberchainToken {\n\n    function buy(address recipient, uint256 value) public payable {\n        if (value < msg.value) {\n            require(msg.sender.call.value(msg.value - value)());  \n        }\n    }\n}",
            "label": 0
        },
        "151": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SIMPLE_PIGGY_BANK {\n\n    mapping (address => uint) public Bal;\n    uint public MinSum = 1 ether;\n\n    function Collect(uint _am) public payable {\n        if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n            msg.sender.call.value(_am);\n            Bal[msg.sender] -= _am;\n        }\n    }\n}\n",
            "label": 0
        },
        "152": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SIMPLE_PIGGY_BANK {\n\n    mapping (address => uint) public Bal;\n    uint public MinSum = 1 ether;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Collect(uint _am) public payable onlyOwner {\n        if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n            msg.sender.call.value(_am);\n            Bal[msg.sender] -= _am;\n        }\n    }\n}\n",
            "label": 0
        },
        "153": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PIGGY_BANK {\n\n    mapping (address => uint) public Accounts;\n\n    function Collect(uint _am) public payable {\n        if(_am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] -= _am;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "154": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenBank  {\n\n    mapping (address => uint) public Holders;\n    \n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[_addr] > 0) {\n            if(_addr.call.value(_wei)()) {\n                Holders[_addr] -= _wei;\n            }\n        }\n    }\n}",
            "label": 1
        },
        "155": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LuckyETH {\n\n    mapping(address => uint) playerPendingWithdrawals;\n\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}\n",
            "label": 0
        },
        "156": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LuckyETH {\n\n    mapping(address => uint) playerPendingWithdrawals;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function playerWithdrawPendingTransactions() public onlyOwner returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}\n",
            "label": 1
        },
        "157": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Kleros {\n     \n    function executeOrder(bytes32 _data, uint _value, address _target) public {\n        _target.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "158": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Kleros {\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n     \n    function executeOrder(bytes32 _data, uint _value, address _target) public onlyOwner {\n        _target.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "159": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleEthBank {\n\n    mapping (address => uint) accountBalances;\n\n    function withdraw(uint amount) public {\n        require(accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount);\n    }\n}\n",
            "label": 0
        },
        "160": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleEthBank {\n\n    mapping (address => uint) accountBalances;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        require(accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount);\n    }\n}\n",
            "label": 0
        },
        "161": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FREE_FOR_FUN {\n\n    mapping (address=>uint256) public ExtractDepositTime;\n\n    function GetFreeEther() public payable {\n        if(ExtractDepositTime[msg.sender] != 0) {\n            msg.sender.call.value(ExtractDepositTime[msg.sender])();\n            ExtractDepositTime[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "162": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Owned {\n\n    function execute(address _dst, uint _value, bytes _data) {\n        _dst.call.value(_value)(_data);\n    }\n}",
            "label": 1
        },
        "163": {
            "code": "pragma solidity ^0.4.24;\n\ncontract OwnedUpgradeabilityProxy  {\n\n    function upgradeToAndCall(bytes data) payable public {\n        require(this.call.value(msg.value)(data));\n    }\n}",
            "label": 1
        },
        "164": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LZLCoin {\n\n    mapping (address => uint) balances;\n\n    function eT(address _pd, uint _tkA) returns (bool) {\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        if (!msg.sender.call.value(_tkA)()) revert();\n        return true;\n    }\n}\n",
            "label": 0
        },
        "165": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LZLCoin {\n\n    mapping (address => uint) balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function eT(address _pd, uint _tkA) onlyOwner returns (bool) {\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        if (!msg.sender.call.value(_tkA)()) revert();\n        return true;\n    }\n}\n",
            "label": 1
        },
        "166": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherGet {\n\n    function getTokens(uint num, address addr) public {\n        for(uint i = 0; i < num; i++){\n            addr.call.value(0)();\n        }\n    }\n}",
            "label": 1
        },
        "167": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EXPERIMENTAL_ETH_AUCTION {\n\n    mapping(address => uint) public Bids;\n\n    function RevokeBid() public payable {\n        uint toTransfer = Bids[msg.sender];\n        Bids[msg.sender] = 0;\n        msg.sender.call.value(toTransfer);\n    }\n}\n",
            "label": 0
        },
        "168": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HODLerParadise {\n\n    mapping (string => uint) parameters;\n\n    function claim_reward(uint uid) public payable {\n         \n        uint final_reward = 100 + msg.value;\n\n        if (final_reward > parameters[\"price_po\u03bfl\"])\n            final_reward = parameters[\"price_po\u03bfl\"];\n\n        require(msg.sender.call.value(final_reward)());\n        parameters[\"price_po\u03bfl\"] -= final_reward;\n    }\n}\n",
            "label": 1
        },
        "169": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenBank {\n\n    mapping (address => uint) public Holders;\n    \n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[msg.sender] > 0) {\n            if(Holders[_addr] >= _wei) {\n                _addr.call.value(_wei)();\n                Holders[_addr] -= _wei;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "170": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenBank {\n\n    mapping (address => uint) public Holders;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {\n        if(Holders[msg.sender] > 0) {\n            if(Holders[_addr] >= _wei) {\n                _addr.call.value(_wei)();\n                Holders[_addr] -= _wei;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "171": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MultiSigWallet {\n\n    mapping (uint => Transaction) public transactions;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    function executeTransaction(uint transactionId) public {\n        if (transactionId > 0) {\n            Transaction tx = transactions[transactionId];\n            tx.executed = true;\n\n            if (tx.destination.call.value(tx.value)(tx.data))\n                return;\n            else {\n                tx.executed = false;\n            }\n        }\n    }\n}\n",
            "label": 0
        },
        "172": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC223Token {\n\n  address rx;\n  function transfer(uint value, bytes data) public returns (bool) {\n    if (true) {\n       require(rx.call.value(value)(data));\n    }\n    return true;\n  }\n}\n",
            "label": 1
        },
        "173": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreSaleFund {\n\n    address owner = msg.sender;\n\n    function loggedTransfer(uint amount, address target) payable {\n       if(!target.call.value(amount)()) { throw; }\n    }\n}\n",
            "label": 1
        },
        "174": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreSaleFund {\n\n    address owner = msg.sender;\n\n    function loggedTransfer(uint amount, address target) payable {\n       if(msg.sender != address(this)) throw;\n       if(!target.call.value(amount)()) { throw; }\n    }\n}\n",
            "label": 1
        },
        "175": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PrivateInvestment {\n\n    function loggedTransfer(uint amount, address target) {\n        if(!target.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "176": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AddressLottery {\n\n    mapping (address => bool) participated;\n\n    function participate() payable {\n        require(!participated[msg.sender]);\n        participated[msg.sender] = true;\n        require(msg.sender.call.value(this.balance)());\n    }\n}\n",
            "label": 0
        },
        "177": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Freebie {\n\n    address public Owner = msg.sender;\n\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}",
            "label": 1
        },
        "178": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Payee {\n    \n    uint256 public price;\n\n    function pay(uint256 count) public payable {\n        assert(msg.value >= price * count);\n        if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }\n    }\n}\n",
            "label": 1
        },
        "179": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PrivateBank {\n\n    mapping (address => uint) public balances;\n\n    function CashOut(uint _am) {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()){\n                balances[msg.sender] -= _am;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "180": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PrivateBank {\n\n    mapping (address => uint) public balances;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function CashOut(uint _am) onlyOwner {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()){\n                balances[msg.sender] -= _am;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "181": {
            "code": "pragma solidity ^0.4.24;\n\ncontract InkPublicPresale {\n\n  function withdrawEther(address _to) public {\n     assert(_to.call.value(this.balance)());\n  }\n}\n",
            "label": 1
        },
        "182": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Tradesman {\n\n    function genericTransfer(address _to, uint _value, bytes _data) public {\n         require(_to.call.value(_value)(_data));\n    }\n}\n",
            "label": 1
        },
        "183": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TrustWallet {\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n    }\n\n    Transaction[] public transactions;\n\n    function executeTransaction() public {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        require(transaction.destination.call.value(transaction.value)(transaction.data));\n    }\n}\n",
            "label": 0
        },
        "184": {
            "code": "pragma solidity ^0.4.24;\n\ncontract RNTMultiSigWallet {\n     \n    mapping (uint => WalletTransaction) public transactions;\n\n    struct WalletTransaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    function executeTransaction(uint transactionId) public {\n        WalletTransaction storage walletTransaction = transactions[transactionId];\n        walletTransaction.executed = true;\n\n        if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))\n            return;\n        else {\n            walletTransaction.executed = false;\n        }\n    }\n}\n",
            "label": 0
        },
        "185": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Distribution {\n\n    address admin;\n\n    function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n        require(msg.sender == admin);\n        require(to.call.value(value)(data));\n    }\n}\n",
            "label": 1
        },
        "186": {
            "code": "pragma solidity ^0.4.24;\n\ncontract NIZIGEN {\n\n    mapping (address => uint) balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {\n\n      if(true) {\n          if (balances[msg.sender] < _value) revert();\n          balances[msg.sender] = balances[msg.sender] - _value;\n          assert(msg.sender.call.value(_value)(_data));\n          return true;\n      }\n      return false;\n    }\n}\n",
            "label": 1
        },
        "187": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TrustWallet {\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool execution_successful;\n    }\n\n    Transaction[] public transactions;\n\n    function executeTransaction() public{\n        Transaction storage transaction = transactions[transactions.length - 1];\n        transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);\n    }\n}\n",
            "label": 0
        },
        "188": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleCapEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(weiAmount > 0);\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}\n",
            "label": 1
        },
        "189": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleCapEscrow {\n\n    mapping(address => uint256) public deposited;\n    address owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function reject(address _participant) public onlyOwner {\n        uint256 weiAmount = deposited[_participant];\n        require(weiAmount > 0);\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}\n",
            "label": 1
        },
        "190": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Distribution {\n    address admin;\n\n    function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n        require(msg.sender == admin);\n        require(to.call.value(value)(data));\n    }\n}\n",
            "label": 1
        },
        "191": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Distribution {\n    address admin;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {\n        require(msg.sender == admin);\n        require(to.call.value(value)(data));\n    }\n}\n",
            "label": 1
        },
        "192": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}\n",
            "label": 1
        },
        "193": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    mapping(address => uint256) private payments;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdrawPayments() external onlyOwner returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}\n",
            "label": 1
        },
        "194": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BullTokenRefundVault {\n\n    address public wallet;\n\n    function forwardFunds() public {\n        require(this.balance > 0);\n        wallet.call.value(this.balance)();\n    }\n}\n",
            "label": 1
        },
        "195": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LPPCampaign{\n\n    function sendTransaction(address destination, uint value, bytes data) public {\n        require(destination.call.value(value)(data));\n    }\n}\n",
            "label": 1
        },
        "196": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LPPCampaign{\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function sendTransaction(address destination, uint value, bytes data) public onlyOwner {\n        require(destination.call.value(value)(data));\n    }\n}\n",
            "label": 1
        },
        "197": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MultiplicatorX4 {\n\n    address public Owner = msg.sender;\n\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}\n",
            "label": 1
        },
        "198": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleKYCEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(weiAmount > 0);\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}\n",
            "label": 1
        },
        "199": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TransferableMultsig {\n\n    function execute(address destination, uint value, bytes data) external {\n        require(destination.call.value(value)(data));\n    }\n}\n",
            "label": 1
        },
        "200": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Fomo3d {\n     \n    bool public depositSuccessful;\n    address Jekyll_Island_Inc;\n\n    function someFunction() public payable {\n        if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n            depositSuccessful = false;\n        } else {\n            depositSuccessful = true;\n        }\n    }\n}\n",
            "label": 1
        },
        "201": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Fomo3d {\n     \n    bool public depositSuccessful;\n    address Jekyll_Island_Inc;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function someFunction() public payable onlyOwner {\n        if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n            depositSuccessful = false;\n        } else {\n            depositSuccessful = true;\n        }\n    }\n}\n",
            "label": 1
        },
        "202": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MergeCoin{\n\n    function eT(address _pd, uint _etA) returns (bool) {\n        if (!_pd.call.value(_etA)()) revert();\n        return true;\n    }\n}\n",
            "label": 1
        },
        "203": {
            "code": "pragma solidity ^0.4.24;\n\ninterface FoMo3DlongInterface {\n  function getBuyPrice() public view returns(uint256);\n  function getTimeLeft() public view returns(uint256);\n}\n\n\ncontract PwnFoMo3D {\n\n    FoMo3DlongInterface fomo3d;\n\n    function gotake() public  {\n        if (fomo3d.getTimeLeft() > 50) { revert(); }\n        address(fomo3d).call.value(fomo3d.getBuyPrice() * 2)();\n    }\n}\n",
            "label": 1
        },
        "204": {
            "code": "pragma solidity ^0.4.24;\n\ncontract VVToken {\n\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\n    function executeTransaction(bytes32 TransHash) public {\n        Transactions[TransHash].executed = true;\n        require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n    }\n}\n",
            "label": 0
        },
        "205": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MultiplicatorX3 {\n\n    address public Owner = msg.sender;\n\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}\n",
            "label": 1
        },
        "206": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Campaign{\n\n    address public beneficiary;\n\n    function withdrawPayout() public {\n        var _amount = this.balance;\n        require(beneficiary.call.value(_amount)());\n    }\n}\n",
            "label": 1
        },
        "207": {
            "code": "pragma solidity ^0.4.24;\n\ncontract IAMEToken {\n\n\taddress public devETHDestination;\n\tbool public saleHasEnded;\n\tbool public minCapReached;\n\n\tfunction endSale() {\n\t\tif (saleHasEnded) revert();\n\t\tif (!minCapReached) revert();\n\n\t\tif (this.balance > 0) {\n\t\t\tif (!devETHDestination.call.value(this.balance)()) revert();\n\t\t}\n\t}\n}",
            "label": 1
        },
        "208": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MilestoneTracker {\n\n    struct Milestone {\n        address paymentSource;\n    }\n\n    Milestone[] public milestones;\n\n\n    function authorizePayment(uint _idMilestone) internal {\n        Milestone milestone = milestones[_idMilestone];\n        if (!milestone.paymentSource.call.value(0)()) throw;\n    }\n}",
            "label": 1
        },
        "209": {
            "code": "pragma solidity ^0.4.24;\n\ncontract VVToken {\n\n    mapping (bytes32 => Transaction) public Transactions;\n\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\n    function executeTransaction(bytes32 TransHash) public {\n\t\tTransactions[TransHash].executed = true;\n        require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n    }\n}\n",
            "label": 0
        },
        "210": {
            "code": "pragma solidity ^0.4.24;\n\ncontract JBX {\n\n    function transfer( address to, bytes data)returns (bool success) {\n        require(to.call.value(0)(data));\n        success = true;\n    }\n}\n",
            "label": 1
        },
        "211": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer {\n\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n\n    function refund() {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        balances[investor] = 0;\n        if(!(investor.call.value(amount)())) throw;\n    }\n}\n",
            "label": 1
        },
        "212": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer {\n\n    mapping(address => uint) public balances;\n    bool refunded = true;\n    address investor = msg.sender;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function refund() onlyOwner {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        balances[investor] = 0;\n        if(!(investor.call.value(amount)())) throw;\n    }\n}\n",
            "label": 1
        },
        "213": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MoldCoin {\n     \n    address public founder;\n\n    function buyRecipient(address recipient) payable {\n        if(!founder.call.value(msg.value)()) revert();\n    }\n}\n",
            "label": 1
        },
        "214": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MoldCoin {\n     \n    address public founder;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function buyRecipient(address recipient) payable onlyOwner {\n        if(!founder.call.value(msg.value)()) revert();\n    }\n}\n",
            "label": 1
        },
        "215": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenLab {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        require(tokens[0][msg.sender] >= amount);\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        require(msg.sender.call.value(amount)());\n    }\n}\n",
            "label": 0
        },
        "216": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenLab {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(uint amount) onlyOwner {\n        require(tokens[0][msg.sender] >= amount);\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        require(msg.sender.call.value(amount)());\n    }\n}\n",
            "label": 1
        },
        "217": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Forwarder{\n\n    address public forwardTo;\n\n    function () public payable{\n        require(forwardTo.call.value(msg.value)(msg.data));\n    }\n}\n",
            "label": 1
        },
        "218": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Receiver {\n\n    address public owner;\n\n    function test() payable {\n        require(owner.call.value(msg.value)());\n    }\n}\n",
            "label": 1
        },
        "219": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FiatContract {\n\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n        require(_to.call.value(_value)(_data));\n        return 0;\n    }\n}\n",
            "label": 1
        },
        "220": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MoldCoin {\n     \n    address public founder;\n    uint public coinAllocation = 20 * 10**8 * 10**2;\n    uint public amountRaised = 0;\n    mapping(address => uint) balances;\n\n    function buyRecipient(address recipient) payable {\n        uint tokens = msg.value * block.timestamp;\n        require(tokens <= coinAllocation);\n        balances[recipient] = balances[recipient] + tokens;\n        amountRaised = amountRaised + msg.value;\n        if (!founder.call.value(msg.value)()) revert();\n    }\n}\n",
            "label": 1
        },
        "221": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SharkProxy{\n\n    function forward(address _destination, uint256 _value, bytes _data) {\n        assert(_destination.call.value(_value)(_data));\n    }\n}\n",
            "label": 1
        },
        "222": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MarketPrice {\n\n    address public sender;\n    address public creator;\n\n    function execute(address _to, uint _value, bytes _data) external {\n        require(msg.sender == creator);\n        require(_to.call.value(_value)(_data));\n    }\n}\n",
            "label": 1
        },
        "223": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherShot{\n\n    mapping (address => uint) playerPendingWithdrawals;\n\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        }\n        else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}\n",
            "label": 0
        },
        "224": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TradersWallet {\n\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32) {\n        require(_to.call.value(_value)(_data));\n        return 0;\n    }\n}\n",
            "label": 1
        },
        "225": {
            "code": "pragma solidity ^0.4.24;\n\ncontract generic_holder {\n\n    function execute(address _to, uint _value, bytes _data) external returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "226": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SFTToken {\n\n\taddress public devETHDestination;\n\n    function withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n",
            "label": 1
        },
        "227": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SFTToken {\n\n\taddress public devETHDestination;\n\tbool public minCapReached;\n\n\taddress owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdrawFunds() onlyOwner {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n",
            "label": 1
        },
        "228": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DeadMansSwitch {\n\n\tfunction send(address _to, uint _value, bytes _data) {\n\t\tif (!_to.call.value(_value)(_data)) throw;\n\t}\n}\n",
            "label": 1
        },
        "229": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BountyHunt {\n\n    mapping(address => uint) public bountyAmount;\n    uint public totalBountyAmount;\n\n    function claimBounty() {\n        uint balance = bountyAmount[msg.sender];\n\n        if (msg.sender.call.value(balance)()) {\n          totalBountyAmount -= balance;\n          bountyAmount[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "230": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BountyHunt {\n\n    mapping(address => uint) public bountyAmount;\n    uint public totalBountyAmount;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function claimBounty() onlyOwner {\n        uint balance = bountyAmount[msg.sender];\n\n        if (msg.sender.call.value(balance)()) {\n          totalBountyAmount -= balance;\n          bountyAmount[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "231": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HUNT {\n\n\taddress addrcnt;\n\n    function collect() {\n\t\trequire(addrcnt.call.value(this.balance)(0));\n\t}\n}",
            "label": 1
        },
        "232": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Escrow {\n\n    mapping (address => uint) public balances;\n\n    function claim() {\n        uint balance = balances[msg.sender];\n        require(balance > 0);\n        balances[msg.sender] = 0;\n        bool claimed = msg.sender.call.value(balance)();\n        require(claimed);\n    }\n}",
            "label": 0
        },
        "233": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenStore {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint _amount) {\n        require(tokens[0][msg.sender] >= _amount);\n        tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;\n        if (!msg.sender.call.value(_amount)()) { revert(); }\n    }\n}\n",
            "label": 0
        },
        "234": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SENSToken{\n\n\taddress public devETHDestination;\n\n\tfunction withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n",
            "label": 1
        },
        "235": {
            "code": "pragma solidity ^0.4.24;\n\ncontract CoinDashBuyer {\n   \n    uint256 public bounty = 1;\n    address public sale;\n\n    function claim_bounty(){\n        if(!sale.call.value(this.balance - bounty)()) throw;\n    }\n}\n",
            "label": 1
        },
        "236": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Wallet{\n\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n        if (_value == 0) {\n            require(_to.call.value(_value)(_data));\n            return 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "237": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Ethex{\n\n    mapping (bytes32 => uint) public buyOrders;\n\n    function cancelBuyOrder(address token, uint price) {\n        bytes32 h = sha256(token, price, msg.sender);\n        uint remain = buyOrders[h];\n        delete buyOrders[h];\n        if (!msg.sender.call.value(remain)()) throw;\n    }\n}\n",
            "label": 1
        },
        "238": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer{\n\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n\n    function refund()  {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        delete balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n    }\n}\n",
            "label": 1
        },
        "239": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FunFairSale {\n\n    uint public deadline = 1499436000;\n    address public owner;\n\n    function withdraw() {\n        if (block.timestamp < deadline) throw;\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}\n",
            "label": 1
        },
        "240": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FunFairSale {\n\n    address public owner;\n\n    function withdraw() {\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}\n",
            "label": 1
        },
        "241": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenPool {\n\n    uint public rewardPercentage = 30;\n    uint public amountRaised = 100;\n    address public tokenCreateContract;\n    bytes4 tokenCreateFunctionHash;\n    mapping (address => uint) balances;\n\n    function CreateTokens() {\n        uint amount = amountRaised * (100 - rewardPercentage) / 100;\n        if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n        balances[tokenCreateContract] -= amount;\n    }\n}\n",
            "label": 1
        },
        "242": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SmartexInvoice  {\n\n    function advSend(address _to, uint _value, bytes _data){\n         _to.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "243": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DecentrEx{\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "244": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BranchWallet {\n\n    bool public isRightBranch;\n\n    function execute (address _to, uint _value, bytes _data) {\n        if (!_to.call.value(_value)(_data)) throw;\n    }\n}",
            "label": 1
        },
        "245": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DAS {\n\n    Proposal[] public proposals;\n\n    enum ProposalState { Executed}\n\n    struct Proposal {\n        address beneficiary;\n        uint256 etherAmount;\n        ProposalState state;\n    }\n\n    function executeProposal(uint256 _proposalID, bytes _transactionBytecode)  {\n        Proposal p = proposals[_proposalID];\n        p.state = ProposalState.Executed;\n        if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }\n    }\n}",
            "label": 1
        },
        "246": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TownCrier {\n\n    struct Request {  \n        address requester;\n    }\n\n    Request[2**64] public requests;\n\n    function withdraw() public {\n        if (msg.sender == requests[0].requester) {\n            if (!requests[0].requester.call.value(this.balance)()) { throw; }\n        }\n    }\n}",
            "label": 0
        },
        "247": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Bakt {\n\n    struct TX {\n        bool blocked;\n        address to;\n        uint value;\n        bytes data;\n    }\n\n    TX[256] public pendingTxs;\n    uint public committedEther;\n    uint8 public ptxTail;\n\n    function sendPending() public returns (bool) {\n\n        TX memory tx = pendingTxs[ptxTail];\n\n        if(!tx.blocked) {\n            if(tx.to.call.value(tx.value)(tx.data)) {\n                committedEther -= tx.value;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
            "label": 1
        },
        "248": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Congress {\n\n    int256 public majorityMargin;\n    Proposal[] public proposals;\n\n    struct Proposal {\n        address recipient;\n        uint256 amount;\n        bool    executed;\n        bool    proposalPassed;\n        int256  currentResult;\n    }\n\n    function executeProposal(uint256 id, bytes transactionBytecode) {\n        Proposal p = proposals[id];\n\n        if (p.currentResult > majorityMargin) {\n            if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;\n            p.proposalPassed = true;\n        } else {\n            p.proposalPassed = false;\n        }\n    }\n}\n",
            "label": 1
        },
        "249": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Token {\n\n    function execute(address _dst, uint _value, bytes _data) {\n        _dst.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "250": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AddressOwnershipVerification {\n\n    mapping(address => mapping (address => uint32)) verifications;\n\n    function revoke(address transactor, address transactee) {\n        uint32 deposit = verifications[transactor][transactee];\n        verifications[transactor][transactee] = 0;\n        if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n    }\n}\n",
            "label": 1
        },
        "251": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Blockjack {\n\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n    address public owner;\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) throw;\n        _;\n    }\n\n    function migrateBlockjack() onlyOwner {\n        if (currentBankroll > initialBankroll) {\n          if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;\n        }\n    }\n}",
            "label": 1
        },
        "252": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherprisesLLC {\n\n    mapping (address => address) public latestSeriesForUser;\n     \n    function () payable {\n        if (latestSeriesForUser[msg.sender] != 0) {\n            if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;\n        }\n    }\n}\n\n",
            "label": 1
        },
        "253": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FDC {\n\n    address public foundationWallet;\n\n    function empty() returns (bool) {\n        return foundationWallet.call.value(this.balance)();\n    }\n}\n\n",
            "label": 1
        },
        "254": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherollCrowdfund{\n\n    mapping (address => uint) public balanceOf;\n\n    function calcRefund(address _addressToRefund) internal {\n        uint amount = balanceOf[_addressToRefund];\n        balanceOf[_addressToRefund] = 0;\n\n        if (amount > 0) {\n            if (_addressToRefund.call.value(amount)()) {\n                return;\n            } else {\n                balanceOf[_addressToRefund] = amount;\n            }\n        } \n    }\n}",
            "label": 1
        },
        "255": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherollCrowdfund{\n\n    mapping (address => uint) public balanceOf;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function calcRefund(address _addressToRefund) internal onlyOwner {\n        uint amount = balanceOf[_addressToRefund];\n        balanceOf[_addressToRefund] = 0;\n\n        if (amount > 0) {\n            if (_addressToRefund.call.value(amount)()) {\n                return;\n            } else {\n                balanceOf[_addressToRefund] = amount;\n            }\n        } \n    }\n}",
            "label": 1
        },
        "256": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Blockjack {\n\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n\n    mapping (address => bool) public isOwner;\n    mapping (address => uint) public balances;\n\n    modifier onlyOwner {\n        if (!isOwner[msg.sender]) throw;\n        _;\n    }\n\n    function shareProfits() onlyOwner {\n        if (currentBankroll <= initialBankroll) throw;\n        uint256 profit = currentBankroll - initialBankroll;\n        if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n        currentBankroll -= profit;\n        balances[ADMIN_CONTRACT] -= profit;\n    }\n}",
            "label": 1
        },
        "257": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Blockjack {\n\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n\n    mapping (address => uint) public balances;\n\n    function shareProfits() {\n        if (currentBankroll <= initialBankroll) throw;\n        uint256 profit = currentBankroll - initialBankroll;\n        if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n        currentBankroll -= profit;\n        balances[ADMIN_CONTRACT] -= profit;\n    }\n}",
            "label": 1
        },
        "258": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ValueTrader{\n\n    function buyEther(uint256 amount) {\n        assert(msg.sender.call.value(amount)());\n    }\n}",
            "label": 1
        },
        "259": {
            "code": "pragma solidity ^0.4.24;\n\ncontract NinjaToken {\n\n    mapping(address=>string) public commit;\n    mapping(address=>uint) public balances;\n    address public fundingAccount;\n\n    function buy(string _commit) payable {\n        if(!fundingAccount.call.value(msg.value)()) throw;\n        balances[fundingAccount] -= msg.value;\n        commit[msg.sender] = _commit;\n    }\n}\n",
            "label": 1
        },
        "260": {
            "code": "pragma solidity ^0.4.24;\n\ncontract NinjaToken {\n\n    mapping(address=>string) public commit;\n    mapping(address=>uint) public balances;\n    address public fundingAccount;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function buy(string _commit) payable onlyOwner {\n        if(!fundingAccount.call.value(msg.value)()) throw;\n        balances[fundingAccount] -= msg.value;\n        commit[msg.sender] = _commit;\n    }\n}\n",
            "label": 1
        },
        "261": {
            "code": "pragma solidity ^0.4.24;\n\ncontract CampaignBeneficiary{\n\n    address public Resilience;\n\n    function simulatePathwayFromBeneficiary() public payable {\n        bytes4 buySig = bytes4(sha3(\"buy()\"));\n        if (!Resilience.call.value(msg.value)(buySig)) throw;\n    }\n}",
            "label": 1
        },
        "262": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Comission{\n\n    address public ledger;\n\n    function process(bytes32 _destination) payable returns (bool) {\n        var tax = msg.value / 100;\n        if (!ledger.call.value(tax)()) throw;\n        return true;\n    }\n}",
            "label": 1
        },
        "263": {
            "code": "pragma solidity ^0.4.24;\n\ncontract NIZIGEN {\n\n    mapping (address => uint) balances;\n\n    function transfer(uint _value, bytes _data) public returns (bool) {\n\n      if(true) {\n          if (balances[msg.sender] < _value) revert();\n          balances[msg.sender] = balances[msg.sender] - _value;\n          assert(msg.sender.call.value(_value)(_data));\n          return true;\n      }\n      else {\n          return false;\n      }\n    }\n}\n",
            "label": 1
        },
        "264": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}\n",
            "label": 1
        },
        "265": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MultiAccess{\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function multiAccessCallD(address _to, uint _value, bytes _data) external onlyOwner returns(bool) {\n        return _to.call.value(_value)(_data);\n    }\n}",
            "label": 1
        },
        "266": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    uint256 private totalBalance;\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        totalBalance -= payment;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}",
            "label": 1
        },
        "267": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Wallet {\n\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n         if (_value == 0) {\n            _to.call.value(_value)(_data);\n            return 0;\n        }\n    }\n}",
            "label": 1
        },
        "268": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Owned {\n\n    function execute(address _dst, uint _value, bytes _data) {\n        _dst.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "269": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DaoAccount {\n\n\tuint256 tokenBalance;  \n    address owner;\n\tuint256 tokenPrice;\n\t \n\tfunction withdraw(uint256 tokens) {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.call.value(tokens * tokenPrice)()) throw;\n\t}\n}\n",
            "label": 1
        },
        "270": {
            "code": "pragma solidity ^0.4.24;\n\ncontract YesNo {\n\n    address public feeAccount;\n    uint public fee;\n\n    function redeem(uint tokens) {\n        uint abc = tokens * fee;\n        if (!feeAccount.call.value(abc /(1 ether))()) throw;\n    }\n}\n",
            "label": 1
        },
        "271": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherDelta {\n\n    mapping (address => mapping (address => uint)) tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "272": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Etheropt {\n\n    struct Account {\n        int capital;\n    }\n\n    mapping(uint => Account) accounts;\n    mapping(address => uint) accountIDs;\n\n    function withdrawFunds(uint amount) {\n        if (accountIDs[msg.sender] > 0) {\n          if (int(amount) > 0) {\n            accounts[accountIDs[msg.sender]].capital -= int(amount);\n            msg.sender.call.value(amount)();\n          }\n        }\n    }\n}",
            "label": 1
        },
        "273": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract Ethsplit {\n\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;\n\n    function split(address etcAddress) {\n        if (amIOnTheFork.forked()) {\n            uint fee = msg.value / 100;\n            fees.send(fee);\n            etcAddress.call.value(msg.value)();\n        }\n    }\n}\n",
            "label": 1
        },
        "274": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DaoAccount {\n\n\tuint256 tokenBalance;\n    address owner;\n\taddress daoChallenge;\n\tuint256 tokenPrice;\n\n\tmodifier onlyOwner() {\n\t    if (daoChallenge != msg.sender) throw;\n\t    _;\n\t}\n\n\tfunction withdraw(uint256 tokens) onlyOwner {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.call.value(tokenPrice * tokens)()) throw;\n\t}\n}",
            "label": 1
        },
        "275": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract SellETCSafely {\n     \n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    function split(address ethDestination) {\n        if (amIOnTheFork.forked()) {\n            ethDestination.call.value(msg.value)();\n        }\n    }\n}\n",
            "label": 1
        },
        "276": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BranchWallet {\n\n    function execute (address _to, uint _value, bytes _data) {\n        if (!_to.call.value(_value)(_data)) throw;\n    }\n}\n",
            "label": 1
        },
        "277": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DaoChallenge {\n\n\tfunction withdrawEtherOrThrow(uint256 amount) {\n\t\tbool result = msg.sender.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}\n}",
            "label": 1
        },
        "278": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherDelta {\n\n    mapping (address => mapping (address => uint)) tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n        tokens[0][msg.sender] -= amount;\n    }\n}\n",
            "label": 1
        },
        "279": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MyEtherBank {\n\n    uint256 private _bankDonationsBalance = 0;\n\n    function BankOwner_WithdrawDonations() public {\n        if (_bankDonationsBalance > 0) {\n            uint256 amount_ = _bankDonationsBalance;\n            _bankDonationsBalance = 0;\n            if (!msg.sender.call.value(amount_)()) { throw; }\n        }\n    }\n}",
            "label": 1
        },
        "280": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Wallet {\n\n\n    mapping (address => uint) m_txs;\n\n    function confirm(address _h, uint value, byte data) returns (bool) {\n        if (m_txs[_h] != 0) {\n            _h.call.value(value)(data);\n            m_txs[_h] -= value;\n            return true;\n        }\n    }\n}\n\n",
            "label": 1
        },
        "281": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ManagedAccount{\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (_recipient.call.value(_amount)()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
            "label": 1
        },
        "282": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Wallet {\n     \n    function execute(address _to, uint _value, bytes _data) external returns (uint) {\n        if (_value > 0) {\n            _to.call.value(_value)(_data);\n            return 0;\n        }\n    }\n}",
            "label": 1
        },
        "283": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Bank{\n\n    mapping (address => uint256) public balances;\n\n    function withdraw() {\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "284": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Owner{\n    mapping (address => uint) private rewardsForA;\n\n    function untrustedWithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n    }\n}",
            "label": 1
        },
        "285": {
            "code": "pragma solidity ^0.4.24;\n\ncontract crossFunctionReentrancy{\n\n    mapping (address => uint) private rewardsForA;\n\n    function WithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        require(recipient.call.value(amountToWithdraw)());\n    }\n}\n",
            "label": 1
        },
        "286": {
            "code": "pragma solidity ^0.4.24;\n\ncontract dumbDAO {\n\n    mapping (address => uint) public balances;\n\n    function withdraw(address _recipient) returns (bool) {\n\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}\n",
            "label": 1
        },
        "287": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherStore {\n\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        require(_weiToWithdraw <= withdrawalLimit);\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n    }\n}\n\n",
            "label": 1
        },
        "288": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n    mapping (address => uint) userBalance;\n\n    function withdrawBalance_fixed() {\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if(!(msg.sender.call.value(amount)())){ throw; }\n    }\n}\n",
            "label": 1
        },
        "289": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ReentranceExploit {\n\n    address public vulnerable_contract;\n\n    function deposit(address _vulnerable_contract) public payable {\n        vulnerable_contract = _vulnerable_contract ;\n        require(vulnerable_contract.call.value(msg.value)());\n    }\n}\n",
            "label": 0
        },
        "290": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SendBalance {\n\n    mapping (address => uint) userBalances ;\n\n    function withdrawBalance() {\n        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n        userBalances[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "291": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleDAO {\n\n    mapping (address => uint) public credit;\n\n    function withdraw(uint amount) {\n        if (credit[msg.sender] >= amount) {\n          msg.sender.call.value(amount)();\n          credit[msg.sender] -= amount;\n        }\n    }\n}",
            "label": 1
        },
        "292": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Victim {\n\n    mapping(address => uint) public balances;\n\n    function withdraw(uint _amount) public {\n        if(balances[msg.sender] >= _amount) {\n            if(!msg.sender.call.value(_amount)()) { throw; }\n            balances[msg.sender] -= _amount;\n        }\n    }\n}\n",
            "label": 1
        },
        "293": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PIGGY_BANK {\n\n    mapping (address => uint) public Accounts;\n    uint public MinSum = 1 ether;\n    uint putBlock;\n\n    function Collect(uint _am) public payable {\n        if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] -= _am;\n            }\n        }\n    }\n}",
            "label": 1
        },
        "294": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BancorBuyer {\n\n    mapping(address => uint256) public balances;\n\n    function buyOne(address _exchange, uint256 _value, bytes _data) payable public {\n        require(_exchange.call.value(_value)(_data));\n        balances[msg.sender] = balances[msg.sender] - _value;\n    }\n}",
            "label": 1
        },
        "295": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Bank{\n\n    mapping (address => uint256) public balances;\n\n    function withdraw(){\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "296": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Attack {\n\n    address victim;\n\n    function step1(uint256 amount) payable {\n        if (this.balance >= amount) {\n            victim.call.value(amount)();\n        }\n    }\n}\n",
            "label": 1
        },
        "297": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Owner{\n\n    mapping (address => uint) private rewardsForA;\n\n    function WithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        require(recipient.call.value(amountToWithdraw)());\n    }\n}",
            "label": 1
        },
        "298": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Owner{\n\n    mapping (address => uint) private rewardsForA;\n\n    function untrustedWithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n    }\n}",
            "label": 1
        },
        "299": {
            "code": "pragma solidity ^0.4.24;\n\ncontract dumbDAO {\n\n    mapping (address => uint) public balances;\n\n    function withdraw(address _recipient) returns (bool) {\n        if (balances[msg.sender] == 0){ throw; }\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}\n",
            "label": 1
        },
        "300": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherStore {\n\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        require(_weiToWithdraw <= withdrawalLimit);\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n    }\n}\n\n",
            "label": 1
        },
        "301": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n\n    mapping (address => uint) userBalance;\n\n    function withdrawBalance_fixed(){\n        uint amount = userBalance[msg.sender];\n        if(!(msg.sender.call.value(amount)())){ throw; }\n        userBalance[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "302": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Private_Bank {\n\n    mapping (address => uint) public balances;\n\n    function CashOut(uint _am)  {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                balances[msg.sender] -= _am;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "303": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n\n    mapping (address => uint) userBalance;\n\n    function withdrawBalance(){\n        if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }\n        userBalance[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "304": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n\n    mapping(address => uint) public balances;\n\n    function withdraw(uint _amount) public {\n        if(balances[msg.sender] >= _amount) {\n          if(msg.sender.call.value(_amount)()) {\n             balances[msg.sender] -= _amount;\n          }\n        }\n    }\n}",
            "label": 1
        },
        "305": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n\n    mapping (address => uint) userBalance;\n\n    function withdrawBalance_fixed(){\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if(!(msg.sender.call.value(amount)())){ throw; }\n    }\n}\n",
            "label": 1
        },
        "306": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ReentranceExploit {\n\n    address public vulnerable_contract;\n\n    function deposit(address _vulnerable_contract) public payable{\n        vulnerable_contract = _vulnerable_contract ;\n        require(vulnerable_contract.call.value(msg.value)());\n    }\n}\n",
            "label": 0
        },
        "307": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SendBalance {\n\n    mapping (address => uint) userBalances ;\n    bool withdrawn = false ;\n\n    function withdrawBalance(){\n        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }\n        userBalances[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "308": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleDAO {\n\n    mapping (address => uint) public credit;\n\n    function withdraw(uint amount) public {\n        if (credit[msg.sender] >= amount) {\n          require(msg.sender.call.value(amount)());\n          credit[msg.sender] -= amount;\n        }\n    }\n}",
            "label": 1
        },
        "309": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleDAO {\n\n    mapping (address => uint) public credit;\n\n    function withdraw(uint amount) public {\n        if (credit[msg.sender] >= amount) {\n          credit[msg.sender] -= amount;\n          require(msg.sender.call.value(amount)());\n        }\n    }\n}\n",
            "label": 0
        },
        "310": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleDAO {\n\n    mapping (address => uint) public credit;\n\n    function withdraw(uint amount) {\n        if (credit[msg.sender] >= amount) {\n          msg.sender.call.value(amount)();\n          credit[msg.sender] -= amount;\n        }\n    }\n}",
            "label": 1
        },
        "311": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Victim {\n   \n    mapping(address => uint) public balances;\n\n    function withdraw(uint _amount) public {\n        if(balances[msg.sender] >= _amount) {\n            if(msg.sender.call.value(_amount)()) {\n                balances[msg.sender] -= _amount;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "312": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Tradesman {\n\n    address public owner;\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n     \n    function genericTransfer(address _to, uint _value, bytes _data) onlyOwner public {\n         require(_to.call.value(_value)(_data));\n    }\n}",
            "label": 1
        },
        "313": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BaseWallet {\n\n    function invoke(address _target, uint _value, bytes _data) external {\n        bool success = _target.call.value(_value)(_data);\n        require(success);\n    }\n}",
            "label": 1
        },
        "314": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenCreation {\n\n    mapping (address => uint256) balances;\n    uint256 public totalSupply;\n\n    function refund() {\n        if (msg.sender.call.value(balances[msg.sender])()) {\n            totalSupply -= balances[msg.sender];\n            balances[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "315": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherDeltaExchange {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}",
            "label": 1
        },
        "316": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HoneyPot {\n    mapping (address => uint) public balances;\n\n    function get() {\n        if (!msg.sender.call.value(balances[msg.sender])()) { throw; }\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "317": {
            "code": "pragma solidity ^0.4.24;\n \ncontract MultiplicatorX3 {\n\n    function Command(address adr, bytes data) payable public {\n        adr.call.value(msg.value)(data);\n    }\n}",
            "label": 1
        },
        "318": {
            "code": "pragma solidity ^0.4.24;\n\ncontract NBUNIERC20 {\n\n    mapping(address => uint256) private balances;\n\n    function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public {\n        bool success = msg.sender.call.value(address(this).balance)();\n        balances[msg.sender] = balances[address(this)];\n        balances[address(this)] = 0;\n    }\n}\n",
            "label": 1
        },
        "319": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Private_Bank {\n\n    mapping (address => uint) public balances;\n\n    function CashOut(uint _am) {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()){\n                balances[msg.sender] -= _am;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "320": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n    mapping (address => uint) userBalance;\n\n    function withdrawBalance(){\n        if( !(msg.sender.call.value(userBalance[msg.sender])()) ){ throw; }\n        userBalance[msg.sender] = 0;\n    }\n}\n\n",
            "label": 1
        },
        "321": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ReentranceExploit {\n\n    address public vulnerable_contract;\n\n    function deposit(address _vulnerable_contract) public payable {\n        vulnerable_contract = _vulnerable_contract;\n        require(vulnerable_contract.call.value(msg.value)());\n    }\n}\n",
            "label": 0
        },
        "322": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Vault {\n    mapping(address => uint) public balances;\n\n    function redeem() {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "323": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Token {\n    mapping (address => uint256) public balances;\n\n    function withdraw(uint _amount) public {     \n        require(balances[msg.sender] >= _amount);\n        if(msg.sender.call.value(_amount)()) {\n            balances[msg.sender] -= _amount;        \n        }\n    }\n}\n",
            "label": 1
        },
        "324": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Token {\n    mapping (address => uint256) public balances;\n\n    function withdraw(uint _amount) public {     \n        require(balances[msg.sender] >= _amount);\n        if(msg.sender.call.value(_amount).gas(2000)()) {\n            balances[msg.sender] -= _amount;        \n        }\n    }\n}\n",
            "label": 1
        },
        "325": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Token {\n    mapping (address => uint256) public balances;\n\n    function withdraw(uint _amount) public {     \n        require(balances[msg.sender] >= _amount);\n        balances[msg.sender] -= _amount;  \n        if(!msg.sender.call.value(_amount)()) { revert(); }\n    }\n}\n",
            "label": 0
        },
        "326": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Token {\n    mapping (address => uint256) public balances;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(uint _amount) public onlyOwner {\n        require(balances[msg.sender] >= _amount);\n        balances[msg.sender] -= _amount;  \n        if(!msg.sender.call.value(_amount)()) { revert(); }\n    }\n}\n",
            "label": 1
        },
        "327": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleDAO {\n\n    mapping (address => uint) public credit;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(uint amount) onlyOwner {\n        if (credit[msg.sender] >= amount) {\n          msg.sender.call.value(amount)();\n          credit[msg.sender] -= amount;\n        }\n    }\n}",
            "label": 1
        },
        "328": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Bank{\n\n    mapping (address => uint256) public balances;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw() onlyOwner {\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender]=0;\n    }\n}\n",
            "label": 1
        },
        "329": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Owner{\n    mapping (address => uint) private rewardsForA;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function untrustedWithdrawReward(address recipient) public onlyOwner {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n    }\n}",
            "label": 1
        },
        "330": {
            "code": "pragma solidity ^0.4.24;\n\ncontract dumbDAO {\n\n    mapping (address => uint) public balances;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(address _recipient) onlyOwner returns (bool) {\n        if (balances[msg.sender] == 0){ throw; }\n\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}\n",
            "label": 1
        },
        "331": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n    mapping (address => uint) userBalance;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdrawBalance_fixed() onlyOwner {\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if(!(msg.sender.call.value(amount)())){ throw; }\n    }\n}\n",
            "label": 1
        },
        "332": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SendBalance {\n\n    mapping (address => uint) userBalances ;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdrawBalance() onlyOwner {\n        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n        userBalances[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "333": {
            "code": "pragma solidity ^0.4.24;\n\ncontract mnyminer {\n    \n    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n\n    function futxMiner() public payable {\n        require(futx.call.value(msg.value)());\n    }\n}",
            "label": 1
        },
        "334": {
            "code": "pragma solidity ^0.4.24;\n\ncontract mnyminer {\n\n    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function futxMiner() public payable onlyOwner {\n        require(futx.call.value(msg.value)());\n    }\n}",
            "label": 1
        },
        "335": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokedoDaico {\n\n    address public milestoneSystem;\n\n    function forwardEther() payable public returns(bool) {\n        require(milestoneSystem.call.value(msg.value)());\n        return true;\n    }\n}\n",
            "label": 1
        },
        "336": {
            "code": "pragma solidity ^0.4.24;\n\ncontract IChain {\n\n    uint256 public amountRaised ;\n    mapping (address => uint) balances;\n\n    function finishDistribution() public returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender] - amountRaised;\n        return true;\n    }\n}\n",
            "label": 1
        },
        "337": {
            "code": "pragma solidity ^0.4.24;\n\ncontract IChain {\n    uint256 public amountRaised ;\n    mapping (address => uint) balances;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function finishDistribution() public onlyOwner returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender] - amountRaised;\n        return true;\n    }\n}\n",
            "label": 1
        },
        "338": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DividendDistributorv3 {\n    modifier onlyOwner() {\n        if(msg.sender != address(this)) throw;\n        _;\n    }\n\n    function loggedTransfer(uint amount, address target) onlyOwner {\n        if(!target.call.value(amount)()) throw;\n    }\n}",
            "label": 1
        },
        "339": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MultiplicatorX3 {\n\n    function Command(address adr,bytes data) payable public {\n        adr.call.value(msg.value)(data);\n    }\n}",
            "label": 1
        },
        "340": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Private_Bank {\n    mapping (address => uint) public balances;\n\n    function CashOut(uint _am) {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                balances[msg.sender]-=_am;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "341": {
            "code": "pragma solidity ^0.4.24;\n\ncontract NIZIGEN {\n\n    mapping (address => uint) balances;\n\n    function transfer(uint _value, bytes _data) public returns (bool) {\n      if (balances[msg.sender] < _value) revert();\n      assert(msg.sender.call.value(_value)(_data));\n      balances[msg.sender] = balances[msg.sender] - _value;\n      return true;\n    }\n}\n",
            "label": 1
        },
        "342": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HiroyukiCoinDark {\n\n    mapping(address => uint256) public balanceOf;\n\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        assert(msg.sender.call.value(_value)(_data));\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        return true;\n    }\n}\n",
            "label": 1
        },
        "343": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ELTWagerLedger {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n    }\n}\n",
            "label": 1
        },
        "344": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DividendToken {\n\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected = 0;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function collectOwedDividends() public onlyOwner returns (uint) {\n        uint amount = creditedPoints[msg.sender] / 100;\n        require(msg.sender.call.value(amount)());\n        creditedPoints[msg.sender] -= amount;\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}\n",
            "label": 1
        },
        "345": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DividendToken {\n\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected = 0;\n\n    function collectOwedDividends() public returns (uint) {\n        uint amount = creditedPoints[msg.sender] / 20;\n        require(msg.sender.call.value(amount)());\n        creditedPoints[msg.sender] -= amount;\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}\n",
            "label": 1
        },
        "346": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BoomerangLiquidity {\n\n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n    Participant[] public participants;\n    uint public payoutOrder = 0;\n\n    function payout() public {\n        uint balance = address(this).balance;\n        require(balance > 1);\n        uint investment = balance / 2;\n        balance -= investment;\n\n        while (balance > 0) {\n            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n\n            if(payoutToSend > 0){\n                participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n                participants[payoutOrder].payout -= payoutToSend;\n                balance -= payoutToSend;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "347": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HODLWallet {\n\n    mapping(address => uint256) public balances;\n\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(amount <= 0.002 * 1000000000000000000);\n        require(balances[from] >= amount);\n        from.call.value(amount)();\n        balances[from] = balances[from] - amount;\n    }\n}\n",
            "label": 1
        },
        "348": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC223TokenCompatible {\n\n    mapping (address => uint) balances;\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n\t\trequire(_value <= balances[msg.sender]);\n\t\tmsg.sender.call.value(_value)(_data);\n        balances[msg.sender] = balances[msg.sender] - _value;\n\t\treturn true;\n\t}\n}\n",
            "label": 1
        },
        "349": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AuctusTokenSale {\n\n\tfunction finish() public  {\n\t\tuint256 freeEthers = address(this).balance * 40 / 100;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t}\n}\n",
            "label": 0
        },
        "350": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LuckyETH {\n\n    mapping(address => uint) playerPendingWithdrawals;\n\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n\n        if (msg.sender.call.value(withdrawAmount)()) {\n            playerPendingWithdrawals[msg.sender] = 0;\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}\n",
            "label": 1
        },
        "351": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LZLCoin {\n\n    mapping (address => uint) balances;\n\n    function eT(address _pd, uint _tkA) returns (bool) {\n        if (!msg.sender.call.value(_tkA)()) revert();\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        return true;\n    }\n}\n",
            "label": 1
        },
        "352": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleCapEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}\n",
            "label": 1
        },
        "353": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        if (!msg.sender.call.value(payment)()) { throw; }\n        payments[msg.sender] = 0;\n        success = true;\n    }\n}\n",
            "label": 1
        },
        "354": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleKYCEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}\n",
            "label": 1
        },
        "355": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer {\n\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n\n    function refund() {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n        balances[investor] = 0;\n    }\n}\n",
            "label": 1
        },
        "356": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MoldCoin {\n     \n    address public founder;\n    uint public coinAllocation = 20 * 10**8 * 10**2;\n    uint public saleTokenSupply = 0;  \n    uint public amountRaised = 0;\n    mapping(address => uint) balances;\n\n    function buyRecipient(address recipient) payable {\n        uint tokens = msg.value * block.timestamp;\n        require(tokens <= coinAllocation);\n        balances[recipient] = balances[recipient] + tokens;\n        amountRaised = amountRaised + msg.value;\n        if (!founder.call.value(msg.value)()) revert();\n        balances[founder] -= msg.value;\n    }\n}\n",
            "label": 1
        },
        "357": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherShot{\n\n    mapping (address => uint) playerPendingWithdrawals;\n\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n\n        if (msg.sender.call.value(withdrawAmount)()) {\n            playerPendingWithdrawals[msg.sender] = 0;\n            return true;\n        }\n        else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}\n",
            "label": 1
        },
        "358": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Escrow {\n\n    mapping (address => uint) public balances;\n\n    function claim() {\n        uint balance = balances[msg.sender];\n        require(balance > 0);\n        bool claimed = msg.sender.call.value(balance)();\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "359": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AddressOwnershipVerification {\n\n    mapping(address => mapping (address => uint32)) verifications;\n\n    function revoke(address transactor, address transactee) {\n        uint32 deposit = verifications[transactor][transactee];\n        if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n        verifications[transactor][transactee] = 0;\n    }\n}\n",
            "label": 1
        },
        "360": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherollCrowdfund{\n\n    mapping (address => uint) public balanceOf;\n\n    function calcRefund(address _addressToRefund) internal {\n        uint amount = balanceOf[_addressToRefund];\n\n        if (amount > 0) {\n            if (_addressToRefund.call.value(amount)()) {\n                balanceOf[_addressToRefund] = 0;\n            } else {\n                balanceOf[_addressToRefund] = amount;\n            }\n        } \n    }\n}",
            "label": 1
        },
        "361": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        if (!msg.sender.call.value(payment)()) { throw; }\n        payments[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "362": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HODLWallet {\n\n    mapping(address => uint256) public balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function doWithdraw(address from,  uint256 amount) internal onlyOwner {\n        require(amount <= 0.002 * 1000000000000000000);\n        require(balances[from] >= amount);\n        from.call.value(amount)();\n        balances[from] = balances[from] - amount;\n    }\n}\n",
            "label": 1
        },
        "363": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleCapEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function reject(address _participant) public onlyOwner {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}\n",
            "label": 1
        },
        "364": {
            "code": "pragma solidity ^0.4.24;\n\ncontract generic_holder {\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "365": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FDC {\n\n    address public foundationWallet;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function empty() onlyOwner returns(bool) {\n        return foundationWallet.call.value(this.balance)();\n    }\n}\n\n",
            "label": 1
        },
        "366": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Accounting {\n\n    struct Account {\n        uint balanceETH;\n        address _to;\n    }\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transact(Account storage a, uint _value, bytes data) internal onlyOwner {\n        require(a.balanceETH >= _value);\n        require(a._to.call.value(_value)(data));\n        a.balanceETH = a.balanceETH - _value;\n    }\n}\n",
            "label": 1
        },
        "367": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Escrow {\n\n    mapping (address => uint) public balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function claim() onlyOwner {\n        uint balance = balances[msg.sender];\n        msg.sender.call.value(balance)();\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "368": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AddressOwnershipVerification {\n\n    mapping(address => mapping (address => uint32)) verifications;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function revoke(address transactor, address transactee) onlyOwner {\n        uint32 deposit = verifications[transactor][transactee];\n        if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n        verifications[transactor][transactee] = 0;\n    }\n}\n",
            "label": 1
        },
        "369": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer {\n\n    mapping(address => uint) public balances;\n    bool refunded = true;\n    address investor = msg.sender;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function refund() onlyOwner {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n        balances[investor] = 0;\n    }\n}\n",
            "label": 1
        },
        "370": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FunFairSale {\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw() onlyOwner {\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}\n",
            "label": 1
        },
        "371": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BasicCrowdsale {\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function mintETHRewards(address _contract, uint256 _amount) public onlyOwner {\n        require(_contract.call.value(_amount)());\n    }\n}\n",
            "label": 1
        },
        "372": {
            "code": "pragma solidity ^0.4.24;\n\ncontract dumbDAO {\n\n    mapping (address => uint) public balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(address _recipient) onlyOwner returns (bool) {\n        if (balances[msg.sender] == 0){ throw; }\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}\n",
            "label": 1
        },
        "373": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n\n    mapping(address => uint) public balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(uint _amount) public onlyOwner {\n        if(balances[msg.sender] >= _amount) {\n          if(msg.sender.call.value(_amount)()) {\n             balances[msg.sender] -= _amount;\n          }\n        }\n    }\n}",
            "label": 1
        },
        "374": {
            "code": "pragma solidity ^0.4.24;\n\ncontract fomo3d {\n    function withdraw() public;\n}\n\ncontract giveAirdrop {\n\n    mapping (address => uint) balances;\n\n    function test() public payable {\n        fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));\n        require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());\n        balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;\n    }\n}\n",
            "label": 1
        },
        "375": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Forwarder {\n   \n    address public parentAddress;\n\n    function flush() {\n        if (!parentAddress.call.value(this.balance)()) throw;\n    }\n}",
            "label": 1
        },
        "376": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Forwarder {\n   \n    address public parentAddress;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function flush() onlyOwner {\n        if (!parentAddress.call.value(this.balance)()) throw;\n    }\n}",
            "label": 1
        },
        "377": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HiroyukiCoinDark {\n\n    mapping(address => uint256) public balanceOf;\n\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        balanceOf[_to] = balanceOf[_to] + _value;\n        assert(msg.sender.call.value(0)());\n        return true;\n    }\n}\n",
            "label": 1
        },
        "378": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HiroyukiCoinDark {\n\n    mapping(address => uint256) public balanceOf;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transfer(address _to, uint _value, bytes _data) public onlyOwner returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        balanceOf[_to] = balanceOf[_to] + _value;\n        assert(msg.sender.call.value(0)());\n        return true;\n    }\n}\n",
            "label": 1
        },
        "379": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BancorBuyer {\n\n    mapping(address => uint256) public balances;\n\n    function buyInternal(address _exchange, uint256 _value, bytes _data) internal {\n        require(_exchange.call.value(_value)(_data));\n        balances[_exchange] = balances[_exchange] - _value;\n    }\n\n}\n",
            "label": 1
        },
        "380": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BancorBuyer {\n\n    mapping(address => uint256) public balances;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function buyInternal(address _exchange, uint256 _value, bytes _data) internal onlyOwner {\n        require(_exchange.call.value(_value)(_data));\n        balances[_exchange] = balances[_exchange] - _value;\n    }\n}\n",
            "label": 1
        },
        "381": {
            "code": "pragma solidity ^0.4.24;\n\ncontract CHCommittee {\n   \n    function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {\n        return _to.call.value(_value).gas(_gas)(_code);\n    }\n}\n",
            "label": 1
        },
        "382": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ELTWagerLedger {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "383": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ELTWagerLedger {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "384": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleBet {\n\n\tbool locked = false;\n\n\tfunction bet() payable {\n\t\tif ((msg.value == 1 ether) && (!locked)) {\n\t\t\tif (!msg.sender.call.value(2 ether)())\n\t\t\t    locked = true;\n\t\t\t\tthrow;\n\t\t}\n\t}\n}\n",
            "label": 1
        },
        "385": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Overflow_fixed_assert {\n\n    uint8 sellerBalance = 0;\n\n    function add(uint8 value) returns (uint){\n        sellerBalance += value;\n        assert(sellerBalance >= value);\n        return sellerBalance;\n    }\n}",
            "label": 0
        },
        "386": {
            "code": "pragma solidity ^0.4.24;\ncontract KOIOSTokenSale {\n\tuint256 public startingTimestamp = 1518696000;\n\n\tfunction isValidPurchase() internal constant returns (bool) {\n\t\tbool validTimestamp = startingTimestamp <= block.timestamp;\n\t\treturn validTimestamp;\n\t}\n}",
            "label": 0
        },
        "387": {
            "code": "pragma solidity ^0.4.24;\ncontract MuskTokenVault {\n    uint256 public teamVestingStages = 8;\n    uint256 public lockedAt = 0;\n\n    function teamVestingStage() public view returns(uint256){\n        uint256 stage = block.timestamp - lockedAt;\n\n        if(stage > teamVestingStages){\n            stage = teamVestingStages;\n        }\n        return stage;\n    }\n}",
            "label": 0
        },
        "388": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ParcelXToken {\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "389": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenVesting {\n  uint public cliff;\n  mapping (address => uint) public released;\n\n  function vestedAmount(address _token) public view returns (uint) {\n    uint totalBalance = released[_token] + 17777777;\n\n    if (100 < cliff) {\n      return totalBalance * block.timestamp;\n    }\n  }\n}",
            "label": 0
        },
        "390": {
            "code": "pragma solidity ^0.4.24;\ncontract BasicAccessControl {\n\n    function getRandom(uint _seed) constant public returns(uint) {\n        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;\n    }\n}",
            "label": 0
        },
        "391": {
            "code": "pragma solidity ^0.4.24;\ncontract TUINETWORK {\n\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;\n\n    function inAllocationLockPeriod() constant returns (bool) {\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n    }\n}",
            "label": 0
        },
        "392": {
            "code": "pragma solidity ^0.4.24;\ncontract BitSongCrowdsale {\n    uint256 public openingTime;\n    uint256 public closingTime;\n    uint256 public duration;\n\n    function startDistribution() external returns (uint256) {\n        openingTime = block.timestamp;\n        closingTime = openingTime + duration;\n        return closingTime;\n    }\n}",
            "label": 0
        },
        "393": {
            "code": "pragma solidity ^0.4.24;\ncontract Fluzcoin {\n    uint public launched = 0;  \n\n    function launch() public returns(uint){\n        launched = block.timestamp;\n        return launched;\n    }\n}",
            "label": 0
        },
        "394": {
            "code": "pragma solidity ^0.4.24;\ncontract UniDAGCrowdsale {\n    uint256 public rateFirstRound = 4000;\n\tuint256 public secondRoundTime = 1539129600;\n\n    function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {\n        if(block.timestamp < secondRoundTime)\n            return _weiAmount * rateFirstRound;\n    }\n}",
            "label": 0
        },
        "395": {
            "code": "pragma solidity ^0.4.24;\ncontract ProgressiveIndividualCappedCrowdsale {\n    uint public startGeneralSale;\n    uint public constant TIME_PERIOD_IN_SEC = 1 days;\n\n    function getCurrentEthCapPerAddress() public constant returns(uint) {\n        uint time = block.timestamp;\n        uint timeSinceStartInSec = time - startGeneralSale;\n        uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC);\n        return currentPeriod * 2;\n    }\n}\n",
            "label": 0
        },
        "396": {
            "code": "pragma solidity ^0.4.24;\ncontract AccessAdmin {\n    uint64 public endDiscountTime = 0;\n\n    function _buyDiscountTTM(uint256 _value) private {\n        if (block.timestamp <= endDiscountTime) {\n            require(_value == 0.64 ether);\n        }\n        else {\n            require(_value == 0.99 ether);\n        }\n    }\n}\n",
            "label": 0
        },
        "397": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale {\n    uint openingTime = 0;\n\n    function TimedCrowdsal(uint256 _openingTime) public returns (bool) {\n        require(_openingTime >= block.timestamp);\n        openingTime = _openingTime;\n        return true;\n    }\n}",
            "label": 0
        },
        "398": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable1 {\n  uint public startsAt;\n  enum State { PreFunding, Funding}\n\n  function getState() public constant returns (State) {\n    if (block.timestamp < startsAt) {\n        return State.PreFunding;\n    } else {\n        return State.Funding;\n    }\n  }\n}",
            "label": 1
        },
        "399": {
            "code": "pragma solidity ^0.4.24;\ncontract ArenaPool {\n    uint64 nextArenaTime;\n\n    function sendArena() external returns (uint64){\n        uint64 tmNow = uint64(block.timestamp);\n        nextArenaTime = tmNow + 21600;\n        return nextArenaTime;\n    }\n}",
            "label": 0
        },
        "400": {
            "code": "pragma solidity ^0.4.24;\ncontract LOTT {\n    uint public rand1;\n    uint8 public rand2;\n    \n    mapping (uint => mapping (uint8 => address)) public map;\n\n    function place(uint8 cell) external returns (uint){\n        rand1 += uint(msg.sender) + block.timestamp;\n        rand2 -= uint8(msg.sender);\n        return rand2 + rand2;\n     }\n}",
            "label": 1
        },
        "401": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenTimelock {\n  uint256 public token;\n  uint256 public releaseTime;\n\n  function release() public returns (uint256){\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token * 2000000;\n    return amount;\n  }\n}\n",
            "label": 1
        },
        "402": {
            "code": "pragma solidity ^0.4.24;\ncontract WorkIt {\n  uint public startDate = 20120;\n  uint secondsPerDay = 86400;\n\n  function currentDay() public view returns (uint) {\n    return (block.timestamp - startDate) / secondsPerDay;\n  }\n}",
            "label": 0
        },
        "403": {
            "code": "pragma solidity ^0.4.24;\ncontract PartialBasic {\n  uint256 public totalNodes;\n  uint256 private rewardTimestamp;\n\n  function rewardPerNode() public view returns (uint256) {\n    uint256 totalDays = block.timestamp - rewardTimestamp;\n    uint256 newReward = totalDays / totalNodes;\n    return totalDays + newReward;\n  }\n}",
            "label": 0
        },
        "404": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n    }\n}",
            "label": 0
        },
        "405": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n        uint256 parameter;\n    }\n    Proposal public currentProposal;\n    bool public proposalInProgress = false;\n\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n        currentProposal.parameter = parameter;\n        proposalInProgress = true;\n    }\n}",
            "label": 0
        },
        "406": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n    uint256 constant proposalLife = 7 days;\n\n    function voteOnProposal(bool voteFor) external {\n        require((block.timestamp - currentProposal.timestamp) <= proposalLife);\n    }\n}",
            "label": 1
        },
        "407": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Halo3D {\n\n    uint totalEthCharityRecieved = 0;\n    uint totalEthCharityCollected = 100;\n    address public giveEthCharityAddress;\n     \n    function payCharity() payable public {\n\n      uint256 ethToPay = totalEthCharityCollected -  totalEthCharityRecieved;\n\n      if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {\n         totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;\n      }\n    }\n}\n",
            "label": 1
        },
        "408": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FsTKerWallet {\n\n  function callContract(address to, bytes data) public payable returns (bool) {\n    require(to.call.value(msg.value)(data));\n    return true;\n  }\n}\n",
            "label": 1
        },
        "409": {
            "code": "pragma solidity ^0.4.24;\ncontract Serpent {\n\tmapping (address => uint256) public investorReturn;\n\tuint256 public SerpentCountDown;\n\n\tfunction CollectReturns () external {\n\t\tuint256 currentTime = uint256(block.timestamp);\n\t\trequire (currentTime > SerpentCountDown);\n\t\tinvestorReturn[msg.sender] = 0;\n\t\treturn;\n\t}\n}",
            "label": 1
        },
        "410": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ICOBuyer {\n\n    address public sale;\n\n    function buy() {\n        require(sale.call.value(this.balance)());\n    }\n}\n",
            "label": 1
        },
        "411": {
            "code": "pragma solidity ^0.4.24;\ncontract WhitelistCrowdsale {\n  mapping(address => bool) whitelisted;\n  uint256 public whitelistedCount;\n\n  function addAddress(address _addr) external {\n    whitelisted[_addr] = true;\n    whitelistedCount = block.timestamp;\n  }\n}",
            "label": 0
        },
        "412": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokensGate {\n\n  function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n    require(address(this).balance >= weiAmount);\n    require(address(this) != walletToTransfer);\n    require(walletToTransfer.call.value(weiAmount)());\n  }\n}",
            "label": 1
        },
        "413": {
            "code": "pragma solidity ^0.4.24;\ncontract VernamCrowdSale {\n\tuint public startTime;\n\tuint public threeHotHoursEnd;\n\tuint constant public threeHotHoursDuration = 3 hours;\n\tuint public firstStageEnd;\n\tuint public firstStageDuration = 8 days;\n\n\tfunction setTimeForCrowdsalePeriods() internal returns (uint){\n\t\tstartTime = block.timestamp;\n\t\tthreeHotHoursEnd = startTime + threeHotHoursDuration;\n\t\tfirstStageEnd = threeHotHoursEnd + firstStageDuration;\n\t\treturn firstStageEnd;\n\t}\n}",
            "label": 0
        },
        "414": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DividendToken {\n\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected;\n\n    function collectOwedDividends() public returns (uint amount) {\n        amount = creditedPoints[msg.sender] / 100;\n        creditedPoints[msg.sender] -= amount;\n        require(msg.sender.call.value(amount)());\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}\n",
            "label": 1
        },
        "415": {
            "code": "pragma solidity ^0.4.24;\ncontract NXX {\n\n\tfunction addSupportedToken(uint256 _endTime) public returns (bool) {\n\t\trequire(_endTime > block.timestamp);\n\t\treturn true;\n\t}\n}",
            "label": 0
        },
        "416": {
            "code": "pragma solidity ^0.4.24;\ncontract AdditionalToken{\n    uint256 public totalSupply = 1999;\n\n    mapping(uint256 => uint256) public maxAmountPer;\n\n    function mint(uint256 _amount) public returns (bool) {\n        uint256 curTime = block.timestamp;\n        uint256 curTimes = curTime / 31536000;\n\n        if(maxAmountPer[curTimes] == 0) {\n            maxAmountPer[curTimes] = totalSupply * _amount / 100;\n        }\n        return true;\n    }\n}\n",
            "label": 0
        },
        "417": {
            "code": "pragma solidity ^0.4.24;\ncontract TeamToken  {\n\n    uint64 public gameTime;\n\n    function test() payable public {\n        if (gameTime > 1514764800) {\n            require(gameTime > block.timestamp);\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "418": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenLock {\n    mapping (address => bool) owners;\n    mapping (address => uint256) public lockAmounts;\n    mapping (address => uint256) public releaseTimestamps;\n\n    function release(address _addr) external returns (bool){\n        require(block.timestamp >= releaseTimestamps[_addr]);\n        lockAmounts[_addr] = 0;\n        releaseTimestamps[_addr] = 0;\n        return true;\n    }\n}",
            "label": 1
        },
        "419": {
            "code": "pragma solidity ^0.4.24;\ncontract SponsoredItemGooRaffle {\n    uint256 private raffleEndTime;\n\n    function drawRandomWinner() public {\n        require(raffleEndTime < block.timestamp);\n    }\n}",
            "label": 1
        },
        "420": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n\n\tfunction test() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n}\n",
            "label": 1
        },
        "421": {
            "code": "pragma solidity ^0.4.24;\ncontract JobsBounty {\n    uint public endDate = 0;\n\n    function withdrawERC20Token() external returns(bool){\n        assert(block.timestamp >= endDate);\n        return true;\n    }\n}",
            "label": 0
        },
        "422": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenVesting {\n  uint256 public cliff;\n\n  function vestedAmount() public view returns (uint256) {\n     if (block.timestamp < cliff) {\n        return cliff;\n     }\n  }\n}",
            "label": 1
        },
        "423": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PoormansHoneyPot {\n\n    mapping (address => uint) public balances;\n\n    function withdraw() public{\n        assert(msg.sender.call.value(balances[msg.sender])()) ;\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "424": {
            "code": "pragma solidity ^0.4.24;\ncontract RigIdle {\n    struct MinerData {\n        uint      money;\n        uint      lastUpdateTime;\n    }\n    \n    mapping(address => MinerData) private miners;\n\n    function UpdateMoney() public {\n        MinerData storage m = miners[msg.sender];\n        uint diff = block.timestamp - m.lastUpdateTime;\n        uint revenue = 1123456;\n\n        if(revenue > 0) {\n            revenue *= diff;\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "425": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenVesting {\n  uint256 public start;\n  uint256 public duration;\n\n  function vestedAmount(uint256 currentBalance) public view returns (uint256) {\n    uint256 totalBalance = currentBalance + 100;\n\n    if (block.timestamp >= duration) {\n        return totalBalance * start;\n    }\n  }\n}",
            "label": 1
        },
        "426": {
            "code": "pragma solidity ^0.4.24;\n\ncontract keepMyEther {\n\n    mapping(address => uint256) public balances;\n\n    function withdraw() public {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "427": {
            "code": "pragma solidity ^0.4.24;\ncontract FloraFicTokenCrowdsale {\n  uint256 public initialRate;\n  uint256 public rate;\n  uint256 public openingTime;\n\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - openingTime;\n    uint num_day = uint(elapsedTime) / 86400;\n    rate = initialRate - (num_day * initialRate);\n    return rate;\n  }\n}",
            "label": 0
        },
        "428": {
            "code": "pragma solidity ^0.4.24;\ncontract IcoRocketFuel {\n\n    struct Crowdsale {\n        uint256 closingTime;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n     \n    function finalize(address _token) external {\n        require((block.timestamp >= crowdsales[_token].closingTime));\n    }\n}",
            "label": 1
        },
        "429": {
            "code": "pragma solidity ^0.4.24;\ncontract IcoRocketFuel {\n    enum States {Closed}\n\n    struct Crowdsale {\n        uint256 closingTime;\n        bool earlyClosure;     \n        States state;\n    }\n\n    mapping(address => Crowdsale) public crowdsales;\n     \n    function finalize(address _token) external {\n        require(block.timestamp >= crowdsales[_token].closingTime);\n        crowdsales[_token].state = States.Closed;\n    }\n}",
            "label": 0
        },
        "430": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    mapping (address => bool) accountExists;\n\n    function withdraw(uint amount) public {\n        require(accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount)();\n    }\n}\n",
            "label": 1
        },
        "431": {
            "code": "pragma solidity ^0.4.24;\ncontract Bittwatt {\n    function createDate(uint _minutes, uint _seconds) public view returns (uint) {\n        uint currentTimestamp = block.timestamp;\n        currentTimestamp += _seconds;\n        currentTimestamp += _minutes;\n        return currentTimestamp;\n    }\n}",
            "label": 0
        },
        "432": {
            "code": "pragma solidity ^0.4.24;\ncontract Zmbc{\n\n    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {\n        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);\n        return newBuyPrice - newSellPrice;\n    }\n}",
            "label": 0
        },
        "433": {
            "code": "pragma solidity ^0.4.24;\n\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}\n",
            "label": 1
        },
        "434": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HODLWallet {\n\n    mapping(address => uint256) public balances;\n\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(balances[from] >= amount);\n        balances[from] = balances[from] - amount;\n        from.call.value(amount)();\n    }\n}\n",
            "label": 1
        },
        "435": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC223TokenCompatible {\n\n    mapping (address => uint) balances;\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n        balances[msg.sender] = balances[msg.sender] - _value;\n        balances[_to] = balances[_to] + _value;\n\t    msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}\n}\n",
            "label": 1
        },
        "436": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Overflow_add {\n\n    uint8 sellerBalance = 0;\n\n    function add(uint8 value) returns (uint){\n        sellerBalance += value;\n        return sellerBalance;\n    }\n}",
            "label": 0
        },
        "437": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\ncontract StandardToken {\n    using SafeMath for uint256;\n    mapping(address => uint256) balances;\n\n    function transfer(address _to, uint256 _value) public returns (bool){\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        return true;\n    }\n }\n",
            "label": 0
        },
        "438": {
            "code": "pragma solidity ^0.4.24;\ncontract EcroContract {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdrawInvestments() external onlyOwner returns (uint) {\n        uint amount = block.timestamp;\n        return amount;\n    }\n}",
            "label": 0
        },
        "439": {
            "code": "pragma solidity ^0.4.24;\ncontract GameCell {\n  mapping(address => TimeLock[2]) public allocations;\n\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint total_lockamount = 100;\n  uint total_unlockamount = 100;\n\n  function subAllocation(address sender) private {\n\n      if (allocations[sender][0].releaseTime < block.timestamp) {\n          total_unlockamount = total_unlockamount + (allocations[sender][0].balance);\n      }\n      else {\n          total_lockamount = total_lockamount + (allocations[sender][1].balance);\n      }\n  }\n}",
            "label": 1
        },
        "440": {
            "code": "pragma solidity ^0.4.24;\ncontract EtherHiLo {\n\n    function cleanupAbandonedGame() public returns (uint){\n        uint elapsed = block.timestamp - 202110;\n        return elapsed;\n    }\n}",
            "label": 0
        },
        "441": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AuctusTokenSale {\n\n\tfunction finish() public  {\n\t\tuint256 freeEthers = address(this).balance * 40;\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}\n}\n",
            "label": 0
        },
        "442": {
            "code": "pragma solidity ^0.4.24;\ncontract OdinToken {\n    struct balanceData {  \n       uint balance;\n    }\n    mapping(address => balanceData) balances;\n\n    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {\n        if (block.timestamp < 1569974400) {\n            return false;\n        }\n        return true;\n    }\n}",
            "label": 1
        },
        "443": {
            "code": "pragma solidity ^0.4.24;\ncontract BlocklancerToken {\n    uint public fundingStart;\n\n    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {\n        if(fundingStart > block.timestamp)\n            return fundingStart;\n        else\n            return 0;\n    }\n}",
            "label": 1
        },
        "444": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SPRING_BOARD_1_ETH {\n\n    function Jump() public payable {\n        if(msg.value > 1 ether) {\n            msg.sender.call.value(this.balance);\n        }\n    }\n}",
            "label": 0
        },
        "445": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SIMPLE_PIGGY_BANK {\n\n    mapping (address => uint) public Bal;\n    uint public MinSum = 1 ether;\n\n    function Collect(uint _am) public payable {\n        if(Bal[msg.sender] >= MinSum) {\n            msg.sender.call.value(_am);\n            Bal[msg.sender] -= _am;\n        }\n    }\n}\n",
            "label": 0
        },
        "446": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PIGGY_BANK {\n\n    mapping (address => uint) public Accounts;\n\n    function Collect(uint _am) public payable {\n        if(_am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] -= _am;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "447": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenBank  {\n\n    mapping (address => uint) public Holders;\n    \n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[_addr] > 0) {\n            if(_addr.call.value(_wei)()) {\n                Holders[_addr] -= _wei;\n            }\n        }\n    }\n}",
            "label": 1
        },
        "448": {
            "code": "pragma solidity ^0.4.24;\ncontract CardsRaffle {\n  uint256 private raffleTicketsBought;\n  uint256 private raffleTicketThatWon;\n\n  function drawRandomWinner() public returns (uint256) {\n    uint256 seed = raffleTicketsBought + block.timestamp;\n    raffleTicketThatWon = seed + raffleTicketsBought;\n    return raffleTicketThatWon;\n  }\n}",
            "label": 0
        },
        "449": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LuckyETH {\n\n    mapping(address => uint) playerPendingWithdrawals;\n\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}\n",
            "label": 0
        },
        "450": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Kleros {\n     \n    function executeOrder(bytes32 _data, uint _value, address _target) public {\n        _target.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "451": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleEthBank {\n\n    mapping (address => uint) accountBalances;\n\n    function withdraw(uint amount) public {\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount);\n    }\n}\n",
            "label": 0
        },
        "452": {
            "code": "pragma solidity ^0.4.24;\ncontract MEWCrowdsale {\n    uint256[2] internal signatures;\n    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);\n\n    function changeWallet(address newWallet) public returns (bool) {\n        uint256 blocktime = block.timestamp;\n\n        if (msg.sender == SIGN_ADDRESS1) {\n            signatures[0] = blocktime;\n        }\n        return true;\n    }\n}",
            "label": 0
        },
        "453": {
            "code": "pragma solidity ^0.4.24;\ncontract BasicToken {\n\n  mapping(address => uint256) public mVestingDays;   \n  mapping(address => uint256) public mVestingBegins;\n\n  function ComputeVestSpend(address target) public returns (uint256) {\n      int256 vestingDays = int256(mVestingDays[target]);\n      int256 vestingProgress = int256(block.timestamp) - int256(mVestingBegins[target]);\n\n      if (vestingProgress > vestingDays) {\n          vestingProgress = vestingDays;\n      }\n\n      return 0;\n  }\n}",
            "label": 1
        },
        "454": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FREE_FOR_FUN {\n\n    mapping (address=>uint256) public ExtractDepositTime;\n\n    function GetFreeEther() public payable {\n        if(ExtractDepositTime[msg.sender] != 0) {\n            msg.sender.call.value(ExtractDepositTime[msg.sender])();\n            ExtractDepositTime[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "455": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LZLCoin {\n\n    mapping (address => uint) balances;\n\n    function eT(address _pd, uint _tkA) returns (bool) {\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        if (!msg.sender.call.value(_tkA)()) revert();\n        return true;\n    }\n}\n",
            "label": 0
        },
        "456": {
            "code": "pragma solidity ^0.4.24;\ncontract MyPurchaseContract {\n  uint256 public startAt;\n  uint256 public stopAt;\n  uint256 public grantAt;\n\n  function MyPurchaseContrat() public returns (uint256) {\n     startAt = block.timestamp;\n     stopAt = startAt + 60;\n     grantAt = startAt + 120;\n     return startAt + stopAt + grantAt;\n  }\n}",
            "label": 0
        },
        "457": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EXPERIMENTAL_ETH_AUCTION {\n\n    mapping(address => uint) public Bids;\n\n    function RevokeBid() public payable {\n        uint toTransfer = Bids[msg.sender];\n        Bids[msg.sender] = 0;\n        msg.sender.call.value(toTransfer);\n    }\n}\n",
            "label": 0
        },
        "458": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenBank {\n\n    mapping (address => uint) public Holders;\n    \n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[_addr] >= _wei) {\n            _addr.call.value(_wei)();\n            Holders[_addr] -= _wei;\n        }\n    }\n}\n",
            "label": 1
        },
        "459": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreSaleFund {\n\n    address owner = msg.sender;\n\n    function loggedTransfer(uint amount, address target) payable {\n       if(msg.sender != address(this)) throw;\n       if(!target.call.value(amount)()) { throw; }\n    }\n}\n",
            "label": 1
        },
        "460": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PrivateBank {\n\n    mapping (address => uint) public balances;\n\n    function CashOut(uint _am) {\n        if(msg.sender.call.value(_am)()){\n            balances[msg.sender] -= _am;\n        }\n    }\n}\n",
            "label": 1
        },
        "461": {
            "code": "pragma solidity ^0.4.24;\n\ncontract InkPublicPresale {\n\n  function withdrawEther(address _to) public {\n     assert(_to.call.value(this.balance)());\n  }\n}\n",
            "label": 1
        },
        "462": {
            "code": "pragma solidity ^0.4.24;\ncontract BasicToken {\n    mapping(address => uint256) public balances;\n\n    function transfer(uint256 _value) public returns (bool) {\n        balances[msg.sender] = balances[msg.sender] - _value;\n        return true;\n    }\n}\n",
            "label": 0
        },
        "463": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Overflow {\n\n    function add_overflow() returns (uint256 _overflow) {\n        uint256 max = 2**256 - 1;\n        return max + 1;\n    }\n}",
            "label": 0
        },
        "464": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleCapEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}\n",
            "label": 1
        },
        "465": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}\n",
            "label": 1
        },
        "466": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale{\n  uint256 public endTime;\n\n  function validPurchase() internal view returns (bool) {\n    bool withinPeriod = block.timestamp <= endTime;\n    return withinPeriod;\n  }\n}",
            "label": 1
        },
        "467": {
            "code": "pragma solidity ^0.4.24;\ncontract tokenHodl {\n    mapping (address => uint) public hodlers;\n\n    function party() {\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n    }\n}",
            "label": 0
        },
        "468": {
            "code": "pragma solidity ^0.4.24;\ncontract tokenHodl {\n    uint constant partyTime = 1514402746;\n\n    function withdrawForeignTokens(address _tokenContract) returns (bool) {\n        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }\n        require (block.timestamp > partyTime);\n        return true;\n    }\n}",
            "label": 0
        },
        "469": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MultiplicatorX4 {\n\n    address public Owner = msg.sender;\n\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}\n",
            "label": 1
        },
        "470": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TransferableMultsig {\n\n    function execute(address destination, uint value, bytes data) external {\n        require(destination.call.value(value)(data));\n    }\n}\n",
            "label": 1
        },
        "471": {
            "code": "pragma solidity ^0.4.24;\ncontract FreezableToken {\n    uint release;\n\n    function releaseAll() public returns (uint tokens) {\n\n        while (release > block.timestamp) {\n            msg.sender.call.value(tokens);\n        }\n        return tokens;\n    }\n}",
            "label": 1
        },
        "472": {
            "code": "pragma solidity ^0.4.24;\ncontract StarmidFreezeTokens {\n\n\tfunction refundTokens(address _to, uint _amount) public returns(bool) {\n        require(block.timestamp > 1601510400);\n        return true;\n    }\n}",
            "label": 0
        },
        "473": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Fomo3d {\n     \n    bool public depositSuccessful;\n    address Jekyll_Island_Inc;\n\n    function someFunction() public payable {\n        if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n            depositSuccessful = false;\n        } else {\n            depositSuccessful = true;\n        }\n    }\n}\n",
            "label": 1
        },
        "474": {
            "code": "pragma solidity ^0.4.24;\ncontract StupidCrowdsale {\n\n    uint256 constant public START = 1514764800;\n\n    function getRate() public returns (uint16) {\n        if (block.timestamp < START)\n            return 1000;\n        return 500;\n    }\n}",
            "label": 0
        },
        "475": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MergeCoin{\n\n    function eT(address _pd, uint _etA) returns (bool) {\n        if (!_pd.call.value(_etA)()) revert();\n        return true;\n    }\n}\n",
            "label": 1
        },
        "476": {
            "code": "pragma solidity ^0.4.24;\n\ninterface FoMo3DlongInterface {\n  function getBuyPrice() public view returns(uint256);\n  function getTimeLeft() public view returns(uint256);\n}\n\n\ncontract PwnFoMo3D {\n\n    FoMo3DlongInterface fomo3d;\n\n    function gotake() public  {\n        if (fomo3d.getTimeLeft() > 50) { revert(); }\n        address(fomo3d).call.value(fomo3d.getBuyPrice())();\n    }\n}\n",
            "label": 1
        },
        "477": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "478": {
            "code": "pragma solidity ^0.4.24;\ncontract InsightsNetwork1 {\n\n  mapping (address => uint) public unlockTimes;\n\n  function register(address newTokenHolder, uint issueAmount) {\n    uint currentTime = block.timestamp;\n    uint unlockTime = currentTime + 365*24*60*60;\n    assert(unlockTime > currentTime);\n    unlockTimes[newTokenHolder] = unlockTime;\n  }\n}",
            "label": 0
        },
        "479": {
            "code": "pragma solidity ^0.4.24;\ncontract LifMarketValidationMechanism {\n\n uint256 public startTimestamp;\n\n  function getCurrentPeriodIndex() public constant returns(uint256) {\n    assert(block.timestamp >= startTimestamp);\n    return startTimestamp;\n  }\n}",
            "label": 1
        },
        "480": {
            "code": "pragma solidity ^0.4.24;\ncontract OysterPearl {\n    uint256 public claimAmount;\n    mapping (address => uint256) public balanceOf;\n\n    function claim() public {\n        require(block.timestamp >= 60);\n        balanceOf[msg.sender] -= claimAmount;\n    }\n}",
            "label": 1
        },
        "481": {
            "code": "pragma solidity ^0.4.24;\ncontract OutCloud {\n    uint public preico_startdate;\n    uint public bonusCalculationFactor;\n    uint disc;\n\n    function getCurrentTokenPricepreICO() private returns (uint) {\n        bonusCalculationFactor = block.timestamp + preico_startdate;\n        if (bonusCalculationFactor > 111110)\n            disc = 30;\n        return disc;\n  }\n}",
            "label": 1
        },
        "482": {
            "code": "pragma solidity ^0.4.24;\ncontract Redenom {\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function pay055loyal(address to) public onlyOwner returns(uint){\n        uint new_amount = (block.timestamp % 100) + 55566600;\n        return new_amount;\n    }\n}  ",
            "label": 0
        },
        "483": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer {\n\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n\n    function refund() {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        balances[investor] = 0;\n        if(!(investor.call.value(amount)())) throw;\n    }\n}\n",
            "label": 1
        },
        "484": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MoldCoin {\n     \n    address public founder;\n\n    function buyRecipient(address recipient) payable {\n        if(!founder.call.value(msg.value)()) revert();\n    }\n}\n",
            "label": 1
        },
        "485": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenLab {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        require(msg.sender.call.value(amount)());\n    }\n}\n",
            "label": 0
        },
        "486": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MoldCoin {\n     \n    address public founder;\n    uint public coinAllocation = 20 * 10**8 * 10**2;\n    uint public amountRaised = 0;\n    mapping(address => uint) balances;\n\n    function buyRecipient(address recipient) payable {\n        uint tokens = msg.value * block.timestamp;\n        balances[recipient] = balances[recipient] + tokens;\n        amountRaised = amountRaised + msg.value;\n        if (!founder.call.value(msg.value)()) revert();\n    }\n}\n",
            "label": 1
        },
        "487": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n\n    function buyTokens() payable {\n        require(block.timestamp < deadline && tokenPrice > 0);\n    }\n}",
            "label": 1
        },
        "488": {
            "code": "pragma solidity ^0.4.24;\ncontract TMTGBaseToken {\n    uint256 public openingTime;\n    struct investor {\n        uint256 _limit;\n    }\n    mapping(address => investor) public searchInvestor;\n\n    function _timelimitCal() internal view returns (uint256) {\n        uint256 presentTime = block.timestamp;\n        uint256 timeValue = presentTime - openingTime;\n        uint256 _result = timeValue / (31 days);\n        return _result;\n    }\n}",
            "label": 0
        },
        "489": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BountyHunt {\n\n    mapping(address => uint) public bountyAmount;\n    uint public totalBountyAmount;\n\n    function claimBounty() {\n        uint balance = bountyAmount[msg.sender];\n\n        if (msg.sender.call.value(balance)()) {\n          totalBountyAmount -= balance;\n          bountyAmount[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "490": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Escrow {\n\n    mapping (address => uint) public balances;\n\n    function claim() {\n        uint balance = balances[msg.sender];\n        balances[msg.sender] = 0;\n        bool claimed = msg.sender.call.value(balance)();\n        require(claimed);\n    }\n}",
            "label": 0
        },
        "491": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenStore {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint _amount) {\n        tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;\n        if (!msg.sender.call.value(_amount)()) { revert(); }\n    }\n}\n",
            "label": 0
        },
        "492": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer{\n\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n\n    function refund()  {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        delete balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n    }\n}\n",
            "label": 1
        },
        "493": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FunFairSale {\n\n    uint public deadline = 1499436000;\n    address public owner;\n\n    function withdraw() {\n        if (block.timestamp < deadline) throw;\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}\n",
            "label": 1
        },
        "494": {
            "code": "pragma solidity ^0.4.24;\ncontract TimeBank {\n\n    struct Holder {\n        uint withdrawTime;\n    }\n\n    mapping (address => Holder) holders;\n\n    function withdrawFunds() {\n        require(holders[msg.sender].withdrawTime < block.timestamp);\n        holders[msg.sender].withdrawTime = 0;\n    }\n}",
            "label": 0
        },
        "495": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenPool {\n\n    uint public rewardPercentage = 30;\n    uint public amountRaised = 100;\n    address public tokenCreateContract;\n    bytes4 tokenCreateFunctionHash;\n    mapping (address => uint) balances;\n\n    function CreateTokens() {\n        uint amount = amountRaised * rewardPercentage;\n        if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n        balances[tokenCreateContract] -= amount;\n    }\n}\n",
            "label": 1
        },
        "496": {
            "code": "pragma solidity ^0.4.24;\ncontract holdEthereum {\n\n    mapping (address => uint) holders;\n    uint constant partyTime = 1596067200;\n\n    function party() {\n        if (block.timestamp < partyTime) throw;\n        uint value = holders[msg.sender];\n        holders[msg.sender] = 0;\n        msg.sender.transfer(value);\n    }\n}",
            "label": 0
        },
        "497": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DecentrEx{\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "498": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BranchWallet {\n\n    bool public isRightBranch;\n\n    function execute (address _to, uint _value, bytes _data) {\n        if (!_to.call.value(_value)(_data)) throw;\n    }\n}",
            "label": 1
        },
        "499": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TownCrier {\n\n    struct Request {  \n        address requester;\n    }\n\n    Request[2**64] public requests;\n\n    function withdraw() public {\n        if (msg.sender == requests[0].requester) {\n            if (!requests[0].requester.call.value(this.balance)()) { throw; }\n        }\n    }\n}",
            "label": 0
        },
        "500": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Token {\n\n    function execute(address _dst, uint _value, bytes _data) {\n        _dst.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "501": {
            "code": "pragma solidity ^0.4.24;\ncontract ProofOfExistence {\n  mapping (string => uint) private proofs;\n\n  function notarize(string sha256) {\n      if ( proofs[sha256] != 0 ){\n        proofs[sha256] = block.timestamp;\n      }\n  }\n}",
            "label": 0
        },
        "502": {
            "code": "pragma solidity ^0.4.24;\ncontract ProofOfExistence {\n  mapping (string => uint) private proofs;\n\n  function storeProof(string sha256) {\n        proofs[sha256] = block.timestamp;\n  }\n}",
            "label": 0
        },
        "503": {
            "code": "pragma solidity ^0.4.24;\n\ncontract AddressOwnershipVerification {\n\n    mapping(address => mapping (address => uint32)) verifications;\n\n    function revoke(address transactor, address transactee) {\n        uint32 deposit = verifications[transactor][transactee];\n        verifications[transactor][transactee] = 0;\n        if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n    }\n}\n",
            "label": 1
        },
        "504": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherprisesLLC {\n\n    mapping (address => address) public latestSeriesForUser;\n     \n    function () payable {\n        if (latestSeriesForUser[msg.sender] != 0) {\n            if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;\n        }\n    }\n}\n\n",
            "label": 1
        },
        "505": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FDC {\n\n    address public foundationWallet;\n\n    function empty() returns (bool) {\n        return foundationWallet.call.value(this.balance)();\n    }\n}\n\n",
            "label": 1
        },
        "506": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Blockjack {\n\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n\n    mapping (address => uint) public balances;\n\n    function shareProfits() {\n        if (currentBankroll <= initialBankroll) throw;\n        uint256 profit = currentBankroll - initialBankroll;\n        if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n        currentBankroll -= profit;\n        balances[ADMIN_CONTRACT] -= profit;\n    }\n}",
            "label": 1
        },
        "507": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ValueTrader{\n\n    function buyEther(uint256 amount) {\n        assert(msg.sender.call.value(amount)());\n    }\n}",
            "label": 1
        },
        "508": {
            "code": "pragma solidity ^0.4.24;\n\ncontract NinjaToken {\n\n    mapping(address=>string) public commit;\n    mapping(address=>uint) public balances;\n    address public fundingAccount;\n\n    function buy(string _commit) payable {\n        if(!fundingAccount.call.value(msg.value)()) throw;\n        balances[fundingAccount] -= msg.value;\n    }\n}\n",
            "label": 1
        },
        "509": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Underflow_sub {\n\n    function sub_underflow() returns (uint256 _underflow) {\n        uint256 min = 0;\n        return min - 1;\n    }\n}",
            "label": 0
        },
        "510": {
            "code": "pragma solidity ^0.4.24;\ncontract Saturn {\n    uint256 public luckyPendingIndex;\n\n    function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {\n        if (luckyPendingIndex < _pendingSkipSize) {\n            uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));\n            return _seed > 0;\n        }\n    }\n}",
            "label": 1
        },
        "511": {
            "code": "pragma solidity ^0.4.24;\ncontract PPBC_API {\n    uint256 private lastBlock;\n    uint256 private lastRandom;\n    uint cnt;\n\n    function createRandomNumber() returns (uint256) {\n        for (cnt = 0; cnt < lastRandom % 5; cnt++){\n            lastBlock = lastBlock - block.timestamp;\n        }\n        return lastBlock;\n    }\n}",
            "label": 0
        },
        "512": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}\n",
            "label": 1
        },
        "513": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    uint256 private totalBalance;\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        totalBalance -= payment;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}",
            "label": 1
        },
        "514": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DaoAccount {\n\n\tuint256 tokenBalance;  \n    address owner;\n\tuint256 tokenPrice;\n\t \n\tfunction withdraw(uint256 tokens) {\n\t    uint256 price = tokens * tokenPrice;\n\t\ttokenBalance -= price;\n\t\tif(!owner.call.value(price)()) throw;\n\t}\n}\n",
            "label": 1
        },
        "515": {
            "code": "pragma solidity ^0.4.24;\ncontract BirthdayGift {\n    address public recipient;\n    uint public birthday;\n\n    function Take () {\n        if (msg.sender != recipient) throw;\n        if (block.timestamp < birthday) throw;\n    }\n}",
            "label": 1
        },
        "516": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherDelta {\n\n    mapping (address => mapping (address => uint)) tokens;\n\n    function withdraw(uint amount) {\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "517": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Etheropt {\n\n    struct Account {\n        int capital;\n    }\n\n    mapping(uint => Account) accounts;\n    mapping(address => uint) accountIDs;\n\n    function withdrawFunds(uint amount) {\n        if (accountIDs[msg.sender] > 0) {\n          if (int(amount) > 0) {\n            accounts[accountIDs[msg.sender]].capital -= int(amount);\n            msg.sender.call.value(amount)();\n          }\n        }\n    }\n}",
            "label": 1
        },
        "518": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DaoAccount {\n\n\tuint256 tokenBalance;\n    address owner;\n\taddress daoChallenge;\n\n\tmodifier onlyOwner() {\n\t    if (daoChallenge != msg.sender) throw;\n\t    _;\n\t}\n\n\tfunction withdraw(uint256 tokens) onlyOwner {\n\t\ttokenBalance -= tokens;\n\t\tif(!owner.call.value(tokens)()) throw;\n\t}\n}",
            "label": 1
        },
        "519": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BranchWallet {\n\n    function execute (address _to, uint _value, bytes _data) {\n        if (!_to.call.value(_value)(_data)) throw;\n    }\n}\n",
            "label": 1
        },
        "520": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DaoChallenge {\n\n\tfunction withdrawEtherOrThrow(uint256 amount) {\n\t\tbool result = msg.sender.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}\n}",
            "label": 1
        },
        "521": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherDelta {\n\n    mapping (address => mapping (address => uint)) tokens;\n\n    function withdraw(uint amount) {\n        if (!msg.sender.call.value(amount)()) throw;\n        tokens[0][msg.sender] -= amount;\n    }\n}\n",
            "label": 1
        },
        "522": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MyEtherBank {\n\n    uint256 private _bankDonationsBalance = 0;\n\n    function BankOwner_WithdrawDonations() public {\n        if (_bankDonationsBalance > 0) {\n            uint256 amount_ = _bankDonationsBalance;\n            _bankDonationsBalance = 0;\n            if (!msg.sender.call.value(amount_)()) { throw; }\n        }\n    }\n}",
            "label": 1
        },
        "523": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Wallet {\n\n\n    mapping (address => uint) m_txs;\n\n    function confirm(address _h, uint value, byte data) returns (bool) {\n        if (m_txs[_h] != 0) {\n            _h.call.value(value)(data);\n            m_txs[_h] -= value;\n            return true;\n        }\n    }\n}\n\n",
            "label": 1
        },
        "524": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ManagedAccount{\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (_recipient.call.value(_amount)()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
            "label": 1
        },
        "525": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Bank{\n\n    mapping (address => uint256) public balances;\n\n    function withdraw() {\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender] = 0;\n    }\n}\n",
            "label": 1
        },
        "526": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Owner{\n    mapping (address => uint) private rewardsForA;\n\n    function untrustedWithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n    }\n}",
            "label": 1
        },
        "527": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n    mapping (address => uint) userBalance;\n\n    function withdrawBalance_fixed() {\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if(!(msg.sender.call.value(amount)())){ throw; }\n    }\n}\n",
            "label": 1
        },
        "528": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherStore {\n\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n    }\n}\n\n",
            "label": 1
        },
        "529": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SimpleDAO {\n\n    mapping (address => uint) public credit;\n\n    function withdraw(uint amount) {\n      msg.sender.call.value(amount)();\n      credit[msg.sender] -= amount;\n    }\n}",
            "label": 1
        },
        "530": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Victim {\n\n    mapping(address => uint) public balances;\n\n    function withdraw(uint _amount) public {\n        if(!msg.sender.call.value(_amount)()) { throw; }\n        balances[msg.sender] -= _amount;\n    }\n}\n",
            "label": 1
        },
        "531": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PIGGY_BANK {\n\n    mapping (address => uint) public Accounts;\n\n    function Collect(uint _am) public payable {\n        if(msg.sender.call.value(_am)()) {\n            Accounts[msg.sender] -= _am;\n        }\n    }\n}",
            "label": 1
        },
        "532": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BancorBuyer {\n\n    mapping(address => uint256) public balances;\n\n    function buyOne(address _exchange, uint256 _value, bytes _data) payable public {\n        require(_exchange.call.value(_value)(_data));\n        balances[msg.sender] = balances[msg.sender] - _value;\n    }\n}",
            "label": 1
        },
        "533": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Bank{\n\n    mapping (address => uint256) public balances;\n\n    function withdraw(){\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "534": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Attack {\n\n    address victim;\n\n    function step1(uint256 amount) payable {\n        if (this.balance >= amount) {\n            victim.call.value(amount)();\n        }\n    }\n}\n",
            "label": 1
        },
        "535": {
            "code": "pragma solidity ^0.4.24;\n\ncontract dumbDAO {\n\n    mapping (address => uint) public balances;\n\n    function withdraw(address _recipient) returns (bool) {\n        if (balances[msg.sender] == 0){ throw; }\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}\n",
            "label": 1
        },
        "536": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EtherStore {\n\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(_weiToWithdraw <= withdrawalLimit);\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n    }\n}\n\n",
            "label": 1
        },
        "537": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Private_Bank {\n\n    mapping (address => uint) public balances;\n\n    function CashOut(uint _am)  {\n        if(msg.sender.call.value(_am)()) {\n            balances[msg.sender] -= _am;\n        }\n    }\n}\n",
            "label": 1
        },
        "538": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ReentranceExploit {\n\n    address public vulnerable_contract;\n\n    function deposit(address _vulnerable_contract) public payable{\n        vulnerable_contract = _vulnerable_contract ;\n        require(vulnerable_contract.call.value(msg.value)());\n    }\n}\n",
            "label": 0
        },
        "539": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BaseWallet {\n\n    function invoke(address _target, uint _value, bytes _data) external {\n        bool success = _target.call.value(_value)(_data);\n        require(success);\n    }\n}",
            "label": 1
        },
        "540": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenCreation {\n\n    mapping (address => uint256) balances;\n    uint256 public totalSupply;\n\n    function refund() {\n        if (msg.sender.call.value(balances[msg.sender])()) {\n            totalSupply -= balances[msg.sender];\n            balances[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "541": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Token {\n    mapping (address => uint256) public balances;\n\n    function withdraw(uint _amount) public {     \n        if(msg.sender.call.value(_amount)()) {\n            balances[msg.sender] -= _amount;        \n        }\n    }\n}\n",
            "label": 1
        },
        "542": {
            "code": "pragma solidity ^0.4.24;\ncontract SnooKarma {\n    uint public totalSupply = 500;\n\n    function redeem(uint karma, uint sigExp) public returns (uint) {\n        require(block.timestamp < sigExp);\n        totalSupply = totalSupply + karma;\n        return totalSupply;\n    }\n}",
            "label": 0
        },
        "543": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable {\n    uint public totalAmount;\n\n    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {\n        totalAmount = totalAmount + _value;\n        return totalAmount;\n    }\n}",
            "label": 0
        },
        "544": {
            "code": "pragma solidity ^0.4.24;\ncontract CrowdsaleExt {\n    uint public startsAt;\n    enum State {PreFunding, Failure}\n\n    function getState() public constant returns (State) {\n        if (block.timestamp < startsAt)\n            return State.PreFunding;\n        else\n            return State.Failure;\n    }\n}",
            "label": 1
        },
        "545": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale  {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "546": {
            "code": "pragma solidity ^0.4.24;\ncontract MMOToken{\n    mapping (address => uint256) public lockAddress;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {\n       if(_value > block.timestamp) {\n            lockAddress[_to] = _value;\n            return true;\n       }\n       return false;\n    }\n}",
            "label": 1
        },
        "547": {
            "code": "pragma solidity ^0.4.24;\n\ncontract mnyminer {\n    \n    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n\n    function futxMiner() public payable {\n        require(futx.call.value(msg.value)());\n    }\n}",
            "label": 1
        },
        "548": {
            "code": "pragma solidity ^0.4.24;\n\ncontract IChain {\n\n    uint256 public amountRaised ;\n    mapping (address => uint) balances;\n\n    function finishDistribution() public returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender] - amountRaised;\n        return true;\n    }\n}\n",
            "label": 1
        },
        "549": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenTimelockVault {\n    mapping(address => TimeEnvoy) internal owners;\n\n    struct TimeEnvoy {\n        uint releaseTime;\n        uint balance;\n    }\n\n    function releasableAmount(address _owner) public view returns (uint256){\n        TimeEnvoy storage owner = owners[_owner];\n        if (block.timestamp >= owner.releaseTime) {\n            return owner.balance;\n        }\n    }\n}",
            "label": 1
        },
        "550": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n\n    function buyTokens() payable returns (bool){\n        require(block.timestamp < deadline && tokenPrice > 0);\n        return true;\n    }\n}",
            "label": 1
        },
        "551": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Crowdsale {\n\n    uint256 public bonusDeliverTime;\n    uint256 public bonusUnsold;\n\n    function returnBonus() external returns (uint) {\n        require(block.timestamp > bonusDeliverTime);\n        require(bonusUnsold > 0);\n        return bonusUnsold;\n    }\n\n}",
            "label": 1
        },
        "552": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Overflow_mul {\n\n    function mul_overflow() returns (uint256 _underflow) {\n        uint256 mul = 2**255 - 1;\n        return mul * 2;\n    }\n}",
            "label": 0
        },
        "553": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DividendDistributorv3 {\n    modifier onlyOwner() {\n        if(msg.sender != address(this)) throw;\n        _;\n    }\n\n    function loggedTransfer(uint amount, address target) onlyOwner {\n        if(!target.call.value(amount)()) throw;\n    }\n}",
            "label": 1
        },
        "554": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MultiplicatorX3 {\n\n    function Command(address adr,bytes data) payable public {\n        adr.call.value(msg.value)(data);\n    }\n}",
            "label": 1
        },
        "555": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Private_Bank {\n    mapping (address => uint) public balances;\n\n    function CashOut(uint _am) {\n        if(_am > 0) {\n            if(msg.sender.call.value(_am)()) {\n                balances[msg.sender]-=_am;\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "556": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DividendToken {\n\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected = 0;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function collectOwedDividends() public onlyOwner returns (uint) {\n        uint amount = creditedPoints[msg.sender] / 100;\n        require(msg.sender.call.value(amount)());\n        creditedPoints[msg.sender] -= amount;\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}\n",
            "label": 1
        },
        "557": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HODLWallet {\n\n    mapping(address => uint256) public balances;\n\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(amount <= 0.002 * 1000000000000000000);\n        from.call.value(amount)();\n        balances[from] = balances[from] - amount;\n    }\n}\n",
            "label": 1
        },
        "558": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LuckyETH {\n\n    mapping(address => uint) playerPendingWithdrawals;\n\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n\n        if (msg.sender.call.value(withdrawAmount)()) {\n            playerPendingWithdrawals[msg.sender] = 0;\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}\n",
            "label": 1
        },
        "559": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LZLCoin {\n\n    mapping (address => uint) balances;\n\n    function eT(address _pd, uint _tkA) returns (bool) {\n        if (!msg.sender.call.value(_tkA)()) revert();\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        return true;\n    }\n}\n",
            "label": 1
        },
        "560": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleCapEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}\n",
            "label": 1
        },
        "561": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Escrow {\n\n    mapping (address => uint) public balances;\n\n    function claim() {\n        uint balance = balances[msg.sender];\n        require(balance > 0);\n        bool claimed = msg.sender.call.value(balance)();\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "562": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleCapEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function reject(address _participant) public onlyOwner {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}\n",
            "label": 1
        },
        "563": {
            "code": "pragma solidity ^0.4.24;\n\ncontract generic_holder {\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "564": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Escrow {\n\n    mapping (address => uint) public balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function claim() onlyOwner {\n        uint balance = balances[msg.sender];\n        msg.sender.call.value(balance)();\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "565": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Reentrance {\n\n    mapping(address => uint) public balances;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw(uint _amount) public onlyOwner {\n      if(msg.sender.call.value(_amount)()) {\n         balances[msg.sender] -= _amount;\n      }\n    }\n}",
            "label": 1
        },
        "566": {
            "code": "pragma solidity ^0.4.24;\ncontract UniswapV2Pair {\n\n    uint32  private blockTimestampLast;  \n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n        if (timeElapsed > 0 ) {\n            price0CumulativeLast += _reserve0 * timeElapsed;\n        }\n    }\n}",
            "label": 1
        },
        "567": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenMintPoD {\n\n  uint256 public lockTime;\n\n  function getBalanceOfToken() public constant returns (uint256) {\n    if (block.timestamp <= lockTime)\n        return lockTime;\n  }\n}\n",
            "label": 1
        },
        "568": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC200 {\n\n    struct InvestorLock {\n        uint amount;\n    }\n\n    uint startsAt;\n\n    mapping(address => InvestorLock) private _investorLocks;\n    uint investorLockedAmount = 0;\n\n    function getInvestorLockedAmount(address account) public view returns (uint) {\n        uint amount = _investorLocks[account].amount;\n        if (amount > 0) {\n          uint timestamp = block.timestamp;\n          if (timestamp <= startsAt) {\n            return investorLockedAmount;\n          }\n        }\n    }\n}\n",
            "label": 1
        },
        "569": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DutchSwapAuction  {\n    uint256 public startDate;\n    uint256 public priceDrop;\n\n    function _currentPrice() private view returns (uint256) {\n        uint256 elapsed = block.timestamp - startDate;\n        uint256 priceDiff = elapsed * priceDrop;\n        return priceDiff;\n    }\n}",
            "label": 0
        },
        "570": {
            "code": "pragma solidity ^0.4.24;\n\ncontract KingOfTheHill {\n    uint public withdrawDelay;\n\n    function takeAll() public {\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(this.balance);\n    }\n}",
            "label": 1
        },
        "571": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TransactionOrdering {\n    uint256 price = 100;\n    address owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function buy() returns (uint256) {\n        return price;\n    }\n\n    function setPrice(uint256 _price) onlyOwner {\n        price = _price;\n    }\n}",
            "label": 0
        },
        "572": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EthTxOrderDependenceMinimal {\n    address public owner;\n    uint public reward;\n\n    function setReward() public payable {\n        require(msg.sender == owner);\n        owner.transfer(reward);\n        reward = msg.value;\n    }\n\n    function claimReward(uint256 submission) {\n        require(submission < 10);\n        msg.sender.transfer(reward);\n    }\n}",
            "label": 1
        },
        "573": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract BasicToken {\n    using SafeMath for uint;\n\n    mapping(address => uint) public balances;\n    uint public basisPointsRate = 0;\n\n    function transfer(address _to, uint _value) public {\n        uint fee = _value.mul(basisPointsRate);\n        uint sendAmount = _value.sub(fee);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(sendAmount);\n    }\n}\n",
            "label": 0
        },
        "574": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract Overflow_add {\n    using SafeMath for uint;\n\n    uint sellerBalance = 0;\n\n    function add(uint value) returns (uint){\n        sellerBalance = sellerBalance.add(value);\n        return sellerBalance;\n    }\n}",
            "label": 0
        },
        "575": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract test {\n    using SafeMath for uint;\n\n    function add_overflow() returns (uint256 _overflow) {\n        uint256 max = 2**256 - 1;\n        return max.add(1);\n    }\n}\n",
            "label": 0
        },
        "576": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n}\n\ncontract Underflow_sub {\n    using SafeMath for uint;\n\n    function sub_underflow() returns (uint256 _underflow) {\n        uint256 min = 0;\n        return min.sub(1);\n    }\n}",
            "label": 0
        },
        "577": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract Ownable {\n    using SafeMath for uint;\n    uint public totalAmount;\n\n    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {\n        totalAmount = totalAmount.add(_value);\n        return totalAmount;\n    }\n}",
            "label": 0
        },
        "578": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract TokenVesting {\n  using SafeMath for uint;\n  uint256 public start;\n  uint256 public duration;\n\n  function vestedAmount(uint256 currentBalance) public view returns (uint256) {\n    uint256 totalBalance = currentBalance.add(100);\n\n    if (block.timestamp >= duration) {\n        return totalBalance.mul(start);\n    }\n  }\n}",
            "label": 1
        },
        "579": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract GameCell {\n  using SafeMath for uint;\n  mapping(address => TimeLock[2]) public allocations;\n\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint total_lockamount = 100;\n  uint total_unlockamount = 100;\n\n  function subAllocation(address sender) private {\n\n      if (allocations[sender][0].releaseTime < block.timestamp) {\n          total_unlockamount = total_unlockamount.add(allocations[sender][0].balance);\n      }\n      else {\n          total_lockamount = total_lockamount.add(allocations[sender][1].balance);\n      }\n  }\n}",
            "label": 1
        },
        "580": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract SnooKarma {\n    using SafeMath for uint;\n    uint public totalSupply = 500;\n\n    function redeem(uint karma, uint sigExp) public returns (uint) {\n        require(block.timestamp < sigExp);\n        totalSupply = totalSupply.add(karma);\n        return totalSupply;\n    }\n}",
            "label": 0
        },
        "581": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract NGOTVesting {\n    using SafeMath for uint;\n    mapping(address => uint256) public stageSettings;\n\n    function vestStage(uint256 lockStartTime) public view returns(uint256){\n        uint256 stage = block.timestamp.sub(lockStartTime);\n\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}",
            "label": 1
        },
        "582": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract H2OC {\n    using SafeMath for uint;\n    uint256 public totalToken;\n\n    function burn (uint256 _burntAmount) public returns (uint) {\n    \ttotalToken = totalToken.sub(_burntAmount).add(block.timestamp);\n    \treturn totalToken;\n\t}\n}",
            "label": 0
        },
        "583": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract IncreasingTokenPriceCrowdsale {\n  using SafeMath for uint;\n  uint256 public openingTime = 10;\n   \n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp.sub(openingTime);\n    return elapsedTime;\n  }\n}",
            "label": 0
        },
        "584": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n\ncontract TokenVesting {\n  using SafeMath for uint;\n  uint public cliff;\n  mapping (address => uint) public released;\n\n  function vestedAmount(address _token) public view returns (uint) {\n    uint totalBalance = released[_token].add(17777777);\n\n    if (100 < cliff) {\n      return totalBalance.mul(block.timestamp);\n    }\n  }\n}",
            "label": 0
        },
        "585": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n\ncontract BitSongCrowdsale {\n    using SafeMath for uint;\n    uint256 public openingTime;\n    uint256 public closingTime;\n    uint256 public duration;\n\n    function startDistribution() external returns (uint256) {\n        openingTime = block.timestamp;\n        closingTime = openingTime.add(duration);\n        return closingTime;\n    }\n}",
            "label": 0
        },
        "586": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n\ncontract TokenTimelock {\n  using SafeMath for uint;\n  uint256 public token;\n  uint256 public releaseTime;\n\n  function release() public returns (uint256){\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token.add(2000000);\n    return amount;\n  }\n}\n",
            "label": 1
        },
        "587": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract Bittwatt {\n    using SafeMath for uint;\n\n    function createDate(uint _minutes, uint _seconds) public view returns (uint) {\n        uint currentTimestamp = block.timestamp;\n        currentTimestamp = currentTimestamp.add(_seconds);\n        currentTimestamp = currentTimestamp.add(_minutes.mul(60));\n        return currentTimestamp;\n    }\n}",
            "label": 0
        },
        "588": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\n\ncontract Zmbc{\n    using SafeMath for uint;\n    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {\n        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);\n        return newBuyPrice.sub(newSellPrice);\n    }\n}",
            "label": 0
        },
        "589": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract CardsRaffle {\n  using SafeMath for uint;\n  uint256 private raffleTicketsBought;\n  uint256 private raffleTicketThatWon;\n\n  function drawRandomWinner() public returns (uint256) {\n    uint256 seed = raffleTicketsBought.add(block.timestamp);\n    raffleTicketThatWon = seed.add(raffleTicketsBought);\n    return raffleTicketThatWon;\n  }\n}",
            "label": 0
        },
        "590": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract BasicToken {\n  using SafeMath for uint;\n  mapping(address => uint256) public mVestingDays;\n  mapping(address => uint256) public mVestingBegins;\n\n  function ComputeVestSpend(address target) public returns (uint256) {\n      uint256 vestingDays = uint256(mVestingDays[target]);\n      uint256 vestingProgress = uint256(block.timestamp).sub(uint256(mVestingBegins[target]));\n\n      if (vestingProgress > vestingDays) {\n          vestingProgress = vestingDays;\n      }\n\n      return 0;\n  }\n}",
            "label": 1
        },
        "591": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract MyPurchaseContract {\n  using SafeMath for uint;\n  uint256 public startAt;\n  uint256 public stopAt;\n  uint256 public grantAt;\n\n  function MyPurchaseContrat() public returns (uint256) {\n     startAt = block.timestamp;\n     stopAt = startAt.add(60);\n     grantAt = startAt.add(120);\n     return grantAt.add(stopAt).add(startAt);\n  }\n}",
            "label": 0
        },
        "592": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract TMTGBaseToken {\n    using SafeMath for uint;\n    uint256 public openingTime;\n    struct investor {\n        uint256 _limit;\n    }\n    mapping(address => investor) public searchInvestor;\n\n    function _timelimitCal() internal view returns (uint256) {\n        uint256 presentTime = block.timestamp;\n        uint256 timeValue = presentTime.sub(openingTime);\n        uint256 _result = timeValue / 31 days;\n        return _result;\n    }\n}",
            "label": 0
        },
        "593": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract IChain {\n    using SafeMath for uint;\n    uint256 public amountRaised ;\n    mapping (address => uint) balances;\n\n    function finishDistribution() public returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender].sub(amountRaised);\n        return true;\n    }\n}\n",
            "label": 1
        },
        "594": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract JadeCoin {\n  using SafeMath for uint;\n  mapping(address => uint256) public jadeBalance;\n  mapping(address => uint256) public lastJadeSaveTime;  \n\n  function updatePlayersCoinByOut(address player) external returns (bool){\n    lastJadeSaveTime[player] = block.timestamp;\n    jadeBalance[player] = jadeBalance[player].add(66666666);\n    return true;\n  }\n}",
            "label": 0
        },
        "595": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract HiroyukiCoinDark {\n    using SafeMath for uint;\n    mapping(address => uint256) public balanceOf;\n\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        assert(msg.sender.call.value(0)());\n        return true;\n    }\n}\n",
            "label": 1
        },
        "596": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract EtheremonEnergy {\n    using SafeMath for uint;\n\n    struct Energy {\n        uint lastClaim;\n    }\n    \n    mapping(address => Energy) energyData;\n    uint public claimAmount = 1;\n\n    function getClaimableAmount(address _trainer) constant external returns(uint) {\n        Energy storage energy = energyData[_trainer];\n        uint period = block.timestamp.add(energy.lastClaim);\n        uint energyAmount = period.mul(claimAmount);\n        if (energyAmount > claimAmount)\n            energyAmount = claimAmount;\n        return energyAmount;\n    }\n}",
            "label": 1
        },
        "597": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract Crowdsale {\n  using SafeMath for uint;\n  uint public startsAt;\n\n  function getCurrentFgcCap() public constant returns (uint) {\n    uint timeSinceStart = block.timestamp.sub(startsAt);\n    uint currentPeriod = (timeSinceStart / 1 days).add(1);\n\n    if (currentPeriod < 2) {\n        return currentPeriod.mul(10);\n    }\n    return 0;\n  }\n}",
            "label": 1
        },
        "598": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract Tokenlock {\n    using SafeMath for uint;\n    uint256 public interval;\n    uint256 public releaseTime;\n\n    function start() external returns (uint256){\n        uint time = block.timestamp;\n        releaseTime = time.add(interval);\n        return releaseTime;\n    }\n}",
            "label": 0
        },
        "599": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract PLCRVoting {\n    using SafeMath for uint;\n\n    function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {\n        uint commitEndDate = block.timestamp.add(_commitDuration);\n        uint revealEndDate = commitEndDate.add(_revealDuration);\n        return revealEndDate;\n    }\n}",
            "label": 0
        },
        "600": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract ProgressiveIndividualCappedCrowdsale {\n    using SafeMath for uint;\n    uint public startGeneralSale;\n    uint public constant TIME_PERIOD_IN_SEC = 1 days;\n    uint256 public baseEthCapPerAddress;\n\n    function getCurrentEthCapPerAddress() public constant returns(uint) {\n        uint time = block.timestamp;\n        uint timeSinceStartInSec = time.sub(startGeneralSale);\n        uint currentPeriod = (timeSinceStartInSec / (TIME_PERIOD_IN_SEC)).add(1);\n        return currentPeriod.mul(2);\n    }\n}\n",
            "label": 0
        },
        "601": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract LOTT {\n    using SafeMath for uint;\n    uint public rand1;\n    uint public rand2;\n    \n    mapping (uint => mapping (uint => address)) public map;\n\n    function place(uint cell) external returns (uint){\n        rand1 = rand1.add(block.timestamp);\n        rand2 = rand2.sub(uint(msg.sender));\n        return rand2.add(rand2);\n     }\n\n}",
            "label": 0
        },
        "602": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract VernamCrowdSale {\n\tusing SafeMath for uint;\n\tuint public startTime;\n\tuint public threeHotHoursEnd;\n\tuint constant public threeHotHoursDuration = 3 hours;\n\tuint public firstStageEnd;\n\tuint public firstStageDuration = 8 days;\n\n\tfunction setTimeForCrowdsalePeriods() internal returns (uint){\n\t\tstartTime = block.timestamp;\n\t\tthreeHotHoursEnd = startTime.add(threeHotHoursDuration);\n\t\tfirstStageEnd = threeHotHoursEnd.add(firstStageDuration);\n\t\treturn firstStageEnd;\n\t}\n}",
            "label": 0
        },
        "603": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract DividendToken {\n    using SafeMath for uint;\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected;\n\n    function collectOwedDividends() public returns (uint amount) {\n        amount = creditedPoints[msg.sender] / 100;\n        creditedPoints[msg.sender] = creditedPoints[msg.sender].sub(amount);\n        require(msg.sender.call.value(amount)());\n        dividendsCollected = dividendsCollected.add(amount);\n        return dividendsCollected;\n    }\n}\n",
            "label": 1
        },
        "604": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract FloraFicTokenCrowdsale {\n  using SafeMath for uint;\n  uint256 public initialRate;\n  uint256 public rate;\n  uint256 public openingTime;\n\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp.sub(openingTime);\n    uint num_day = uint(elapsedTime) / 86400;\n    rate = initialRate.sub(num_day.mul(initialRate) / 100);\n    return rate;\n  }\n}",
            "label": 0
        },
        "605": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract A2ACrowdsale {\n    using SafeMath for uint;\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] = balances[_contract].sub(_amount);\n\t}\n}\n",
            "label": 1
        },
        "606": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract HODLWallet {\n    using SafeMath for uint;\n    mapping(address => uint256) public balances;\n\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(balances[from] >= amount);\n        balances[from] = balances[from].sub(amount);\n        from.call.value(amount)();\n    }\n}\n",
            "label": 1
        },
        "607": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract ERC223TokenCompatible {\n    using SafeMath for uint;\n    mapping (address => uint) balances;\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n\t\trequire(_value <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n\t    msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}\n}\n",
            "label": 1
        },
        "608": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract EtherHiLo {\n    using SafeMath for uint;\n\n    function cleanupAbandonedGame() public {\n        uint elapsed = block.timestamp.sub(202110);\n        require(elapsed >= 86400);\n    }\n}",
            "label": 0
        },
        "609": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract AuctusTokenSale {\n    using SafeMath for uint;\n\n\tfunction finish() public  {\n\t\tuint256 freeEthers = address(this).balance.mul(40);\n\t\tuint256 vestedEthers = address(this).balance.sub(freeEthers);\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}\n}\n",
            "label": 1
        },
        "610": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract PIGGY_BANK {\n    using SafeMath for uint;\n    mapping (address => uint) public Accounts;\n\n    function Collect(uint _am) public payable {\n        if(_am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] = Accounts[msg.sender].sub(_am);\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "611": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract PIGGY_BANK {\n    using SafeMath for uint;\n    mapping (address => uint) public Accounts;\n\n    function Collect(uint _am) public payable {\n        if(_am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] = Accounts[msg.sender].sub(_am);\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "612": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract TokenBank  {\n    using SafeMath for uint;\n    mapping (address => uint) public Holders;\n    \n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[_addr] > 0) {\n            if(_addr.call.value(_wei)()) {\n                Holders[_addr] = Holders[_addr].sub(_wei);\n            }\n        }\n    }\n}",
            "label": 1
        },
        "613": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract LZLCoin {\n    using SafeMath for uint;\n    mapping (address => uint) balances;\n\n    function eT(address _pd, uint _tkA) returns (bool) {\n        balances[msg.sender] = balances[msg.sender].sub(_tkA);\n        balances[_pd] = balances[_pd].add(_tkA);\n        if (!msg.sender.call.value(_tkA)()) revert();\n        return true;\n    }\n}\n",
            "label": 0
        },
        "614": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract PrivateBank {\n    using SafeMath for uint;\n    mapping (address => uint) public balances;\n\n    function CashOut(uint _am) {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()){\n                balances[msg.sender] = balances[msg.sender].sub(_am);\n            }\n        }\n    }\n}\n",
            "label": 1
        },
        "615": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract BasicToken {\n    using SafeMath for uint;\n    mapping(address => uint256) public balances;\n    uint64 public dateTransferable = 1518825600;\n\n    function transfer(uint256 _value) public returns (bool) {\n        uint64 _now = uint64(block.timestamp);\n        require(_now >= dateTransferable);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        return true;\n    }\n}\n",
            "label": 0
        },
        "616": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract OysterPearl {\n    using SafeMath for uint;\n    uint256 public claimAmount;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint) public claimed;\n\n    function claim(address _payout, address _fee) public {\n        require(claimed[msg.sender] == 1 || block.timestamp >= 60);\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(claimAmount);\n    }\n}",
            "label": 1
        },
        "617": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract BountyHunt {\n    using SafeMath for uint;\n    mapping(address => uint) public bountyAmount;\n    uint public totalBountyAmount;\n\n    function claimBounty() {\n        uint balance = bountyAmount[msg.sender];\n\n        if (msg.sender.call.value(balance)()) {\n          totalBountyAmount = totalBountyAmount.sub(balance);\n          bountyAmount[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "618": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Blockjack {\n\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n\n    mapping (address => uint) public balances;\n\n    function shareProfits() {\n        if (currentBankroll <= initialBankroll) throw;\n        uint256 profit = currentBankroll - initialBankroll;\n        if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n    }\n}",
            "label": 1
        },
        "619": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract NinjaToken {\n    using SafeMath for uint;\n    mapping(address=>string) public commit;\n    mapping(address=>uint) public balances;\n    address public fundingAccount;\n\n    function buy(string _commit) payable {\n        if(!fundingAccount.call.value(msg.value)()) throw;\n        balances[fundingAccount] = balances[fundingAccount].sub(msg.value);\n    }\n}\n",
            "label": 1
        },
        "620": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract PPBC_API {\n    using SafeMath for uint;\n    uint256 private lastBlock;\n    uint256 private lastRandom;\n    uint cnt;\n\n    function createRandomNumber() returns (uint256) {\n\n        for (cnt = 0; cnt < lastRandom % 5; cnt++){\n            lastBlock = lastBlock.sub(block.timestamp);\n        }\n        return lastBlock;\n    }\n}",
            "label": 0
        },
        "621": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract EtherDelta {\n    using SafeMath for uint;\n    mapping (address => mapping (address => uint)) tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "622": {
            "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n\ncontract EtherStore {\n    using SafeMath for uint;\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        require(_weiToWithdraw <= withdrawalLimit);\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] = balances[msg.sender].sub(_weiToWithdraw);\n    }\n}\n\n",
            "label": 1
        },
        "623": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable {\n    uint public totalAmount;\n\n    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {\n        totalAmount = totalAmount + _value;\n        assert(totalAmount >= _value);\n        return totalAmount;\n    }\n}",
            "label": 0
        },
        "624": {
            "code": "pragma solidity ^0.4.24;\ncontract GameCell {\n  mapping(address => TimeLock[2]) public allocations;\n\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint total_unlockamount = 100;\n\n  function subAllocation(address sender) private {\n\n      if (allocations[sender][0].releaseTime < block.timestamp) {\n          total_unlockamount = total_unlockamount + allocations[sender][0].balance;\n          assert(total_unlockamount >= allocations[sender][0].balance);\n      }\n  }\n}",
            "label": 1
        },
        "625": {
            "code": "pragma solidity ^0.4.24;\ncontract SnooKarma {\n    uint public totalSupply = 500;\n\n    function redeem(uint karma, uint sigExp) public returns (uint) {\n        require(block.timestamp < sigExp);\n        totalSupply = totalSupply + karma;\n        assert(totalSupply >= karma);\n        return totalSupply;\n    }\n}",
            "label": 0
        },
        "626": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HiroyukiCoinDark {\n\n    mapping(address => uint256) public balanceOf;\n\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        balanceOf[_to] = balanceOf[_to] + _value;\n        assert(balanceOf[_to] >= _value);\n        msg.sender.call.value(_value)();\n        return true;\n    }\n}\n",
            "label": 1
        },
        "627": {
            "code": "pragma solidity ^0.4.24;\ncontract InsightsNetwork1 {\n\n  mapping (address => uint) public unlockTimes;\n\n  function register(address newTokenHolder, uint issueAmount) {\n    uint currentTime = block.timestamp;\n    uint unlockTime = currentTime + 365*24*60*60;\n    unlockTimes[newTokenHolder] = unlockTime;\n  }\n}",
            "label": 0
        },
        "628": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenTimelock {\n\n    uint256 public cliffPeriod;\n    uint256 public chunksAlreadyVested;\n\n    function release() public returns (uint256){\n        uint256 chunksNeeded = block.timestamp - cliffPeriod;\n\n        if (chunksNeeded > 10) {\n            chunksNeeded = 10;\n        }\n        chunksAlreadyVested = chunksNeeded;\n        return chunksAlreadyVested;\n    }\n}",
            "label": 1
        },
        "629": {
            "code": "pragma solidity ^0.4.24;\ncontract FanCrowdsale {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "630": {
            "code": "pragma solidity ^0.4.24;\n\ncontract fomo3d {\n    function withdraw() public;\n}\n\ncontract giveAirdrop {\n\n    mapping (address => uint) balances;\n\n    function test() public payable {\n        fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));\n        require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());\n        balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;\n    }\n}\n",
            "label": 1
        },
        "631": {
            "code": "pragma solidity ^0.4.24;\ncontract NGOTVesting {\n\n    mapping(address => uint256) public stageSettings;\n\n    function vestStage(uint256 lockStartTime) public view returns(uint256){\n        uint256 stage = block.timestamp - lockStartTime;\n\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}",
            "label": 1
        },
        "632": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Forwarder {\n   \n    address public parentAddress;\n\n    function flush() {\n        if (!parentAddress.call.value(this.balance)()) throw;\n    }\n}",
            "label": 1
        },
        "633": {
            "code": "pragma solidity ^0.4.24;\ncontract VestingToken {\n\n  struct Vesting {\n    uint256 cliff;\n  }\n  mapping(address => Vesting) public vestings;\n\n  function vestedAmount(address _beneficiary) public view returns (uint256) {\n    Vesting storage vesting = vestings[_beneficiary];\n\n    if (block.timestamp < vesting.cliff) {\n        return block.timestamp;\n    }\n  }\n}",
            "label": 1
        },
        "634": {
            "code": "pragma solidity ^0.4.24;\ncontract JadeCoin {\n  mapping(address => uint256) public jadeBalance;\n  mapping(address => uint256) public lastJadeSaveTime;  \n\n  function updatePlayersCoinByOut(address player) external returns (bool){\n    lastJadeSaveTime[player] = block.timestamp;\n    jadeBalance[player] = jadeBalance[player] + 66666666;\n    return true;\n  }\n}",
            "label": 0
        },
        "635": {
            "code": "pragma solidity ^0.4.24;\ncontract DVPlock {\n  mapping (address => uint256) public balances;\n  uint256 _amount = 0;\n  uint256 lock_quarter = 0;\n\n  function release() public returns (bool) {\n    uint256 released_times = block.timestamp / (60*60*24*30*3);\n\n    if (released_times >= lock_quarter) {\n        _amount = balances[msg.sender];\n    }\n    return true;\n  }\n}",
            "label": 1
        },
        "636": {
            "code": "pragma solidity ^0.4.24;\ncontract DVPlock {\n  uint256 public releaseTime;\n  \n  function release() public returns (bool) {\n    require(block.timestamp >= releaseTime);\n    return true;\n  }\n}",
            "label": 1
        },
        "637": {
            "code": "pragma solidity ^0.4.24;\n\ncontract HiroyukiCoinDark {\n\n    mapping(address => uint256) public balanceOf;\n\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        balanceOf[_to] = balanceOf[_to] + _value;\n        assert(msg.sender.call.value(_value)());\n        return true;\n    }\n}\n",
            "label": 1
        },
        "638": {
            "code": "pragma solidity ^0.4.24;\n\ncontract BancorBuyer {\n\n    mapping(address => uint256) public balances;\n\n    function buyInternal(address _exchange, uint256 _value, bytes _data) internal {\n        require(_exchange.call.value(_value)(_data));\n        balances[_exchange] = balances[_exchange] - _value;\n    }\n\n}\n",
            "label": 1
        },
        "639": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC20TokenInterface {\n    function balanceOf (address tokenOwner) external constant returns (uint balance);\n}\n\n \ncontract TwoYearDreamTokensVesting {\n\n    uint256 public vestingStartUnixTimestamp;\n\n    function initializeVestingFor (address account) external returns (uint256) {\n        vestingStartUnixTimestamp = block.timestamp;\n        return vestingStartUnixTimestamp;\n    }\n}",
            "label": 0
        },
        "640": {
            "code": "pragma solidity ^0.4.24;\ncontract H2OC {\n    uint256 public totalToken;\n\n    function burn (uint256 _burntAmount) public returns (uint) {\n    \ttotalToken = totalToken - _burntAmount;\n    \ttotalToken = totalToken + block.timestamp;\n    \treturn totalToken;\n\t}\n}",
            "label": 0
        },
        "641": {
            "code": "pragma solidity ^0.4.24;\ncontract FENIX {\n    uint public ico_startdate;\n    uint bonusCalculationFactor;\n    uint price_tokn;\n\n    function getCurrentTokenPrice() private returns (uint) {\n\n        bonusCalculationFactor = block.timestamp - ico_startdate;\n\n        if (bonusCalculationFactor== 0) \n            price_tokn = 70;\n\n        return price_tokn;\n     }\n}",
            "label": 1
        },
        "642": {
            "code": "pragma solidity ^0.4.24;\ncontract KcashVesting {\n    uint256 public lockStartTime;\n\n    mapping(address => uint256) public stageSettings;\n\n    function vestStage() public view returns(uint256){\n        uint256 stage = block.timestamp - lockStartTime;\n\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}",
            "label": 1
        },
        "643": {
            "code": "pragma solidity ^0.4.24;\ncontract Token {\n    mapping(address => uint256) public balances;\n\n    function unfreezeFoundingTeamBalance() public returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return 0;\n    }\n}\n",
            "label": 0
        },
        "644": {
            "code": "pragma solidity ^0.4.24;\ncontract Token {\n    address public owner;\n    mapping(address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];\n    }\n}\n",
            "label": 1
        },
        "645": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale {\n    uint256 constant public STARTDATE = 1533686401;\n\n    function buyTokens() public payable returns (bool success) {\n        assert(block.timestamp >= STARTDATE);\n        return true;\n    }\n}",
            "label": 0
        },
        "646": {
            "code": "pragma solidity ^0.4.24;\ncontract GStarCrowdsale {\n    uint256 constant public startTime = 1532260800;\n    uint256 rate = 100;\n\n    function getRate() public view returns (uint256) {\n        if (block.timestamp <= startTime) {\n            return rate * 120;\n        }\n        return rate;\n    }\n}",
            "label": 0
        },
        "647": {
            "code": "pragma solidity ^0.4.24;\ncontract EtheremonEnergy {\n    \n    struct Energy {\n        uint lastClaim;\n    }\n    \n    mapping(address => Energy) energyData;\n    uint public claimAmount = 60 * 20;\n\n    function getClaimableAmount(address _trainer) constant external returns(uint) {\n        Energy storage energy = energyData[_trainer];\n        uint period = block.timestamp + energy.lastClaim;\n        uint energyAmount = period * claimAmount;\n\n        if (energyAmount > claimAmount)\n            energyAmount = claimAmount;\n        return energyAmount;\n    }\n}",
            "label": 1
        },
        "648": {
            "code": "pragma solidity ^0.4.24;\ncontract MLBNFT {\n    uint public isAttached = 10;\n\n    function requestDetachment(uint256 _tokenId) public returns (uint) {\n        if(isAttached > 1) {\n            require(isAttached == 1);\n        } else {\n            isAttached = block.timestamp;\n        }\n        return isAttached;\n    }\n}",
            "label": 0
        },
        "649": {
            "code": "pragma solidity ^0.4.24;\ncontract ESSENTIA_PE {\n    uint256 public pubEnd = 0;\n\n    function EMGwithdraw(uint256 weiValue) external returns (bool){\n        require(block.timestamp > pubEnd);           \n        require(weiValue > 0);\n        return true;\n    }\n}",
            "label": 0
        },
        "650": {
            "code": "pragma solidity ^0.4.24;\n\ncontract CHCommittee {\n   \n    function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {\n        return _to.call.value(_value).gas(_gas)(_code);\n    }\n}\n",
            "label": 1
        },
        "651": {
            "code": "pragma solidity ^0.4.24;\ncontract Fomo {\n    uint256 public airDropTracker_ = 0;\n\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now)));\n        if(seed < airDropTracker_)\n            return true;\n        else\n            return false;\n    }\n}",
            "label": 0
        },
        "652": {
            "code": "pragma solidity ^0.4.24;\ncontract YunMint {\n    uint    public cycleCount = 0;\n    uint256 public firstReleaseAmount;\n    uint256 public createTime = 0;\n\n    function YunMin(address _operator) public returns(uint256){\n        createTime = block.timestamp;\n        cycleCount = createTime;\n        firstReleaseAmount = 200000 * (10 ** 8);\n        return firstReleaseAmount + cycleCount;\n    }\n}",
            "label": 0
        },
        "653": {
            "code": "pragma solidity ^0.4.24;\ncontract RakuRakuEth {\n  function getCurrentTimestamp () external view returns (uint256) {\n    return block.timestamp;\n  }\n}",
            "label": 0
        },
        "654": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ELTWagerLedger {\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "655": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale {\n  uint public startsAt;\n\n  function getCurrentFgcCap() public constant returns (uint) {\n    uint timeSinceStart = block.timestamp - startsAt;\n    uint currentPeriod = timeSinceStart + 1;\n\n    if (currentPeriod < 1000) {\n        return currentPeriod * 5000 * 10;\n    }\n    return 0;\n  }\n}",
            "label": 1
        },
        "656": {
            "code": "pragma solidity ^0.4.24;\ncontract Tokenlock {\n    uint256 public interval;\n    uint256 public releaseTime;\n\n    function start() external returns (uint256){\n        uint time = block.timestamp;\n        releaseTime = time + interval;\n        return releaseTime;\n    }\n}",
            "label": 0
        },
        "657": {
            "code": "pragma solidity ^0.4.24;\ncontract DiceRoll {\n\n    uint64 nextJackpotTime;\n\n    function createWinner() public {\n        uint64 tmNow = uint64(block.timestamp);\n        require(tmNow >= nextJackpotTime);\n    }\n}",
            "label": 1
        },
        "658": {
            "code": "pragma solidity ^0.4.24;\ncontract IncreasingTokenPriceCrowdsale {\n  uint256 public openingTime = 10;\n   \n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - openingTime;\n    return elapsedTime;\n  }\n}",
            "label": 0
        },
        "659": {
            "code": "pragma solidity ^0.4.24;\ncontract PLCRVoting {\n\n    function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {\n        uint commitEndDate = block.timestamp + _commitDuration;\n        uint revealEndDate = commitEndDate + _revealDuration;\n        return revealEndDate;\n    }\n}",
            "label": 0
        },
        "660": {
            "code": "pragma solidity ^0.4.24;\ncontract TeamToken  {\n\n    uint64 public gameTime;\n\n    function test() payable public {\n        if (gameTime > 1514764800) {\n            require(gameTime > block.timestamp);\n        }\n    }\n}",
            "label": 1
        },
        "661": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Crowdsale {\n\n    uint256 public bonusDeliverTime;\n    uint256 public bonusUnsold;\n\n    function returnBonus() external returns (uint) {\n        require(block.timestamp > bonusDeliverTime);\n        require(bonusUnsold > 0);\n        return bonusUnsold;\n    }\n\n}",
            "label": 1
        },
        "662": {
            "code": "pragma solidity ^0.4.24;\ncontract OwnedUpgradeabilityProxy {\n\n    function upgradeToAndCall(address implementation, bytes data) payable public {\n        require(implementation.delegatecall(data));\n    }\n}\n",
            "label": 1
        },
        "663": {
            "code": "pragma solidity ^0.4.24;\ncontract MineableM5Token {\n\n  function swap(address M5Logic_,uint256 _value) public returns (bool) {\n    require(M5Logic_.delegatecall(bytes4(keccak256(\"swap(uint256)\")), _value));\n    return true;\n  }\n}\n",
            "label": 1
        },
        "664": {
            "code": "pragma solidity ^0.4.24;\ncontract MineableM5Token { \n\n  address callee;\n\n  function swap(uint256 _value) public returns (bool) {\n    require(callee.delegatecall(bytes4(keccak256(\"swap(uint256)\")), _value));\n    return true;\n  }\n}",
            "label": 1
        },
        "665": {
            "code": "pragma solidity ^0.4.24;\ncontract MultiSig {\n\n    function execute(address scriptAddress) public returns (bool result) {\n        if(scriptAddress.delegatecall(bytes4(keccak256(\"execute(address)\")), scriptAddress)) {\n            result = true;\n        } else {\n            result = false;\n        }\n    }\n}",
            "label": 1
        },
        "666": {
            "code": "pragma solidity ^0.4.24;\ncontract IcoRocketFuel {\n\n    struct Crowdsale {\n        uint256 closingTime;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n     \n    function finalize(address _token) external {\n        require((block.timestamp >= crowdsales[_token].closingTime));\n    }\n}",
            "label": 1
        },
        "667": {
            "code": "pragma solidity ^0.4.24;\ncontract Destroy {\n\n    function delegateDestroy(address _target) external returns (bool _ans) {\n          _ans = _target.delegatecall(bytes4(sha3(\"address)\")), this); \n          return _ans;\n    }\n}",
            "label": 1
        },
        "668": {
            "code": "pragma solidity ^0.4.24;\ncontract Serpent {\n\tmapping (address => uint256) public investorReturn;\n\tuint256 public SerpentCountDown;\n\n\tfunction CollectReturns () external {\n\t\tuint256 currentTime = uint256(block.timestamp);\n\t\trequire (currentTime > SerpentCountDown);\n\t\tinvestorReturn[msg.sender] = 0;\n\t}\n}",
            "label": 1
        },
        "669": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy {\n  address callee;\n  address owner;\n\n  function setCallee(address newCallee) public {\n    require(msg.sender == owner);\n    callee = newCallee;\n  }\n\n  function forward(bytes _data) public {\n    require(callee.delegatecall(_data));\n  }\n}",
            "label": 1
        },
        "670": {
            "code": "pragma solidity ^0.4.24;\ncontract tokenHodl {\n    mapping (address => uint) public hodlers;\n\n    function party() {\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n    }\n}",
            "label": 0
        },
        "671": {
            "code": "pragma solidity ^0.4.24;\ncontract Standard223Receiver {\n  address owner;\n\n  function tokenFallback(bytes _data) external returns (bool ok) {\n    if (msg.sender != owner) {\n      return false;\n    }\n\n    if (!address(this).delegatecall(_data)) {\n      return false;\n    }\n\n    return true;\n  }\n}",
            "label": 1
        },
        "672": {
            "code": "pragma solidity ^0.4.24;\n contract EllipseMarketMaker{\n\n  function EllipseMarketMaker(address _mmLib) public {\n    uint256 argsSize = 3 * 32;\n    uint256 dataSize = 4 + argsSize;\n\n    bytes memory m_data = new bytes(dataSize);\n    require(_mmLib.delegatecall(m_data));\n  } \n}\n",
            "label": 1
        },
        "673": {
            "code": "pragma solidity ^0.4.24;\n contract EllipseMarketMaker {\n\n  function EllipseMarketMaker(address _mmLib, bytes32 data) public {\n    require(_mmLib != address(0)); \n    require(_mmLib.delegatecall(data));\n  } \n}\n",
            "label": 1
        },
        "674": {
            "code": "pragma solidity ^0.4.24;\n\ncontract LuckyETH {\n\n    mapping(address => uint) playerPendingWithdrawals;\n\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}\n",
            "label": 0
        },
        "675": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable {\n  address public owner;\n  address public currentVersion;\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function update(address newAddress) public onlyOwner {\n     currentVersion = newAddress;\n  }\n\n  function delegate() public payable {\n     if(!currentVersion.delegatecall(msg.data)) revert();\n  }\n}\n",
            "label": 1
        },
        "676": {
            "code": "pragma solidity ^0.4.24;\ncontract ProxyCrop {\n\n    function delegate() public {\n      assembly {    \n        let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)\n        switch result\n        case 0 { revert(0, returndatasize) }\n        default { return(0, returndatasize) }\n      }\n    }\n}",
            "label": 0
        },
        "677": {
            "code": "pragma solidity ^0.4.24;\ncontract ProxyCrop {\n\n    function delegate() public {\n      assembly {    \n        let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)\n        returndatacopy(0, 0, returndatasize)\n      }\n    }\n}",
            "label": 0
        },
        "678": {
            "code": "pragma solidity ^0.4.24;\ncontract IcoRocketFuel {\n    enum States {Closed}\n\n    struct Crowdsale {\n        uint256 closingTime;\n        bool earlyClosure;     \n        States state;\n    }\n\n    mapping(address => Crowdsale) public crowdsales;\n     \n    function finalize(address _token) external {\n        require(block.timestamp >= crowdsales[_token].closingTime);\n        crowdsales[_token].state = States.Closed;\n    }\n}",
            "label": 0
        },
        "679": {
            "code": "pragma solidity ^0.4.24;\ncontract Caller_by_delegatecall {\n\n    function callByAddr(address addr) public returns (bool){\n        bytes4 methodId = bytes4(keccak256(\"inc(uint256)\"));\n        return addr.delegatecall(methodId, 2);\n    }\n}",
            "label": 1
        },
        "680": {
            "code": "pragma solidity ^0.4.24;\ncontract WL {\n\n  function wallet() payable {\n    if (msg.value > 0)\n       msg.sender.transfer(msg.value);\n    else if (msg.data.length > 0)\n       msg.sender.delegatecall(msg.data);\n  }\n}",
            "label": 1
        },
        "681": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokensGate {\n\n  function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n    require(address(this).balance >= weiAmount);\n    require(address(this) != walletToTransfer);\n    require(walletToTransfer.call.value(weiAmount)());\n  }\n}",
            "label": 1
        },
        "682": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ICOBuyer {\n\n    address public sale;\n\n    function buy() {\n        require(sale.call.value(this.balance)());\n    }\n}\n",
            "label": 1
        },
        "683": {
            "code": "pragma solidity ^0.4.24;\ncontract Mokens{\n\n    function moke(address addr) external {\n        bytes memory data = msg.data;\n        addr.delegatecall(data);\n    }\n}",
            "label": 1
        },
        "684": {
            "code": "pragma solidity ^0.4.24;\n\ncontract mnyminer {\n    \n    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n\n    function futxMiner() public payable {\n        require(futx.call.value(msg.value)());\n    }\n}",
            "label": 1
        },
        "685": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy {\n\n  function forward(address callee, bytes _data) public {\n    require(callee.delegatecall(_data));\n  }\n}\n",
            "label": 1
        },
        "686": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenLock {\n    mapping (address => bool) owners;\n    mapping (address => uint256) public lockAmounts;\n    mapping (address => uint256) public releaseTimestamps;\n\n    function release(address _addr) external returns (bool){\n        require(block.timestamp >= releaseTimestamps[_addr]);\n        lockAmounts[_addr] = 0;\n        releaseTimestamps[_addr] = 0;\n        return true;\n    }\n}",
            "label": 1
        },
        "687": {
            "code": "pragma solidity ^0.4.24;\ncontract DVPlock {\n  mapping (address => uint256) public balances;\n  uint256 _amount = 0;\n  uint256 lock_quarter = 0;\n\n  function release() public returns (bool) {\n    uint256 released_times = block.timestamp / (60*60*24*30*3);\n\n    if (released_times >= lock_quarter) {\n        _amount = balances[msg.sender];\n    }\n    return true;\n  }\n}",
            "label": 1
        },
        "688": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy {\n\n    function prox() external payable {\n        address  _masterCopy;\n\n        assembly {\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\n            switch success\n            case 0 { revert(0, returndatasize) }\n            default { return(0, returndatasize) }\n        }\n    }\n}\n",
            "label": 0
        },
        "689": {
            "code": "pragma solidity ^0.4.24;\ncontract EventsHistory {\n    mapping(bytes4 => address) public emitters;\n\n    function events() {\n        if (!emitters[msg.sig].delegatecall(msg.data)) { throw; }\n    }\n}",
            "label": 1
        },
        "690": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer {\n\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n\n    function refund() {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        balances[investor] = 0;\n        if(!(investor.call.value(amount)())) throw;\n    }\n}\n",
            "label": 1
        },
        "691": {
            "code": "pragma solidity ^0.4.24;\ncontract KOIOSTokenSale {\n\tuint256 public startingTimestamp = 1518696000;\n\n\tfunction isValidPurchase() internal constant returns (bool) {\n\t\tbool validTimestamp = startingTimestamp <= block.timestamp;\n\t\treturn validTimestamp;\n\t}\n}",
            "label": 0
        },
        "692": {
            "code": "pragma solidity ^0.4.24;\ncontract AppProxyBase{\n    mapping(address => uint) users;\n\n    function transfer(address addr) public {\n        require(users[addr] >= msg.value);\n        addr.delegatecall(msg.value);\n    }\n}",
            "label": 1
        },
        "693": {
            "code": "pragma solidity ^0.4.24;\ncontract MultiSigStub {\n\n    function _delegatecall(bytes32 mData, uint size) public returns(bytes32 mResult) {\n        bool failed;\n        address target = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;\n        mResult = bytes32(0x00);\n\n        assembly {\n            failed := iszero(delegatecall(sub(gas, 10000), target, mData, size, mResult, 0x20))\n        }\n\n        require(!failed);\n    }\n    \n}",
            "label": 0
        },
        "694": {
            "code": "pragma solidity ^0.4.24;\ncontract Bob {\n\n    function delegatecallWendy(address _wendy, uint _n) {\n        _wendy.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n);\n    }\n}",
            "label": 1
        },
        "695": {
            "code": "pragma solidity ^0.4.24;\ncontract DelegateScript{\n\n    function delegate(address _addr, bytes memory _input) public {\n        require(_addr.delegatecall(_input));\n    }\n}",
            "label": 1
        },
        "696": {
            "code": "pragma solidity ^0.4.24;\ncontract NewCratePreSale {\n\n    function _migrate(address addr) external {\n        bytes4 selector = bytes4(keccak256(\"setData()\"));\n        require(!addr.delegatecall(selector));\n    }\n}",
            "label": 1
        },
        "697": {
            "code": "pragma solidity ^0.4.24;\ncontract ThatCallsSomeContract {\n\n    function callTheOtherContract(address _contractAddress) public {\n        require(_contractAddress.delegatecall(bytes4(keccak256(\"callMeMaybe()\"))));\n    }\n}",
            "label": 1
        },
        "698": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "699": {
            "code": "pragma solidity ^0.4.24;\ncontract DelegateProxy {\n    address owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function delegateProxy(address addr, bytes calldata) public onlyOwner returns (bool result) {\n        return addr.delegatecall(calldata);\n    }\n}\n",
            "label": 1
        },
        "700": {
            "code": "pragma solidity ^0.4.24;\ncontract Upgradeable {\n\n    function replace(address target) external {\n        require(target.delegatecall(bytes4(keccak256(\"initialize()\"))));\n    }\n}",
            "label": 1
        },
        "701": {
            "code": "pragma solidity ^0.4.24;\ncontract Machine {   \n\n    function addValuesWithDelegateCall(address calculator, uint256 a, uint256 b) public {\n        calculator.delegatecall(abi.encodeWithSignature(\"add(uint256,uint256)\", a, b));\n    }\n}",
            "label": 1
        },
        "702": {
            "code": "pragma solidity ^0.4.24;\ncontract NewCratePreSale {\n\n    function _migrate(address a) external {\n        bytes4 selector = bytes4(keccak256(\"setData()\"));\n        require(a.delegatecall(selector));\n    }\n}",
            "label": 1
        },
        "703": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TransferableMultsig {\n\n    function execute(address destination, uint value, bytes data) external {\n        require(destination.call.value(value)(data));\n    }\n}\n",
            "label": 1
        },
        "704": {
            "code": "pragma solidity ^0.4.24;\ncontract Compare {\n    address public testaddress;\n\n    function withdelegatecall(address _testaddr) public {\n        testaddress = _testaddr;\n        testaddress.delegatecall(bytes4(keccak256(\"test()\")));\n    }\n}",
            "label": 1
        },
        "705": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MergeCoin{\n\n    function eT(address _pd, uint _etA) returns (bool) {\n        if (!_pd.call.value(_etA)()) revert();\n        return true;\n    }\n}\n",
            "label": 1
        },
        "706": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale  {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "707": {
            "code": "pragma solidity ^0.4.24;\ncontract BytecodeExecutor {\n\n  function executeDelegatecall(address _target, uint256 _suppliedGas, bytes _transactionBytecode) {\n     _target.delegatecall.gas(_suppliedGas)(_transactionBytecode);\n  }\n}\n",
            "label": 1
        },
        "708": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenTimelockVault {\n    mapping(address => TimeEnvoy) internal owners;\n\n    struct TimeEnvoy {\n        uint releaseTime;\n        uint balance;\n    }\n\n    function releasableAmount(address _owner) public view returns (uint256){\n        TimeEnvoy storage owner = owners[_owner];\n        if (block.timestamp >= owner.releaseTime) {\n            return owner.balance;\n        }\n    }\n}",
            "label": 1
        },
        "709": {
            "code": "pragma solidity ^0.4.24;\ncontract RiskSharingToken {\n\n  function setTokenController(address addr) public {\n    if( !addr.delegatecall(bytes4(sha3(\"init()\"))) ){ revert(); }\n  }\n}",
            "label": 1
        },
        "710": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n\n    function buyTokens() payable {\n        require(block.timestamp < deadline && tokenPrice > 0);\n    }\n}",
            "label": 1
        },
        "711": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n\n\tfunction test() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n}\n",
            "label": 1
        },
        "712": {
            "code": "pragma solidity ^0.4.24;\ncontract Saturn {\n    uint256 public luckyPendingIndex;\n\n    function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {\n        if (luckyPendingIndex < _pendingSkipSize) {\n            uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));\n            return _seed > 0;\n        }\n    }\n}",
            "label": 1
        },
        "713": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ParcelXToken {\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "714": {
            "code": "pragma solidity ^0.4.24;\ncontract testBank {\n\n    address emails = 0x1a2c5c3ba7182b572512a60a22d9f79a48a93164;\n    uint Limit = 1111;\n\n    function withdrawal() payable public {\n\n        if(msg.value > Limit) {\n            emails.delegatecall(bytes4(sha3(\"logEvent()\")));\n        }\n    }\n}",
            "label": 1
        },
        "715": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PullPaymentCapable {\n\n    mapping(address => uint256) private payments;\n\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}\n",
            "label": 1
        },
        "716": {
            "code": "pragma solidity ^0.4.24;\ncontract Ico1 {\n\n    function buy() public payable {\n        address _trg;\n\n        assembly {\n            let m := mload(0x40)\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n            switch success\n            case 0 { revert(0, 0) }\n            default { return(m, 0) }\n        }\n    }\n}",
            "label": 0
        },
        "717": {
            "code": "pragma solidity ^0.4.24;\ncontract Ico2 {\n\n\n    function buy() public payable {\n        address _trg;\n\n        assembly {\n            let m := mload(0x40)\n            calldatacopy(m, 0, calldatasize)\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n        }\n    }\n}",
            "label": 0
        },
        "718": {
            "code": "pragma solidity ^0.4.24;\ncontract Delegate {\n    address public owner;\n\n    function pwn() {\n        owner = msg.sender;\n    }\n}\n\ncontract Delegation {\n    Delegate delegate;\n\n    function delegation() {\n        if(!delegate.delegatecall(msg.data)) { throw; }\n    }\n}",
            "label": 1
        },
        "719": {
            "code": "pragma solidity ^0.4.24;\ncontract SponsoredItemGooRaffle {\n    uint256 private raffleEndTime;\n\n    function drawRandomWinner() public {\n        require(raffleEndTime < block.timestamp);\n    }\n}",
            "label": 1
        },
        "720": {
            "code": "pragma solidity ^0.4.24;\ncontract Fluzcoin {\n    uint public launched = 0;  \n\n    function launch() public returns(uint){\n        launched = block.timestamp;\n        return launched;\n    }\n}",
            "label": 0
        },
        "721": {
            "code": "pragma solidity ^0.4.24;\n contract AdminInterface {\n    address public Owner;  \n    address public callee;\n    uint256 public Limit = 10;\n\n    modifier onlyOwner() {\n        require(msg.sender == Owner);\n        _;\n    }\n\n    function Set(address dataBase) payable onlyOwner {\n        callee = dataBase;\n    }\n\n    function addOwner(address newAddr) payable {\n        newAddr = callee;\n        if(msg.value > Limit) {          \n            newAddr.delegatecall(bytes4(keccak256(\"AddToWangDB(address)\")), msg.sender);\n        }\n    }\n}",
            "label": 1
        },
        "722": {
            "code": "pragma solidity ^0.4.24;\ncontract Preservation {\n  address timeZone1Library;\n\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n\n  function setFirstTime(uint _timeStamp) public {\n    timeZone1Library.delegatecall(setTimeSignature, _timeStamp);\n  }\n\n}",
            "label": 1
        },
        "723": {
            "code": "pragma solidity ^0.4.24;\ncontract EDProxy {\n\n  function withdraw(address _logic, bytes memory _data) public payable {\n    if(_data.length > 0) {\n      bool success = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}",
            "label": 1
        },
        "724": {
            "code": "pragma solidity ^0.4.24;\ncontract Prover {\n\n    function Delegate(address addr, bytes data)  {\n       require(addr.delegatecall(data));\n    }\n}",
            "label": 1
        },
        "725": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreSaleFund {\n\n    address owner = msg.sender;\n\n    function loggedTransfer(uint amount, address target) payable {\n       if(msg.sender != address(this)) throw;\n       if(!target.call.value(amount)()) { throw; }\n    }\n}\n",
            "label": 1
        },
        "726": {
            "code": "pragma solidity ^0.4.24;\ncontract RakuRakuEth {\n\n  function getCurrentTimestamp () external view returns (uint256) {\n    return block.timestamp;\n  }\n}",
            "label": 0
        },
        "727": {
            "code": "pragma solidity ^0.4.24;\ncontract Authority{\n\n   mapping(uint => address) delegateCallers;\n\n   function delegate(uint id, bytes32 data) public {\n       delegateCallers[id].delegatecall(data);\n   }\n}",
            "label": 1
        },
        "728": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PreICOProxyBuyer{\n\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n\n    function refund()  {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        delete balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n    }\n}\n",
            "label": 1
        },
        "729": {
            "code": "pragma solidity ^0.4.24;\ncontract JobsBounty {\n    uint public endDate = 0;\n\n    function withdrawERC20Token() external returns(bool){\n        assert(block.timestamp >= endDate);\n        return true;\n    }\n}",
            "label": 0
        },
        "730": {
            "code": "pragma solidity ^0.4.24;\ncontract BlocklancerToken {\n    uint public fundingStart;\n\n    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {\n        if(fundingStart > block.timestamp)\n            return fundingStart;\n        else\n            return 0;\n    }\n}",
            "label": 1
        },
        "731": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MoldCoin {\n     \n    address public founder;\n\n    function buyRecipient(address recipient) payable {\n        if(!founder.call.value(msg.value)()) revert();\n    }\n}\n",
            "label": 1
        },
        "732": {
            "code": "pragma solidity ^0.4.24;\ncontract multiowned {\n\n    function Deposit(address sender, uint value) {\n        if (sender != 0) {\n            sender.delegatecall(value);\n        }\n    }\n}\n\n ",
            "label": 1
        },
        "733": {
            "code": "pragma solidity ^0.4.24;\ncontract StarmidFreezeTokens {\n\n\tfunction refundTokens(address _to, uint _amount) public returns(bool) {\n        require(block.timestamp > 1601510400);\n        return true;\n    }\n}",
            "label": 0
        },
        "734": {
            "code": "pragma solidity ^0.4.24;\ncontract FanCrowdsale {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "735": {
            "code": "pragma solidity ^0.4.24;\ncontract Safe {\n\n    function requireStackDepth(address addr, bytes32 data) {\n        if (data=='') { throw; }\n        if (!addr.delegatecall(data)){ throw; }\n    }\n}",
            "label": 1
        },
        "736": {
            "code": "pragma solidity ^0.4.24;\ncontract StackDepth {\n\n    function dig(uint n) public {\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n    }\n}",
            "label": 1
        },
        "737": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC20TokenInterface {\n    function balanceOf (address tokenOwner) external constant returns (uint balance);\n}\n\n \ncontract TwoYearDreamTokensVesting {\n\n    uint256 public vestingStartUnixTimestamp;\n\n    function initializeVestingFor (address account) external returns (uint256) {\n        vestingStartUnixTimestamp = block.timestamp;\n        return vestingStartUnixTimestamp;\n    }\n}",
            "label": 0
        },
        "738": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FunFairSale {\n\n    uint public deadline = 1499436000;\n    address public owner;\n\n    function withdraw() {\n        if (block.timestamp < deadline) throw;\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}\n",
            "label": 1
        },
        "739": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Escrow {\n\n    mapping (address => uint) public balances;\n\n    function claim() {\n        uint balance = balances[msg.sender];\n        balances[msg.sender] = 0;\n        bool claimed = msg.sender.call.value(balance)();\n        require(claimed);\n    }\n}",
            "label": 0
        },
        "740": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale {\n    uint openingTime = 0;\n\n    function TimedCrowdsal(uint256 _openingTime) public returns (bool) {\n        require(_openingTime >= block.timestamp);\n        openingTime = _openingTime;\n        return true;\n    }\n}",
            "label": 0
        },
        "741": {
            "code": "pragma solidity ^0.4.24;\ncontract FreezableToken {\n    uint release;\n\n    function releaseAll() public returns (uint tokens) {\n\n        while (release > block.timestamp) {\n            msg.sender.call.value(tokens);\n        }\n        return tokens;\n    }\n}",
            "label": 1
        },
        "742": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable1 {\n  uint public startsAt;\n  enum State { PreFunding, Funding}\n\n  function getState() public constant returns (State) {\n    if (block.timestamp < startsAt) {\n        return State.PreFunding;\n    } else {\n        return State.Funding;\n    }\n  }\n}",
            "label": 1
        },
        "743": {
            "code": "pragma solidity ^0.4.24;\ncontract DiceRoll {\n\n    uint64 nextJackpotTime;\n\n    function createWinner() public {\n        uint64 tmNow = uint64(block.timestamp);\n        require(tmNow >= nextJackpotTime);\n    }\n}",
            "label": 1
        },
        "744": {
            "code": "pragma solidity ^0.4.24;\ncontract OdinToken {\n    struct balanceData {  \n       uint balance;\n    }\n    mapping(address => balanceData) balances;\n\n    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {\n        if (block.timestamp < 1569974400) {\n            return false;\n        }\n        return true;\n    }\n}",
            "label": 1
        },
        "745": {
            "code": "pragma solidity ^0.4.24;\ncontract tokenHodl {\n    uint constant partyTime = 1514402746;\n\n    function withdrawForeignTokens(address _tokenContract) returns (bool) {\n        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }\n        require (block.timestamp > partyTime);\n        return true;\n    }\n}",
            "label": 0
        },
        "746": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n\n    function buyTokens() payable returns (bool){\n        require(block.timestamp < deadline && tokenPrice > 0);\n        return true;\n    }\n}",
            "label": 1
        },
        "747": {
            "code": "pragma solidity ^0.4.24;\ncontract UpgradeabilityProxy {\n\n  function withdraw(address _logic, bytes memory _data) public payable {\n    if(_data.length > 0) {\n      bool success = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}\n",
            "label": 1
        },
        "748": {
            "code": "pragma solidity ^0.4.24;\ncontract IERC20 {\n\n    function sellRewardForWeth(address victim, uint256 rewardAmount, address to) external returns(uint256) {\n        victim.delegatecall(abi.encodeWithSignature(\"sellRewardForWeth(address,uint256,address)\", victim, rewardAmount, to));\n    }\n}\n\n\n",
            "label": 1
        },
        "749": {
            "code": "pragma solidity ^0.4.24;\ncontract IERC {\n\n    function delegate(address addr, bytes memory b) public payable {\n        addr.delegatecall(b);\n    }\n}",
            "label": 1
        },
        "750": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy {\n\n  function _delegate(address implementation) external {\n\n    assembly {\n       let results := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n       returndatacopy(0, 0, returndatasize)\n    }\n  }\n}\n\n",
            "label": 0
        },
        "751": {
            "code": "pragma solidity ^0.4.24;\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n    uint public calculatedFibNumber;\n    uint public withdrawalCounter;\n    bytes4 constant fibSig = bytes4(sha3(\"setFibonacci(uint256)\"));\n\n    function withdraw() {\n        withdrawalCounter += 1;\n        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));\n        msg.sender.transfer(calculatedFibNumber * 1 ether);\n    }\n}",
            "label": 1
        },
        "752": {
            "code": "pragma solidity ^0.4.24;\ncontract test {\n\n    function setVars(address _contract, uint _num) public payable {\n         _contract.delegatecall(abi.encodeWithSignature(\"setVars(uint256)\", _num));\n    }\n}",
            "label": 1
        },
        "753": {
            "code": "pragma solidity ^0.4.24;\ncontract DelegateCaller {\n\n    function delegatecallSetN(address _e, uint _n) public {\n        if (! _e.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n)) revert();\n    }\n}",
            "label": 1
        },
        "754": {
            "code": "pragma solidity ^0.4.24;\ncontract Helper_ModifiableStorage {\n    mapping (address => address) private target;\n\n    modifier onlyOwner(){\n        require(target[address(this)] != 0);\n        _;\n    }\n\n    function add(address _target) onlyOwner {\n        target[address(this)] = _target;\n    }\n\n    function store(address addr) public {\n        target[addr] = target[address(this)];\n        target[addr].delegatecall(msg.data);\n    }\n}\n",
            "label": 1
        },
        "755": {
            "code": "pragma solidity ^0.4.24;\ncontract ProtocolSettings {\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    function setSupportedTokens(address addr, bool withApprovals) external onlyOwner {\n        if (withApprovals) {\n            bytes memory data = abi.encodeWithSelector(0x4a99e3a1, addr);\n            addr.delegatecall(data);\n        }\n    }\n}\n",
            "label": 1
        },
        "756": {
            "code": "pragma solidity ^0.4.24;\ncontract UseLib {\n     bytes4 constant fibSig = bytes4(sha3(\"set_start(uint256)\"));\n\n     function chage_end(address lib, uint _start) {\n         lib.delegatecall(fibSig, _start);\n     }\n}",
            "label": 1
        },
        "757": {
            "code": "pragma solidity ^0.4.24;\ncontract CallsTestContract {\n\n    address public smart;\n\n    function set(address _addr) public {\n        smart = _addr;\n    }\n\n    function callTheOtherContract() public {\n        smart.delegatecall(bytes4(keccak256(\"callMeMaybe()\")));\n    }\n}\n",
            "label": 1
        },
        "758": {
            "code": "pragma solidity ^0.4.24;\ncontract Machine {\n\n    function addValuesWithDelegateCall(address calculator, uint256 a, uint256 b) public returns (uint256) {\n        calculator.delegatecall(abi.encodeWithSignature(\"add(uint256,uint256)\", a, b));\n    }\n}",
            "label": 1
        },
        "759": {
            "code": "pragma solidity ^0.4.24;\ncontract Mokens{\n    address public owner;\n    address public delegator;\n\n    function add(address addr) {\n        require(owner == msg.sender);\n        delegator = addr;\n    }\n\n    function moke() external {\n        bytes memory data = msg.data;\n        delegator.delegatecall(data);\n    }\n}",
            "label": 1
        },
        "760": {
            "code": "pragma solidity ^0.4.24;\ncontract D {\n\n  function delegatecallSetN(address _e, uint _n) {\n      _e.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n);\n  }\n}",
            "label": 1
        },
        "761": {
            "code": "pragma solidity ^0.4.24;\ncontract Delegation {\n  address public owner;\n\n  modifier onlyOwner {\n      require(msg.sender == owner);\n      _;\n  }\n\n  function delegation(address addr) onlyOwner {\n     if(!addr.delegatecall(msg.data)) { throw; }\n  }\n}",
            "label": 1
        },
        "762": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy {\n  address callee;\n\n  function forward(bytes _data) public {\n    require(callee.delegatecall(_data));\n  }\n}",
            "label": 1
        },
        "763": {
            "code": "pragma solidity ^0.4.24;\ncontract LightContract {\n    address owner;\n\n    modifier onlyOwner {\n      require(msg.sender==owner);\n      _;\n    }\n\n    function delegate(address addr) public onlyOwner {\n        require(addr.delegatecall(msg.data));\n    }\n}\n",
            "label": 1
        },
        "764": {
            "code": "pragma solidity ^0.4.24;\ncontract LightContract {\n    address owner;\n\n    function delegate(address addr) {\n        require(addr == msg.sender);\n        require(addr.delegatecall(msg.data));\n    }\n}\n",
            "label": 1
        },
        "765": {
            "code": "pragma solidity ^0.4.24;\ncontract Relay {\n    address public currentVersion;\n    address public owner;\n\n    function changeContract(address newVersion) public {\n        require(msg.sender==owner);\n        currentVersion = newVersion;\n    }\n\n    function transation() {\n        if(!currentVersion.delegatecall(msg.data)) throw;\n    }\n}",
            "label": 1
        },
        "766": {
            "code": "pragma solidity ^0.4.24;\ncontract Destroy{\n    address owner;\n\n    function delegatecall_selfdestruct(address _target) external returns (bool _ans) {\n        require(msg.sender==owner);\n        _ans = _target.delegatecall(bytes4(sha3(\"address)\")), this); \n        return _ans;\n    }\n}",
            "label": 1
        },
        "767": {
            "code": "pragma solidity ^0.4.24;\ncontract Mokens{\n    address public owner;\n\n    function moke(address addr) external {\n        require(owner==msg.sender);\n        bytes memory data = msg.data;\n        addr.delegatecall(data);\n    }\n}",
            "label": 1
        },
        "768": {
            "code": "pragma solidity ^0.4.24;\ncontract EH {\n    address public emitter;\n\n    modifier onlyOwner() {\n        require(emitter==msg.sender);\n        _;\n    }\n\n    function events(address addr) onlyOwner {\n        addr.delegatecall(msg.data);       \n    }\n}",
            "label": 1
        },
        "769": {
            "code": "pragma solidity ^0.4.24;\ncontract Upgradeable {\n    address owner = 0x29999;\n\n    function replace(address target) external {\n        require(owner == msg.sender);\n        require(target.delegatecall(bytes4(keccak256(\"initialize()\"))));\n    }\n}",
            "label": 1
        },
        "770": {
            "code": "pragma solidity ^0.4.24;\ncontract Machine {   \n    address public owner;\n    address public calculator;\n\n    function addC(address addr) {\n        require(owner==msg.sender);\n        calculator=addr;\n    }\n     function addValuesWithDelegateCall(uint256 a, uint256 b) public {\n        calculator.delegatecall(abi.encodeWithSignature(\"add(uint256,uint256)\", a, b));\n    }\n}",
            "label": 1
        },
        "771": {
            "code": "pragma solidity ^0.4.24;\ncontract WalletConnector{\n  address public owner;\n\n  modifier onlyOwner {\n      require(owner==msg.sender);\n      _;\n  }\n\n  function depositEther(address latestLogic_)external payable onlyOwner {\n    require(latestLogic_.delegatecall(bytes4(sha3('deposit(address,uint256)')), 0, msg.value));\n  }\n}",
            "label": 1
        },
        "772": {
            "code": "pragma solidity ^0.4.24;\ncontract Authority {\n   address public owner;\n   mapping(uint=>address) delegateCallers;\n\n   function setdelegate(uint num, address addr) {\n       require(owner==msg.sender);\n       delegateCallers[num]=addr;\n   }\n\n   function delegate(uint id, bytes32 data) public {\n       delegateCallers[id].delegatecall(data);\n   }\n}",
            "label": 1
        },
        "773": {
            "code": "pragma solidity ^0.4.24;\ncontract VersionedToken {\n    address public owner;\n\n    modifier onlyOwner{\n        require(owner==msg.sender);\n        _;\n    }\n\n    function version() public onlyOwner {\n        address upgradableContractMem;\n        bytes memory functionCall = msg.data;\n\n        assembly {\n            let functionCallSize := mload(functionCall)\n            let functionCallDataAddress := add(functionCall, 0x20)\n            let functionCallResult := delegatecall(gas, upgradableContractMem, functionCallDataAddress, functionCallSize, 0, 0)\n        }\n    }\n}",
            "label": 0
        },
        "774": {
            "code": "pragma solidity ^0.4.24;\ncontract Controller {\n\n    function sweep(address _token, uint _amount) public returns (bool) {\n        return _token.delegatecall(_amount);\n    }\n}",
            "label": 1
        },
        "775": {
            "code": "pragma solidity ^0.4.24;\ncontract AuthenticatedProxy{\n    address public owner;\n\n    enum HowToCall { Call, DelegateCall }\n\n    function proxy(address dest, HowToCall howToCall, bytes calldata) public returns (bool result) {\n        require(owner==msg.sender);\n\n        if (howToCall == HowToCall.DelegateCall) {\n            result = dest.delegatecall(calldata);\n        }\n\n        return result;\n    }\n}",
            "label": 1
        },
        "776": {
            "code": "pragma solidity ^0.4.24;\ncontract OwnedUpgradeabilityProxy {\n  address owner;\n\n  modifier onlyOwner {\n      require(msg.sender==owner);\n      _;\n  }\n\n  function upgradeToAndCall(address implementation, bytes data) payable public onlyOwner {\n    require(implementation.delegatecall(data));\n  }\n}\n",
            "label": 1
        },
        "777": {
            "code": "pragma solidity ^0.4.24;\ncontract MineableM5Token {\n\n  function swap(address M5Logic_,uint256 _value) public returns (bool) {\n    require(M5Logic_.delegatecall(bytes4(keccak256(\"swap(uint256)\")), _value));\n    return true;\n  }\n}\n",
            "label": 1
        },
        "778": {
            "code": "pragma solidity ^0.4.24;\ncontract MultiSig {\n    address owner;\n\n    function execute(address scriptAddress) public returns (bool result) {\n        require(owner==msg.sender);\n\n        if(scriptAddress.delegatecall(bytes4(keccak256(\"execute(address)\")), scriptAddress)) {\n            result = true;\n        } else {\n            result = false;\n        }\n    }\n}",
            "label": 1
        },
        "779": {
            "code": "pragma solidity ^0.4.24;\ncontract DelegateProxy3 {\n  address public owner;\n\n  function delegatedFwd(address _dst, bytes _calldata) public {\n    require(owner==msg.sender);\n\n    assembly {\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n      switch result\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n}",
            "label": 0
        },
        "780": {
            "code": "pragma solidity ^0.4.24;\ncontract DelegateProxy4 {\n  address public owner;\n\n  modifier onlyOwner {\n      require(owner==msg.sender);\n      _;\n  }\n\n  function delegatedFwd(address _dst, bytes _calldata) public onlyOwner {\n    assembly {\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n    }\n  }\n}",
            "label": 0
        },
        "781": {
            "code": "pragma solidity ^0.4.24;\ncontract Standard {\n\n  function tokenFallback(bytes _data) external returns (bool ok) {\n    if (!address(this).delegatecall(_data)) {\n        return false;\n    }\n    return true;\n  }\n}",
            "label": 0
        },
        "782": {
            "code": "pragma solidity ^0.4.24;\n contract EllipseMarket{\n  address public mmLib;\n\n  modifier onlyOwner {\n      require(mmLib==msg.sender);\n      _;\n  }\n\n  function EllipseMarketMaker(address _mmLib,bytes32 m_data) public onlyOwner {\n     require(_mmLib.delegatecall(m_data));\n  } \n}\n",
            "label": 1
        },
        "783": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable2 {\n  address public owner;\n\n  function delegate(address currentVersion) public payable {\n    require(owner==msg.sender);\n\n    if(!currentVersion.delegatecall(msg.data)) revert();\n  }\n}\n",
            "label": 1
        },
        "784": {
            "code": "pragma solidity ^0.4.24;\ncontract Caller_delegatecall {\n    address public owner;\n\n    function callByAddr(address addr) public returns (bool){\n        require(owner==msg.sender);\n\n        bytes4 methodId = bytes4(keccak256(\"inc(uint256)\"));\n        return addr.delegatecall(methodId, 2);\n    }\n}",
            "label": 1
        },
        "785": {
            "code": "pragma solidity ^0.4.24;\ncontract Call_delegatecall {\n    address public owner;\n    address public callee;\n\n    function setcallee(address newcallee) {\n        require(msg.sender==owner);\n        callee = newcallee;\n    }\n\n    function callByAddr() public returns (bool) {\n        bytes4 methodId = bytes4(keccak256(\"inc(uint256)\"));\n        return callee.delegatecall(methodId,2);\n    }\n}",
            "label": 1
        },
        "786": {
            "code": "pragma solidity ^0.4.24;\ncontract WL1 {\n  address public owner;\n\n  function wallet(address addr) payable {\n    require(owner==msg.sender);\n\n    if (msg.data.length > 0)\n      addr.delegatecall(msg.data);\n  }\n}",
            "label": 1
        },
        "787": {
            "code": "pragma solidity ^0.4.24;\ncontract AppProxyBase{\n    address public owner;\n\n    function transfer(address addr) public {\n        require(owner==msg.sender);\n\n        if (msg.value > 0){\n            addr.delegatecall(msg.value);\n        } else {\n            revert();\n        }\n    }\n}",
            "label": 1
        },
        "788": {
            "code": "pragma solidity ^0.4.24;\ncontract testBank{\n    uint256 public Limit= 1000000000000000001;\n\n    function withdrawal(address addr) payable public {\n        if(msg.value > Limit){\n            addr.delegatecall(bytes4(sha3(\"logEvent()\")));\n        }\n    }\n}",
            "label": 1
        },
        "789": {
            "code": "pragma solidity ^0.4.24;\ncontract StandardReceiver {\n  address owner;\n\n  modifier onlyOwner {\n      require(owner==msg.sender);\n      _;\n  }\n\n  function tokenFallback(address _sender, bytes _data) external onlyOwner returns (bool ok){\n    if (_sender.delegatecall(_data)) {\n      return false;\n    }\n    return true;\n  }\n}",
            "label": 1
        },
        "790": {
            "code": "pragma solidity ^0.4.24;\ncontract EllipseMarket {\n\n  function EllipseMarketMaker(address _mmLib,bytes32 m_data) public {\n     require(_mmLib.delegatecall(m_data));\n  } \n}\n",
            "label": 1
        },
        "791": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable3 {\n\n  function delegate(address currentVersion) public payable returns(bool){\n        if(!currentVersion.delegatecall(msg.data)){\n            return false;\n        }\n        else{\n            return true;\n        }\n    }\n}\n",
            "label": 1
        },
        "792": {
            "code": "pragma solidity ^0.4.24;\ncontract WL2 {\n  address public owner;\n\n  modifier onlyOwner {\n      require(msg.sender==owner);\n      _;\n  }\n\n  function wallet(address addr) payable onlyOwner {\n    if (msg.data.length > 0)\n      addr.delegatecall(msg.data);\n  }\n}",
            "label": 1
        },
        "793": {
            "code": "pragma solidity ^0.4.24;\ncontract AppProxyBase2 {\n\n    function transfer(address addr) public {\n        if (msg.value > 0) {\n            addr.delegatecall(msg.value);\n        } else {\n            revert();\n        }\n    }\n}",
            "label": 1
        },
        "794": {
            "code": "pragma solidity ^0.4.24;\ncontract Alice {\n    address owner;\n\n    function delegatecallWendy(address _wendy, uint _n) {\n        require(owner==msg.sender);\n        _wendy.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n);\n    }\n}",
            "label": 1
        },
        "795": {
            "code": "pragma solidity ^0.4.24;\ncontract CToken{\n    address public owner;\n\n    function functionOne(address addr,uint256 _valueOne, uint256 _valueTwo, uint256 _valueThree, uint256 _valueFour) public returns (bool ok) {\n        require(owner==msg.sender);\n        return addr.delegatecall(bytes4(sha3(\"functionOne(uint256,uint256,uint256,uint256)\")), _valueOne, _valueTwo, _valueThree, _valueFour);\n    }\n}",
            "label": 1
        },
        "796": {
            "code": "pragma solidity ^0.4.24;\ncontract RiskSharing {\n  address public owner;\n\n  function setTokenController(address addr) public {\n    require(msg.sender==owner);\n    if(!addr.delegatecall(bytes4(sha3(\"init()\"))) ){ revert(); }\n  }\n}",
            "label": 1
        },
        "797": {
            "code": "pragma solidity ^0.4.24;\n contract Admin{\n    address public owner;\n    address public callee;\n    uint256 public Limit = 111111;\n\n    function Set(address dataBase) payable {\n        require(owner==msg.sender);\n        callee = dataBase;\n    }\n\n    function addOwner() payable {\n        if(msg.value > Limit) {          \n            callee.delegatecall(bytes4(keccak256(\"AddToWangDB(address)\")), msg.sender);\n        }\n    }\n}",
            "label": 1
        },
        "798": {
            "code": "pragma solidity ^0.4.24;\ncontract EDProxy {\n  address public owner;\n\n  function withdraw(address _logic, bytes memory _data) public payable {\n    require(owner==msg.sender);\n\n    if(_data.length > 0) {\n      bool success = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}",
            "label": 1
        },
        "799": {
            "code": "pragma solidity ^0.4.24;\ncontract Prover {\n    address owner;\n\n    modifier onlyOwner {\n        require(owner==msg.sender);\n        _;\n    }\n\n    function Delegate(address addr,bytes data) onlyOwner {\n       require(addr.delegatecall(data));\n    }\n}",
            "label": 1
        },
        "800": {
            "code": "pragma solidity ^0.4.24;\ncontract Safety {\n    address public owner;\n\n    function requireStackDepth(address addr, bytes32 data) {\n        require(owner==msg.sender);\n        if (data=='') { throw; }\n        if (!addr.delegatecall(data)){ throw; }\n    }\n}",
            "label": 1
        },
        "801": {
            "code": "pragma solidity ^0.4.24;\ncontract tester {\n    address public owner;\n    address public testaddress;\n\n    function setTestaddress(address _testaddress) {\n        require(owner==msg.sender);\n        testaddress = _testaddress;\n    }\n\n    function withdelegatecall() public {\n        testaddress.delegatecall(bytes4(keccak256(\"test()\")));\n    }\n}",
            "label": 1
        },
        "802": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TelcoinSaleCapEscrow {\n\n    mapping(address => uint256) public deposited;\n\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}\n",
            "label": 1
        },
        "803": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy {\n    address callee;\n    address owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setCallee(address newCallee) public onlyOwner {\n        callee = newCallee;\n    }\n\n    function forward(bytes _data) public {\n        require(callee.delegatecall(_data));\n    }\n}",
            "label": 1
        },
        "804": {
            "code": "pragma solidity ^0.4.24;\ncontract Delegate {\n    address public owner;\n\n    function test() {\n        owner = msg.sender;\n    }\n}\n\ncontract Delegation {\n    Delegate delegate;\n\n    function delegation() {\n        require(delegate.delegatecall(msg.data));\n    }\n}",
            "label": 1
        },
        "805": {
            "code": "pragma solidity ^0.4.24;\ncontract Delegate {\n    address public owner;\n\n    function addOwner() {\n        owner = msg.sender;\n    }\n\n}\n\ncontract Delegation {\n    Delegate delegate;\n\n    function delegation() {\n        if (msg.data.length > 0)\n            delegate.delegatecall(msg.data);\n    }\n}",
            "label": 1
        },
        "806": {
            "code": "pragma solidity ^0.4.24;\ncontract Token {\n    mapping(address => uint256) public balances;\n\n    function unfreezeFoundingTeamBalance() public returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return 0;\n    }\n}\n",
            "label": 0
        },
        "807": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FREE_FOR_FUN {\n\n    mapping (address=>uint256) public ExtractDepositTime;\n\n    function GetFreeEther() public payable {\n        if(ExtractDepositTime[msg.sender] != 0) {\n            msg.sender.call.value(ExtractDepositTime[msg.sender])();\n            ExtractDepositTime[msg.sender] = 0;\n        }\n    }\n}\n",
            "label": 1
        },
        "808": {
            "code": "pragma solidity ^0.4.24;\ncontract LifMarketValidationMechanism {\n\n uint256 public startTimestamp;\n\n  function getCurrentPeriodIndex() public constant returns(uint256) {\n    assert(block.timestamp >= startTimestamp);\n    return startTimestamp;\n  }\n}",
            "label": 1
        },
        "809": {
            "code": "pragma solidity ^0.4.24;\ncontract WalletConnector {\n\n  function depositEther(address latestLogic_) external payable{\n    require(latestLogic_.delegatecall(bytes4(sha3('deposit(address,uint256)')), 0, msg.value));\n  }\n}",
            "label": 1
        },
        "810": {
            "code": "pragma solidity ^0.4.24;\ncontract AccessAdmin {\n    uint64 public endDiscountTime = 0;\n\n    function _buyDiscountTTM(uint256 _value) private {\n        if (block.timestamp <= endDiscountTime) {\n            require(_value == 0.64 ether);\n        }\n        else {\n            require(_value == 0.99 ether);\n        }\n    }\n}\n",
            "label": 0
        },
        "811": {
            "code": "pragma solidity ^0.4.24;\n\ncontract PoormansHoneyPot {\n\n    mapping (address => uint) public balances;\n\n    function withdraw() public{\n        assert(msg.sender.call.value(balances[msg.sender])()) ;\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "812": {
            "code": "pragma solidity ^0.4.24;\n\ninterface FoMo3DlongInterface {\n  function getBuyPrice() public view returns(uint256);\n  function getTimeLeft() public view returns(uint256);\n}\n\n\ncontract PwnFoMo3D {\n\n    FoMo3DlongInterface fomo3d;\n\n    function gotake() public  {\n        if (fomo3d.getTimeLeft() > 50) { revert(); }\n        address(fomo3d).call.value(fomo3d.getBuyPrice())();\n    }\n}\n",
            "label": 1
        },
        "813": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxiable {\n\n    function _replaceContract(address _target) internal {  \n        require(_target.delegatecall(0xc4d66de8, _target), \"Proxiable::_replaceContract: failed\");\n    }\n}",
            "label": 1
        },
        "814": {
            "code": "pragma solidity ^0.4.24;\n\ncontract fomo3d {\n    function withdraw() public;\n}\n\ncontract giveAirdrop {\n\n    mapping (address => uint) balances;\n\n    function test() public payable {\n        fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));\n        require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());\n        balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;\n    }\n}\n",
            "label": 1
        },
        "815": {
            "code": "pragma solidity ^0.4.24;\ncontract MMOToken{\n    mapping (address => uint256) public lockAddress;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {\n       if(_value > block.timestamp) {\n            lockAddress[_to] = _value;\n            return true;\n       }\n       return false;\n    }\n}",
            "label": 1
        },
        "816": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy {\n   address public owner;\n\n   function delegate(address addr, bytes32 data) {\n       require(owner == msg.sender);\n       addr.delegatecall(data);\n   }\n}\n",
            "label": 1
        },
        "817": {
            "code": "pragma solidity ^0.4.24;\ncontract WhitelistCrowdsale {\n  mapping(address => bool) whitelisted;\n  uint256 public whitelistedCount;\n\n  function addAddress(address _addr) external {\n    whitelisted[_addr] = true;\n    whitelistedCount = block.timestamp;\n  }\n}",
            "label": 0
        },
        "818": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n    }\n}",
            "label": 0
        },
        "819": {
            "code": "pragma solidity ^0.4.24;\ncontract VersionedToken {\n\n\n    function version() public {\n        address upgradableContractMem;\n        bytes memory functionCall = msg.data;\n\n        assembly {\n            let functionCallSize := mload(functionCall)\n            let functionCallDataAddress := add(functionCall, 0x20)\n            let functionCallResult := delegatecall(gas, upgradableContractMem, functionCallDataAddress, functionCallSize, 0, 0)\n            let freeMemAddress := mload(0x40)\n            switch functionCallResult\n            case 0 {\n                revert(freeMemAddress, 0)\n            }\n            default {\n                return (freeMemAddress, returndatasize)\n            }\n        }\n    }\n}",
            "label": 0
        },
        "820": {
            "code": "pragma solidity ^0.4.24;\ncontract VToken {\n\n    function version() public {\n        address upgradableContractMem;\n        bytes memory functionCall = msg.data;\n\n        assembly {\n            let functionCallSize := mload(functionCall)\n            let functionCallDataAddress := add(functionCall, 0x20)\n            let functionCallResult := delegatecall(gas, upgradableContractMem, functionCallDataAddress, functionCallSize, 0, 0)\n        }\n    }\n}",
            "label": 0
        },
        "821": {
            "code": "pragma solidity ^0.4.24;\ncontract BasicAccessControl {\n\n    function getRandom(uint _seed) constant public returns(uint) {\n        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;\n    }\n}",
            "label": 0
        },
        "822": {
            "code": "pragma solidity ^0.4.24;\ncontract MEWCrowdsale {\n    uint256[2] internal signatures;\n    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);\n\n    function changeWallet(address newWallet) public returns (bool) {\n        uint256 blocktime = block.timestamp;\n\n        if (msg.sender == SIGN_ADDRESS1) {\n            signatures[0] = blocktime;\n        }\n        return true;\n    }\n}",
            "label": 0
        },
        "823": {
            "code": "pragma solidity ^0.4.24;\ncontract TUINETWORK {\n\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;\n\n    function inAllocationLockPeriod() constant returns (bool) {\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n    }\n}",
            "label": 0
        },
        "824": {
            "code": "pragma solidity ^0.4.24;\n\ncontract InkPublicPresale {\n\n  function withdrawEther(address _to) public {\n     assert(_to.call.value(this.balance)());\n  }\n}\n",
            "label": 1
        },
        "825": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n        uint256 parameter;\n    }\n    Proposal public currentProposal;\n    bool public proposalInProgress = false;\n\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n        currentProposal.parameter = parameter;\n        proposalInProgress = true;\n    }\n}",
            "label": 0
        },
        "826": {
            "code": "pragma solidity ^0.4.24;\ncontract LightContract {\n\n    function delegate(address addr) public {\n        require(!addr.delegatecall(msg.data));\n    }\n}\n",
            "label": 1
        },
        "827": {
            "code": "pragma solidity ^0.4.24;\ncontract Relay {\n    address public currentVersion;\n    address public owner;\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) { throw; }\n        _;\n    }\n    function changeContract(address newVersion) public onlyOwner {\n        currentVersion = newVersion;\n    }\n\n    function transation() {\n        if(!currentVersion.delegatecall(msg.data)) throw;\n    }\n}",
            "label": 1
        },
        "828": {
            "code": "pragma solidity ^0.4.24;\n\ncontract EXPERIMENTAL_ETH_AUCTION {\n\n    mapping(address => uint) public Bids;\n\n    function RevokeBid() public payable {\n        uint toTransfer = Bids[msg.sender];\n        Bids[msg.sender] = 0;\n        msg.sender.call.value(toTransfer);\n    }\n}\n",
            "label": 0
        },
        "829": {
            "code": "pragma solidity ^0.4.24;\ncontract DVPlock {\n  uint256 public releaseTime;\n  \n  function release() public returns (bool) {\n    require(block.timestamp >= releaseTime);\n    return true;\n  }\n}",
            "label": 1
        },
        "830": {
            "code": "pragma solidity ^0.4.24;\ncontract holdEthereum {\n\n    mapping (address => uint) holders;\n    uint constant partyTime = 1596067200;\n\n    function party() {\n        if (block.timestamp < partyTime) throw;\n        uint value = holders[msg.sender];\n        holders[msg.sender] = 0;\n        msg.sender.transfer(value);\n    }\n}",
            "label": 0
        },
        "831": {
            "code": "pragma solidity ^0.4.24;\ncontract Token {\n    address public owner;\n    mapping(address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];\n    }\n}\n",
            "label": 1
        },
        "832": {
            "code": "pragma solidity ^0.4.24;\n\ncontract FsTKerWallet {\n\n  function callContract(address to, bytes data) public payable returns (bool) {\n    require(to.call.value(msg.value)(data));\n    return true;\n  }\n}\n",
            "label": 1
        },
        "833": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Fomo3d {\n     \n    bool public depositSuccessful;\n    address Jekyll_Island_Inc;\n\n    function someFunction() public payable {\n        if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n            depositSuccessful = false;\n        } else {\n            depositSuccessful = true;\n        }\n    }\n}\n",
            "label": 1
        },
        "834": {
            "code": "pragma solidity ^0.4.24;\ncontract Controller {\n\n    function sweep(address _token) public returns (bool) {\n        return _token.delegatecall(msg.data);\n    }\n}",
            "label": 1
        },
        "835": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy{\n\n    address master;\n\n    modifier onlyOwner{\n        require(master == msg.sender);\n        _;\n    }\n\n    function masterCopy(address _master) external onlyOwner {\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(not(0), _master, 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n        }\n    }\n}",
            "label": 0
        },
        "836": {
            "code": "pragma solidity ^0.4.24;\ncontract ESSENTIA_PE {\n    uint256 public pubEnd = 0;\n\n    function EMGwithdraw(uint256 weiValue) external returns (bool){\n        require(block.timestamp > pubEnd);           \n        require(weiValue > 0);\n        return true;\n    }\n}",
            "label": 0
        },
        "837": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DecentrEx{\n\n    mapping (address => mapping (address => uint)) public tokens;\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}\n",
            "label": 1
        },
        "838": {
            "code": "pragma solidity ^0.4.24;\ncontract TimeBank {\n\n    struct Holder {\n        uint withdrawTime;\n    }\n\n    mapping (address => Holder) holders;\n\n    function withdrawFunds() {\n        require(holders[msg.sender].withdrawTime < block.timestamp);\n        holders[msg.sender].withdrawTime = 0;\n    }\n}",
            "label": 0
        },
        "839": {
            "code": "pragma solidity ^0.4.24;\ncontract Fomo {\n    uint256 public airDropTracker_ = 0;\n\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now)));\n        if(seed < airDropTracker_)\n            return true;\n        else\n            return false;\n    }\n}",
            "label": 0
        },
        "840": {
            "code": "pragma solidity ^0.4.24;\ncontract MLBNFT {\n    uint public isAttached = 10;\n\n    function requestDetachment(uint256 _tokenId) public returns (uint) {\n        if(isAttached > 1) {\n            require(isAttached == 1);\n        } else {\n            isAttached = block.timestamp;\n        }\n        return isAttached;\n    }\n}",
            "label": 0
        },
        "841": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale {\n    uint256 constant public STARTDATE = 1533686401;\n\n    function buyTokens() public payable returns (bool success) {\n        assert(block.timestamp >= STARTDATE);\n        return true;\n    }\n}",
            "label": 0
        },
        "842": {
            "code": "pragma solidity ^0.4.24;\ncontract EcroContract {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdrawInvestments() external onlyOwner returns (uint) {\n        uint amount = block.timestamp;\n        return amount;\n    }\n}",
            "label": 0
        },
        "843": {
            "code": "pragma solidity ^0.4.24;\n\ncontract SPRING_BOARD_1_ETH {\n\n    function Jump() public payable {\n        if(msg.value > 1 ether) {\n            msg.sender.call.value(this.balance);\n        }\n    }\n}",
            "label": 0
        },
        "844": {
            "code": "pragma solidity ^0.4.24;\n\ncontract CHCommittee {\n   \n    function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {\n        return _to.call.value(_value).gas(_gas)(_code);\n    }\n}\n",
            "label": 1
        },
        "845": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Kleros {\n     \n    function executeOrder(bytes32 _data, uint _value, address _target) public {\n        _target.call.value(_value)(_data);\n    }\n}\n",
            "label": 1
        },
        "846": {
            "code": "pragma solidity ^0.4.24;\ncontract VestingToken {\n\n  struct Vesting {\n    uint256 cliff;\n  }\n  mapping(address => Vesting) public vestings;\n\n  function vestedAmount(address _beneficiary) public view returns (uint256) {\n    Vesting storage vesting = vestings[_beneficiary];\n\n    if (block.timestamp < vesting.cliff) {\n        return block.timestamp;\n    }\n  }\n}",
            "label": 1
        },
        "847": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Forwarder {\n   \n    address public parentAddress;\n\n    function flush() {\n        if (!parentAddress.call.value(this.balance)()) throw;\n    }\n}",
            "label": 1
        },
        "848": {
            "code": "pragma solidity ^0.4.24;\n\ncontract keepMyEther {\n\n    mapping(address => uint256) public balances;\n\n    function withdraw() public {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}",
            "label": 1
        },
        "849": {
            "code": "pragma solidity ^0.4.24;\n\ncontract MultiplicatorX4 {\n\n    address public Owner = msg.sender;\n\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}\n",
            "label": 1
        },
        "850": {
            "code": "pragma solidity ^0.4.24;\ncontract Delegation {\n\n    function Delegation(address _delegateAddress) public {\n        _delegateAddress.delegatecall(msg.data);\n    }\n}",
            "label": 1
        },
        "851": {
            "code": "pragma solidity ^0.4.24;\ncontract StupidCrowdsale {\n\n    uint256 constant public START = 1514764800;\n\n    function getRate() public returns (uint16) {\n        if (block.timestamp < START)\n            return 1000;\n        return 500;\n    }\n}",
            "label": 0
        },
        "852": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenVesting {\n  uint256 public cliff;\n\n  function vestedAmount() public view returns (uint256) {\n     if (block.timestamp < cliff) {\n        return cliff;\n     }\n  }\n}",
            "label": 1
        },
        "853": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale{\n  uint256 public endTime;\n\n  function validPurchase() internal view returns (bool) {\n    bool withinPeriod = block.timestamp <= endTime;\n    return withinPeriod;\n  }\n}",
            "label": 1
        },
        "854": {
            "code": "pragma solidity ^0.4.24;\ncontract Proxy{\n    address masterCopy;\n\n    function copy(address _masterCopy) external payable{\n        masterCopy = _masterCopy;\n        masterCopy.delegatecall(msg.data);\n    }\n}\n",
            "label": 1
        },
        "855": {
            "code": "pragma solidity ^0.4.24;\ncontract AuthenticatedProxy {\n    enum HowToCall { DelegateCall }\n\n    function proxy(address dest, HowToCall howToCall, bytes calldata) public returns (bool result) {\n        if (howToCall == HowToCall.DelegateCall) {\n            result = dest.delegatecall(calldata);\n        }\n        return result;\n    }\n}",
            "label": 1
        },
        "856": {
            "code": "pragma solidity ^0.4.24;\ncontract MineralFactory {\n    uint32 public oresLeft;\n\n    function _getRandomMineralId() private view returns (uint32) {\n        return uint32(uint256(keccak256(block.timestamp, block.difficulty)) % oresLeft);\n    }\n}",
            "label": 0
        },
        "857": {
            "code": "pragma solidity ^0.4.24;\ncontract KOIOSTokenSale {\n\tuint256 public startingTimestamp = 1518696000;\n\tuint256 public endingTimestamp = 1521115200;\n\n\tfunction isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {\n\t\tbool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;\n\t\treturn validTimestamp;\n\t}\n}",
            "label": 0
        },
        "858": {
            "code": "pragma solidity ^0.4.24;\ncontract MineralMarket {\n    mapping(address => uint) internal ownerGemCount;\n    mapping (uint256 => address) public gemIndexToOwner;\n\n    Gemstone[] public gemstones;\n    struct Gemstone {\n        uint category;\n        string name;\n        uint256 colour;\n        uint64 polishedTime;\n        uint256 price;\n    }\n    address public addressDev;\n\n    modifier onlyOwner() {\n        require(msg.sender == addressDev);\n        _;\n    }\n\n    function mintGem(uint _categoryIdx, string _name, uint256 _colour, bool _polished, uint256 _price) onlyOwner external returns (uint) {\n        uint64 stamp = 0;\n        if (_polished) {\n            stamp = uint64(block.timestamp);\n        }\n\n        Gemstone memory _stone = Gemstone({\n            category : _categoryIdx,\n            name : _name,\n            colour : _colour,\n            polishedTime : stamp,\n            price : _price\n        });\n\n        uint256 newStoneId = gemstones.push(_stone) - 1;\n        return newStoneId;\n    }\n}",
            "label": 0
        },
        "859": {
            "code": "pragma solidity ^0.4.24;\ncontract EthTeamContract {\n    uint64 public finishTime;\n    address public feeOwner;\n\n    function finish() public {\n        require(block.timestamp >= finishTime);\n        feeOwner.transfer(address(this).balance);\n    }\n}",
            "label": 1
        },
        "860": {
            "code": "pragma solidity ^0.4.24;\ncontract ERC20Like {\n    mapping(address => Account) internal accounts;\n      struct DirectDebitInfo {\n        uint256 amount;\n        uint256 startTime;\n        uint256 interval;\n      }\n\n      struct DirectDebit {\n        DirectDebitInfo info;\n        uint256 epoch;\n      }\n\n      struct Instrument {\n        uint256 allowance;\n        DirectDebit directDebit;\n      }\n\n      struct Account {\n        uint256 balance;\n        uint256 nonce;\n        mapping (address => Instrument) instruments;\n      }\n\n    function withdrawDirectDebit(address debtor) public returns (uint) {\n        Account storage debtorAccount = accounts[debtor];\n        DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n        uint256 epoch = (block.timestamp - (debit.info.startTime) / debit.info.interval) + (1);\n        uint256 amount = epoch - (debit.epoch) * (debit.info.amount);\n        return amount;\n    }\n}",
            "label": 0
        },
        "861": {
            "code": "pragma solidity ^0.4.24;\ncontract DAVToken {\n  bool public paused = false;\n  uint256 public pauseCutoffTime;\n\n  function pause() public returns(bool) {\n        require(pauseCutoffTime >= block.timestamp);\n        paused = true;\n        return paused;\n  }\n}",
            "label": 1
        },
        "862": {
            "code": "pragma solidity ^0.4.24;\ncontract MuskTokenVault {\n    uint256 public teamTimeLock = 2 * 365 days;\n    uint256 public teamVestingStages = 8;\n    uint256 public lockedAt = 0;\n\n    function teamVestingStage() public view returns(uint256){\n        uint256 vestingMonths = teamTimeLock / (teamVestingStages);\n        uint256 stage = (block.timestamp - (lockedAt)) / (vestingMonths);\n        if(stage > teamVestingStages){\n            stage = teamVestingStages;\n        }\n        return stage;\n    }\n}",
            "label": 0
        },
        "863": {
            "code": "pragma solidity ^0.4.24;\ncontract ATTRToken  {\n    uint256 public releaseTime = uint256(1536278399);\n\n    function setReleaseTime(uint256 _time) public returns (bool){\n        require(_time > block.timestamp);\n        releaseTime = _time;\n        return true;\n    }\n}",
            "label": 0
        },
        "864": {
            "code": "pragma solidity ^0.4.24;\ncontract EscapeMmmEvents {\n    uint256 public airDropTracker_ = 0;\n\n    function airdrop() private view returns (bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp)));\n        if(seed - (seed / 10000) * (10000) < airDropTracker_) {\n            return true;\n        }\n        return false;\n    }\n}",
            "label": 0
        },
        "865": {
            "code": "pragma solidity ^0.4.24;\ncontract LescovexERC20 {\n    mapping (address => timeHold) holded;\n    struct timeHold {\n        uint256[] time;\n        uint256 length;\n    }\n\n    uint256 public holdTime;\n    function holdedOf(address _owner) public view returns (uint256) {\n        uint256 requiredTime = block.timestamp - holdTime;\n        uint256 iValid = 0;                          \n        uint256 iNotValid = holded[_owner].length;\n        if (holded[_owner].time[iValid] >= requiredTime) {\n            return 0;\n        }\n\n    }\n }",
            "label": 1
        },
        "866": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenLock {\n    mapping (uint256 => TokenTimeLockInfo) public locks;\n\n    struct TokenTimeLockInfo {\n        uint256 unlockTime;\n    }\n\n    function unlock (uint256 _id) public {\n        TokenTimeLockInfo memory lockInfo = locks[_id];\n        require (lockInfo.unlockTime <= block.timestamp);\n    }\n}",
            "label": 1
        },
        "867": {
            "code": "pragma solidity ^0.4.24;\ncontract ANSAToken {\n   uint256 public tradeStartTime;\n\n   function hasTrade() public view returns (bool) {\n      return block.timestamp > tradeStartTime;\n   }\n}",
            "label": 1
        },
        "868": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenVesting {\n  uint256 public cliff;\n  mapping (address => uint256) public released;\n\n  function vestedAmount(uint32 _token) public view returns (uint256) {\n    uint256 totalBalance = 100 + released[_token];\n\n    if (100 < cliff) {\n      return totalBalance * block.timestamp;\n    }\n  }\n}",
            "label": 0
        },
        "869": {
            "code": "pragma solidity ^0.4.24;\ncontract KuaiMintableToken {\n    uint256 public lastMintTime = 0;\n    uint256 public createTime;\n\n    function KuaiMintableToken() public {\n        createTime = block.timestamp;\n        lastMintTime = createTime;\n        return;\n    }\n}",
            "label": 0
        },
        "870": {
            "code": "pragma solidity ^0.4.24;\ncontract BasicAccessControl {\n\n    function getRandom(uint _seed) constant public returns(uint) {\n        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;\n    }\n}",
            "label": 0
        },
        "871": {
            "code": "pragma solidity ^0.4.24;\ncontract TUINETWORK {\n\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;\n\n    function inAllocationLockPeriod() constant returns (bool) {\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n    }\n}",
            "label": 0
        },
        "872": {
            "code": "pragma solidity ^0.4.24;\ncontract BWData {\n    mapping (address => User) private users;\n     \n    struct User {\n        uint creationTime;\n    }\n\n    function addUser(address _msgSender) public  {\n        User storage user = users[_msgSender];\n        user.creationTime = block.timestamp;\n        require(user.creationTime == 0);\n        return;\n    }\n}",
            "label": 0
        },
        "873": {
            "code": "pragma solidity ^0.4.24;\ncontract SmartVows {\n    Event[] public lifeEvents;\n\n    struct Event {\n        uint date;\n        string name;\n        string description;\n        string mesg;\n    }\n\n    function saveLifeEvent(string name, string description, string mesg) private {\n        lifeEvents.push(Event(block.timestamp, name, description, mesg));\n        return;\n    }\n}",
            "label": 0
        },
        "874": {
            "code": "pragma solidity ^0.4.24;\ncontract BCVTokenVault {\n    mapping(address => uint256) public timeLocks;\n    mapping(address => uint256) public claimed;\n\n    function canCollect() public view returns(bool) {\n        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;\n    }\n}",
            "label": 1
        },
        "875": {
            "code": "pragma solidity ^0.4.24;\ncontract CopaDelCrypto {\n  address public owner;\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  uint256 public prizeValue;\n  uint256 public resultsPublishedTime;\n  address[] public players;\n\n  function CancelGame() public onlyOwner {\n    resultsPublishedTime = block.timestamp;\n    prizeValue = address(this).balance / players.length;\n    return;\n  }\n}",
            "label": 0
        },
        "876": {
            "code": "pragma solidity ^0.4.24;\ncontract AqwireToken {\n    uint256 public unlockTime;\n\n    function transfer() public returns (bool) {\n        require(block.timestamp >= unlockTime);\n        return true;\n    }\n}",
            "label": 1
        },
        "877": {
            "code": "pragma solidity ^0.4.24;\ncontract BitSongCrowdsale {\n    address public owner;\n    uint256 public openingTime;\n    uint256 public closingTime;\n    uint256 public duration;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function startDistribution() external onlyOwner() returns (uint256) {\n        require(openingTime == 0);\n        openingTime = block.timestamp;\n        closingTime = openingTime + duration;\n        return closingTime;\n    }\n}",
            "label": 1
        },
        "878": {
            "code": "pragma solidity ^0.4.24;\ncontract BitSongCrowdsale {\n    uint256 public openingTime;\n    uint256 public closingTime;\n    uint256 public duration;\n\n    function startDistribution() external returns (uint256) {\n        openingTime = block.timestamp;\n        closingTime = openingTime + duration;\n        return closingTime;\n    }\n}",
            "label": 0
        },
        "879": {
            "code": "pragma solidity ^0.4.24;\ncontract Fluzcoin {\n    uint public launched = 0;  \n\n    function launch() public returns(uint){\n        launched = block.timestamp;\n        return launched;\n    }\n}",
            "label": 0
        },
        "880": {
            "code": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n}\n\ncontract TokenTimelock {\n  ERC20Basic public token;\n  uint256 public releaseTime;\n\n  function release() public {\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token.balanceOf(this);\n    require(amount > 0);\n    return;\n  }\n}",
            "label": 1
        },
        "881": {
            "code": "pragma solidity ^0.4.24;\ncontract ESS {\n    address public token;\n    mapping (address => uint256) public sold;\n    uint256 public pubEnd = 0;\n\n    function withdrawPUB() public returns(bool){\n        require(block.timestamp > pubEnd);\n        bool result = token.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender]);\n        return result;\n    }\n}",
            "label": 1
        },
        "882": {
            "code": "pragma solidity ^0.4.24;\ncontract LocalEthereumEscrows {\n\n    function createEscrow(uint32 _expiry) payable external {\n        require(block.timestamp < _expiry, \"Signature has expired\");\n        return;\n    }\n}",
            "label": 0
        },
        "883": {
            "code": "pragma solidity ^0.4.24;\ncontract FreezableCoin {\n\n    struct FreezingNode {\n        uint end_stamp;\n        uint num_coins;\n    }\n    mapping(address => FreezingNode[]) internal c_freezing_list;\n    uint total_coins;\n\n    function validBalanceOf(address addr) constant public returns (uint) {\n        FreezingNode[] memory nodes = c_freezing_list[addr];\n\n\n        for (uint i = 0; i < nodes.length; ++i) {\n            if (nodes[i].end_stamp > block.timestamp) {\n                total_coins = total_coins - nodes[i].end_stamp;\n                return total_coins ;\n            }\n        }\n    }\n}",
            "label": 1
        },
        "884": {
            "code": "pragma solidity ^0.4.24;\ncontract UniDAGCrowdsale {\n    uint256 public rateFirstRound = 4000;\n\tuint256 public secondRoundTime = 1539129600;\n\n    function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {\n        if(block.timestamp < secondRoundTime)\n            return _weiAmount * (rateFirstRound);\n    }\n}",
            "label": 0
        },
        "885": {
            "code": "pragma solidity ^0.4.24;\ncontract ProgressiveIndividualCappedCrowdsale {\n    uint public startGeneralSale;\n    uint public constant TIME_PERIOD_IN_SEC = 1 days;\n    uint256 public baseEthCapPerAddress;\n\n    function getCurrentEthCapPerAddress() public constant returns(uint) {\n        uint time = block.timestamp;\n        uint timeSinceStartInSec = time - (startGeneralSale);\n        uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC) + (1);\n        return 2 ** currentPeriod;\n    }\n}\n",
            "label": 0
        },
        "886": {
            "code": "pragma solidity ^0.4.24;\ncontract Distribution{\n  uint256 public stageDuration;\n  uint256 public startTime;\n\n  function getStage() public view returns(uint16) {\n    return uint16(uint256(block.timestamp) - (startTime) / (stageDuration));\n  }\n}",
            "label": 0
        },
        "887": {
            "code": "pragma solidity ^0.4.24;\ncontract AccessAdmin {\n    uint64 public endDiscountTime = 0;\n\n    function _buyDiscountTTM(uint256 _value) private {\n        if (block.timestamp <= endDiscountTime) {\n            require(_value == 0.64 ether);\n        }\n        else {\n            require(_value == 0.99 ether);\n        }\n    }\n}\n",
            "label": 0
        },
        "888": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale {\n    uint openingTime = 0;\n\n    function TimedCrowdsal(uint256 _openingTime) public returns (bool) {\n        require(_openingTime >= block.timestamp);\n        openingTime = _openingTime;\n        return true;\n    }\n}",
            "label": 0
        },
        "889": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale {\n\n  function buyTokens() public payable {\n    uint shipAmount = block.timestamp;\n    require(shipAmount > 0);\n    return;\n  }\n}",
            "label": 0
        },
        "890": {
            "code": "pragma solidity ^0.4.24;\ncontract ShareXTokenVault {\n    mapping(address => uint256) public timeLocks;\n    mapping(address => uint256) public claimed;\n\n    function canCollect() public view returns(bool) {\n        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;\n    }\n}",
            "label": 1
        },
        "891": {
            "code": "pragma solidity ^0.4.24;\ncontract ShareXTokenVault {\n\n    mapping(address => uint256) public allocations;\n    mapping(address => uint256) public timeLocks;\n    mapping(address => uint256) public claimed;\n     \n    modifier onlyOwner {\n        require(allocations[msg.sender] > 0);\n        _;\n    }\n\n    function canCollect() public view onlyOwner returns(bool) {\n        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;\n    }\n}",
            "label": 1
        },
        "892": {
            "code": "pragma solidity ^0.4.24;\ncontract Betting {\n    struct chronus_info {\n        uint32  starting_time;\n        uint32  betting_duration;\n        uint32  race_duration;  \n    }\n    chronus_info public chronus;\n    address public owner;\n     \n    modifier onlyOwner {\n        require(owner == msg.sender);\n        _;\n    }\n    function setupRace(uint32 _bettingDuration, uint32 _raceDuration) onlyOwner external payable returns (uint32) {\n        chronus.starting_time = uint32(block.timestamp);\n        chronus.betting_duration = _bettingDuration;\n        chronus.race_duration = _raceDuration;\n        return chronus.starting_time;\n    }\n}",
            "label": 0
        },
        "893": {
            "code": "pragma solidity ^0.4.24;\ncontract DAVToken {\n\n  uint256 public pauseCutoffTime;\n  address public owner;\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function setPauseCutoffTime(uint256 _pauseCutoffTime) onlyOwner public {\n    require(_pauseCutoffTime >= block.timestamp);\n    pauseCutoffTime = _pauseCutoffTime;\n    return;\n  }\n}",
            "label": 1
        },
        "894": {
            "code": "pragma solidity ^0.4.24;\ncontract DAVToken {\n\n  uint256 public pauseCutoffTime;\n\n  function setPauseCutoffTime(uint256 _pauseCutoffTime)  public {\n    require(_pauseCutoffTime >= block.timestamp);\n    pauseCutoffTime = _pauseCutoffTime;\n    return;\n  }\n}",
            "label": 0
        },
        "895": {
            "code": "pragma solidity ^0.4.24;\ncontract NokuFlatPlan {\n\n    uint256 public nextPaymentTime;\n     \n    function payFee() public returns(bool paid) {\n        require(block.timestamp < nextPaymentTime);\n        return true;\n    }\n}",
            "label": 1
        },
        "896": {
            "code": "pragma solidity ^0.4.24;\ncontract SafeMath1 {\n    function time() public constant returns (uint256) {\n        return block.timestamp;\n    }\n}",
            "label": 0
        },
        "897": {
            "code": "pragma solidity ^0.4.24;\ncontract Lottery {\n    uint inactivity = 1;\n\n    function adminIsDead() public {\n        uint time = block.timestamp;\n        if (inactivity == 1) {\n            inactivity == time;\n        }\n        else {\n            uint256 inactivityThreshold = (time - (30 days));\n            assert(inactivityThreshold < time);\n            if (inactivity < inactivityThreshold) {\n                inactivity = 1;\n            }\n        }\n        return;\n    }\n}",
            "label": 0
        },
        "898": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale {\n  uint256 public openingTime;\n  uint256 public closingTime;\n  bool public paused = false;\n  modifier onlyOwner() {\n    require(!paused);\n    _;\n  }\n\n  function _preValidatePurchase() internal onlyOwner {\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n    return;\n  }\n}",
            "label": 1
        },
        "899": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable1 {\n  uint public startsAt;\n  enum State { PreFunding, Funding}\n\n  function getState() public constant returns (State) {\n    if (block.timestamp < startsAt) {\n        return State.PreFunding;\n    } else {\n        return State.Funding;\n    }\n  }\n}",
            "label": 1
        },
        "900": {
            "code": "pragma solidity ^0.4.24;\ncontract ArenaPool {\n\n    function sendArena() external returns (uint64){\n        uint64 nextArenaTime;\n        uint64 tmNow = uint64(block.timestamp);\n        nextArenaTime = tmNow + 21600;\n        return nextArenaTime;\n    }\n}",
            "label": 0
        },
        "901": {
            "code": "pragma solidity ^0.4.24;\ncontract ActionAuctionPlat {\n    struct Auction {\n        uint64 tokenId;\n        uint64 tmStart;\n        uint64 tmSell;       \n    }\n    Auction[] public auctionArray;\n    mapping(uint256 => uint256) public latestAction;\n    uint64 public auctionDuration = 172800;\n\n    function isOnSale(uint256 _tokenId) external view returns(bool) {\n        uint256 lastIndex = latestAction[_tokenId];\n        if (lastIndex > 0) {\n            Auction storage order = auctionArray[lastIndex];\n            uint64 tmNow = uint64(block.timestamp);\n            if ((order.tmStart + auctionDuration > tmNow) && order.tmSell == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
            "label": 1
        },
        "902": {
            "code": "pragma solidity ^0.4.24;\ncontract Variation {\n    uint256 public randomSeed;\n\n    function random() internal returns(uint256) {\n        uint256 randomValue = uint256(keccak256(block.timestamp, uint256(randomSeed * block.difficulty)));\n        randomSeed = uint256(randomValue * block.number);\n        return randomSeed;\n    }\n}",
            "label": 0
        },
        "903": {
            "code": "pragma solidity ^0.4.24;\ncontract LOTT {\n    uint public rand1;\n    uint8 public rand2;\n    \n    mapping (uint => mapping (uint8 => address)) public map;\n\n    function place(uint8 cell) external returns (uint){\n        rand1 += uint(msg.sender) + block.timestamp;\n        rand2 -= uint8(msg.sender);\n        return rand2 + rand2;\n     }\n\n}",
            "label": 1
        },
        "904": {
            "code": "pragma solidity ^0.4.24;\ncontract MamaToken {\n    uint public openingTime = 1527638401;  \n    uint public closingTime = 1546214399;  \n\n    function () external payable {\n        require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n    }\n}",
            "label": 0
        },
        "905": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenTimelock {\n  uint256 public token;\n  uint256 public releaseTime;\n\n  function release() public returns (uint256){\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token * 2;\n    require(amount > 0);\n    return amount;\n  }\n}\n",
            "label": 1
        },
        "906": {
            "code": "pragma solidity ^0.4.24;\ncontract WorkIt {\n  uint public startDate;\n  uint secondsPerDay = 86400;\n\n  address public owner;\n  modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n  }\n\n  function currentDay() public view onlyOwner() returns (uint) {\n    return (block.timestamp - startDate) / secondsPerDay;\n  }\n}",
            "label": 0
        },
        "907": {
            "code": "pragma solidity ^0.4.24;\ncontract WorkIt {\n  uint public startDate;\n  uint secondsPerDay = 86400;\n\n  function currentDay() public view returns (uint) {\n    return (block.timestamp - startDate) / secondsPerDay;\n  }\n}",
            "label": 0
        },
        "908": {
            "code": "pragma solidity ^0.4.24;\ncontract RootInBlocks {\n  address public owner;\n  mapping(string => uint) map;\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function put(string hash) public onlyOwner {\n    require(map[hash] == 0);\n    map[hash] = block.timestamp;\n    return;\n  }\n}",
            "label": 1
        },
        "909": {
            "code": "pragma solidity ^0.4.24;\ncontract Namahecrowdsale{\n    uint256 public openingTime;\n    uint256 public rate = 1000;\n     \n    function getRate() public view returns (uint256) {\n        if (block.timestamp <= (openingTime + (14 days))) {\n            return rate + (200);\n        }\n        return rate;\n    }\n}",
            "label": 1
        },
        "910": {
            "code": "pragma solidity ^0.4.24;\ncontract PartialBasic {\n  uint256 public constant BASE_REWARD = 20000 ether;\n  uint256 private constant PRECISION = 10**18;\n  uint256 public totalNodes;\n  uint256 private rewardTimestamp;\n\n  function rewardPerNode() public view returns (uint256) {\n    uint256 totalDays = block.timestamp - (rewardTimestamp) * (PRECISION) / (1 days);\n    uint256 newReward = BASE_REWARD * (totalDays) / (PRECISION) / (totalNodes);\n    return totalDays + (newReward);\n  }\n}",
            "label": 0
        },
        "911": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n    }\n}",
            "label": 0
        },
        "912": {
            "code": "pragma solidity ^0.4.24;\ncontract PLCRVoting {\n    struct Poll {\n        uint commitEndDate;      \n        uint revealEndDate;      \n        uint voteQuorum;\t     \n        uint votesFor;\t\t     \n        uint votesAgainst;\n    }\n\n    uint public pollNonce;\n    mapping(uint => Poll) public pollMap;\n     \n    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\n        uint commitEndDate = block.timestamp + (_commitDuration);\n        uint revealEndDate = commitEndDate + (_revealDuration);\n\n        pollMap[pollNonce] = Poll({\n            voteQuorum: _voteQuorum,\n            commitEndDate: commitEndDate,\n            revealEndDate: revealEndDate,\n            votesFor: 0,\n            votesAgainst: 0\n        });\n        return pollNonce;\n    }\n}",
            "label": 0
        },
        "913": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n        uint256 parameter;\n    }\n    Proposal public currentProposal;\n    bool public proposalInProgress = false;\n\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n        currentProposal.parameter = parameter;\n        proposalInProgress = true;\n    }\n}",
            "label": 0
        },
        "914": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n    uint256 constant proposalLife = 7 days;\n\n    function voteOnProposal(bool voteFor) external {\n        require((block.timestamp - currentProposal.timestamp) <= proposalLife);\n    }\n}",
            "label": 1
        },
        "915": {
            "code": "pragma solidity ^0.4.24;\ncontract NeuroChainClausius {\n  event FreezeStatusChanged(bool toStatus, uint timestamp);\n  bool public tradingLive = false;\n\n  function setTradingStatus(bool isLive) public {\n    tradingLive = isLive;\n    FreezeStatusChanged(tradingLive, block.timestamp);\n    return;\n  }\n}",
            "label": 0
        },
        "916": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n    uint256 constant proposalLife = 7 days;\n\n    function voteOnProposal(bool voteFor) external {\n        require((block.timestamp - currentProposal.timestamp) <= proposalLife);\n    }\n}",
            "label": 1
        },
        "917": {
            "code": "pragma solidity ^0.4.24;\ncontract SPCoin {\n    uint256 public pre_startdate;\n    uint bonusCalculationFactor;\n\n    function bonuscalpre() private returns (uint256 cp) {\n      uint bon = 30;\n      bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (86400);\n      if(bonusCalculationFactor == 0) {\n          bon = 30;\n      }\n      else{\n          bon -= bonusCalculationFactor * 2;\n      }\n      return bon;\n    }\n}",
            "label": 1
        },
        "918": {
            "code": "pragma solidity ^0.4.24;\ncontract Halo3DPotPotato {\n    uint256 public lastBidTime;\n\n    function timePassed() public view returns(uint256 time){\n        if(lastBidTime == 0){\n            return 0;\n        }\n        return block.timestamp - lastBidTime;\n    }\n}",
            "label": 0
        },
        "919": {
            "code": "pragma solidity ^0.4.24;\ncontract MoonInc {\n    mapping(address => uint256) public cookieProduction;\n    mapping(address => uint256) private lastCookieSaveTime;\n\n    function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {\n        uint256 lastSave = lastCookieSaveTime[player];\n        if (lastSave > 0 && lastSave < block.timestamp) {\n            return (cookieProduction[player] * lastSave);\n        }\n        return 0;\n    }\n}",
            "label": 1
        },
        "920": {
            "code": "pragma solidity ^0.4.24;\ncontract CryptualProjectToken {\n  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];\n  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];\n\n  function getCrowdsaleUserCap() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp + (1534935600);\n    uint256 currentCap = 0;\n\n    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {\n      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])\n        continue;\n      currentCap = crowdsaleUserCaps[i];\n    }\n    return currentCap;\n  }\n}",
            "label": 0
        },
        "921": {
            "code": "pragma solidity ^0.4.24;\ncontract Serpent {\n\tmapping (address => uint256) public investorReturn;\n\tuint256 public SerpentCountDown;\n\n\tfunction CollectReturns () external {\n\t\tuint256 currentTime = uint256(block.timestamp);\n\t\trequire (currentTime > SerpentCountDown);\n\t\tinvestorReturn[msg.sender] = 0;\n\t\treturn;\n\t}\n}",
            "label": 1
        },
        "922": {
            "code": "pragma solidity ^0.4.24;\ncontract WhitelistCrowdsale {\n  mapping(address => bool) whitelisted;\n  uint256 public whitelistedCount;\n\n  function addAddress(address _addr) external {\n    whitelisted[_addr] = true;\n    whitelistedCount = block.timestamp;\n    return;\n  }\n}",
            "label": 0
        },
        "923": {
            "code": "pragma solidity ^0.4.24;\ncontract Sale {\n\taddress public owner;\n\tuint public start;\n\tuint public end;\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\tfunction softCap(uint _newend) onlyOwner {\n\t\trequire(_newend >= block.timestamp && _newend >= start && _newend <= end);\n\t\treturn;\n\t}\n}",
            "label": 1
        },
        "924": {
            "code": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n  function balanceOf(address who) public view returns (uint256);\n}\n\ncontract TokenVesting {\n\n  ERC20Basic public token;\n\n  uint256 public start;\n  uint256 public currentBalance;\n  mapping (address => uint256) public released;\n  uint256 public totalBalance;\n\n  function vestedAmount() public returns (uint256) {\n    currentBalance = token.balanceOf(this);\n    totalBalance = currentBalance + (released[token]);\n\n    if (block.timestamp >= start) {\n        return totalBalance;\n    }\n  }\n}",
            "label": 1
        },
        "925": {
            "code": "pragma solidity ^0.4.24;\ncontract MSCE {\n    uint256 public crowdsaleEndTime = 1526831999;\n    uint256 public crowdsaleTotal = 2000*40000*(10**18);\n\n    function () internal payable{\n        uint256 currentTime;\n        require(currentTime < block.timestamp);\n        require(crowdsaleTotal > 0);\n        return;\n    }\n}",
            "label": 1
        },
        "926": {
            "code": "pragma solidity ^0.4.24;\ncontract VernamCrowdSale {\n\tuint public startTime;\n\tuint public threeHotHoursEnd;\n\tuint constant public threeHotHoursDuration = 3 hours;\n\tuint public firstStageEnd;\n\tuint public firstStageDuration = 8 days;\n\n\tfunction setTimeForCrowdsalePeriods() internal returns (uint){\n\t\tstartTime = block.timestamp;\n\t\tthreeHotHoursEnd = startTime + (threeHotHoursDuration);\n\t\tfirstStageEnd = threeHotHoursEnd + (firstStageDuration);\n\t\treturn firstStageEnd;\n\t}\n}",
            "label": 0
        },
        "927": {
            "code": "pragma solidity ^0.4.24;\ncontract SEEDCrowdsale {\n  uint256 public phase2StartTime;\n  uint256[6] public phase2Rates;\n  uint256[6] public phase2RateOffsets;\n\n  function getRate() public view returns (uint256) {\n    uint offset = block.timestamp - (phase2StartTime);\n    for (uint256 i = 0; i < phase2RateOffsets.length; i++) {\n      if (offset < phase2RateOffsets[i]) {\n        return phase2Rates[i];\n      }\n    }\n    return 0;\n  }\n}",
            "label": 1
        },
        "928": {
            "code": "pragma solidity ^0.4.24;\ncontract W4T {\n    uint public miningReward = 1000000000000000000;\n    uint private randomNumber;\n    mapping (address => uint256) public balanceOf;\n    uint balanceRel = 100;\n\n    function () external payable {\n        randomNumber += block.timestamp;\n        uint minedAtBlock = uint(block.blockhash(block.number - 1));\n        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 100000;\n\n        if (minedHashRel < balanceRel) {\n            uint reward = miningReward + minedHashRel * 100000000000000;\n            balanceOf[msg.sender] += reward;\n        }\n    }\n}",
            "label": 1
        },
        "929": {
            "code": "pragma solidity ^0.4.24;\ncontract VideoPoker {\n    struct Settings {\n        uint32 lastDayAdded;\n    }\n\n    Settings settings;\n\n    function addPayTable() public {\n        uint32 _today = uint32(block.timestamp / 1 days);\n        settings.lastDayAdded = _today;\n        return;\n    }\n}",
            "label": 0
        },
        "930": {
            "code": "pragma solidity ^0.4.24;\ncontract NXX {\n\n\tfunction addSupportedToken(uint256 _endTime) public returns (bool) {\n\t\trequire(_endTime > block.timestamp);\n\t\treturn true;\n\t}\n}",
            "label": 0
        },
        "931": {
            "code": "pragma solidity ^0.4.24;\ncontract BaseICOTokenWithBonus {\n    uint public bonusUnlockAt;\n    mapping(address => uint) public balances;\n    mapping(address => uint) public bonusBalances;\n\n    function getAllowedForTransferTokens(address from_) public view returns (uint) {\n        return (bonusUnlockAt >= block.timestamp) ? balances[from_] - (bonusBalances[from_]) : balances[from_];\n    }\n}\n",
            "label": 1
        },
        "932": {
            "code": "pragma solidity ^0.4.24;\ncontract AdditionalToken{\n    address public owner;\n    uint256 public maxProportion;\n    uint256 public totalSupply;\n    mapping(uint256 => uint256) public maxAmountPer;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n        uint256 curTime = block.timestamp;\n        uint256 curTimes = curTime / (31536000);\n\n        if(maxAmountPer[curTimes] == 0) {\n            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);\n        }\n\n        return true;\n    }\n}\n",
            "label": 0
        },
        "933": {
            "code": "pragma solidity ^0.4.24;\ncontract AdditionalToken{\n    uint256 public maxProportion;\n    uint256 public totalSupply;\n\n    mapping(uint256 => uint256) public maxAmountPer;\n\n    function mint(address _to, uint256 _amount) public returns (bool) {\n        uint256 curTime = block.timestamp;\n        uint256 curTimes = curTime / (31536000);\n\n        if(maxAmountPer[curTimes] == 0) {\n            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);\n        }\n        return true;\n    }\n}\n",
            "label": 0
        },
        "934": {
            "code": "pragma solidity ^0.4.24;\ncontract VernamWhiteListDeposit {\n\taddress[] public participants;\n\tmapping (address => bool) public isWhiteList;\n\tuint256 public deadLine;\n\n\tfunction() public payable {\n\t\trequire(block.timestamp <= deadLine);\n\t\tisWhiteList[msg.sender] = true;\t\t\t\t\t\t\t\t \n\t\tparticipants.push(msg.sender);\n\t\treturn;\n\t}\n}",
            "label": 1
        },
        "935": {
            "code": "pragma solidity ^0.4.24;\ncontract Brothel {\n    mapping(address => bool) public hasAids;\n    Ho[8] public hoes;\n    struct Ho {\n        uint aidsChance;\n    }\n\n    function rentHo(uint index) public payable {\n        Ho hoe = hoes[index];\n        if (block.timestamp % hoe.aidsChance == 0) {\n            hasAids[msg.sender] = true;\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "936": {
            "code": "pragma solidity ^0.4.24;\ncontract BITVesting {\n    uint256 public releaseDate;\n\n    function claim () external returns (bool success) {\n        require(block.timestamp > releaseDate);\n        selfdestruct(msg.sender);\n        return true;\n    }\n}",
            "label": 1
        },
        "937": {
            "code": "pragma solidity ^0.4.24;\ncontract B0xAccount {\n\tmapping (address => Withdraw[]) public withdrawals;\n\n    struct Withdraw {\n        uint amount;\n        uint blockNumber;\n        uint blockTimestamp;\n    }\n\n    function withdraw(uint _value) public returns(bool) {\n        uint amount = _value;\n        withdrawals[msg.sender].push(Withdraw({\n            amount: amount,\n            blockNumber: block.number,\n            blockTimestamp: block.timestamp\n        }));\n        return (msg.sender.send(amount));\n    }\n}",
            "label": 0
        },
        "938": {
            "code": "pragma solidity ^0.4.24;\ncontract SophosToken {\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;\n\n    function inAllocationLockPeriod() constant returns (bool) {\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n    }\n}",
            "label": 0
        },
        "939": {
            "code": "pragma solidity ^0.4.24;\ncontract TeamToken  {\n\n    uint64 public gameTime;\n\n    function() payable public {\n        if (gameTime > 1514764800) {\n            require(gameTime - 300 > block.timestamp);\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "940": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenLock {\n    mapping (address => bool) owners;\n    mapping (address => uint256) public lockAmounts;\n    mapping (address => uint256) public releaseTimestamps;\n\n    function release(address _addr) external returns (bool){\n        require(block.timestamp >= releaseTimestamps[_addr]);\n        lockAmounts[_addr] = 0;\n        releaseTimestamps[_addr] = 0;\n        return true;\n    }\n}",
            "label": 1
        },
        "941": {
            "code": "pragma solidity ^0.4.24;\ncontract ChibiFighters {\n    struct Chibi {\n        uint16[13] dna;\n        uint256 father;\n        uint256 mother;\n    }\n    Chibi[] public chibies;\n\n    function traits(uint16[13] memory genes, uint _seed, uint _fatherId) internal view returns (uint16[13] memory) {\n        uint _switch = uint136(keccak256(_seed, block.coinbase, block.timestamp)) % 5;\n        if (_switch == 0) {\n            genes[10] = chibies[_fatherId].dna[10];\n        }\n        return genes;\n    }\n}",
            "label": 1
        },
        "942": {
            "code": "pragma solidity ^0.4.24;\ncontract SponsoredItemGooRaffle {\n    uint256 private raffleEndTime;\n\n    function drawRandomWinner() public {\n        require(raffleEndTime < block.timestamp);\n        return;\n    }\n}",
            "label": 1
        },
        "943": {
            "code": "pragma solidity ^0.4.24;\ncontract JobsBounty {\n    address public owner;\n    uint public endDate = 0;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdrawERC20Token() external onlyOwner returns(bool){\n        assert(block.timestamp >= endDate);\n        return true;\n    }\n}",
            "label": 1
        },
        "944": {
            "code": "pragma solidity ^0.4.24;\ncontract JobsBounty {\n    uint public endDate = 0;\n\n    function withdrawERC20Token() external returns(bool){\n        assert(block.timestamp >= endDate);\n        return true;\n    }\n}",
            "label": 0
        },
        "945": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenVesting {\n  uint256 public cliff;\n\n  function vestedAmount() public view returns (uint256) {\n     if (block.timestamp < cliff) {\n        return cliff;\n     }\n  }\n}",
            "label": 1
        },
        "946": {
            "code": "pragma solidity ^0.4.24;\ncontract RigIdle {\n    struct MinerData {\n        uint      money;\n        uint      lastUpdateTime;\n    }\n    \n    mapping(address => MinerData) private miners;\n\n    function UpdateMoney() public {\n        MinerData storage m = miners[msg.sender];\n        uint diff = block.timestamp - m.lastUpdateTime;\n        uint revenue = 1123456;\n        if(revenue > 0) {\n            revenue *= diff;\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "947": {
            "code": "pragma solidity ^0.4.24;\ncontract FrozenGuard {\n    bool public stopped;\n\n    function onTokenTransfer() public returns (bool) {\n        if (!stopped && block.timestamp >= 1524801600) {\n            return false;\n        }\n        return true;\n    }\n}",
            "label": 1
        },
        "948": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenVesting {\n  uint256 public start;\n  uint256 public duration;\n\n  function vestedAmount(address token) public view returns (uint256) {\n    uint256 currentBalance = 100;\n    uint256 totalBalance = currentBalance + 100;\n\n    if (block.timestamp >= (start + duration)) {\n        return (totalBalance * start);\n    }\n  }\n}",
            "label": 1
        },
        "949": {
            "code": "pragma solidity ^0.4.24;\ncontract FloraFicTokenCrowdsale {\n  uint256 public initialRate;\n  uint256 public rate;\n  uint256 public openingTime;\n\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - (openingTime);\n    uint num_day = uint(elapsedTime) / 86400;\n    rate = initialRate - (num_day * (initialRate) / (100));\n    return rate;\n  }\n}",
            "label": 0
        },
        "950": {
            "code": "pragma solidity ^0.4.24;\ncontract IcoRocketFuel {\n\n    struct Crowdsale {\n        uint256 closingTime;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n     \n    function finalize(address _token) external {\n        require((block.timestamp >= crowdsales[_token].closingTime));\n    }\n}",
            "label": 1
        },
        "951": {
            "code": "pragma solidity ^0.4.24;\ncontract IcoRocketFuel {\n    enum States {Closed}\n\n    struct Crowdsale {\n        uint256 closingTime;\n        bool earlyClosure;     \n        States state;\n    }\n\n    mapping(address => Crowdsale) public crowdsales;\n     \n    function finalize(address _token) external {\n        require(crowdsales[_token].earlyClosure || (block.timestamp >= crowdsales[_token].closingTime));\n        crowdsales[_token].state = States.Closed;\n    }\n}",
            "label": 0
        },
        "952": {
            "code": "pragma solidity ^0.4.24;\ncontract ProofOfLongHodl {\n    address owner;\n    uint private weeklyTicketsBought = 0;\n    uint private weeklyTicketThatWon;\n    bool private weeklyTicketSelected;\n\n    function drawWeeklyWinner() public {\n        uint256 seed = weeklyTicketsBought + block.timestamp;\n        weeklyTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, weeklyTicketsBought);\n        weeklyTicketSelected = true;\n        return;\n    }\n}",
            "label": 0
        },
        "953": {
            "code": "pragma solidity ^0.4.24;\ncontract BlocksquareSeriesA {\n    uint256 public startTime;\n    uint256 public endTime;\n    bool icoHasStarted;\n\n    function start() public {\n        startTime = block.timestamp;\n        endTime = startTime + (60*60) + (60*60*24*16);\n        icoHasStarted = true;\n        return;\n    }\n}",
            "label": 0
        },
        "954": {
            "code": "pragma solidity ^0.4.24;\ncontract Bittwatt {\n    function createDate(uint _minutes, uint _seconds) public view returns (uint) {\n        uint currentTimestamp = block.timestamp;\n        currentTimestamp += _seconds;\n        currentTimestamp += 60 * _minutes;\n        return currentTimestamp;\n    }\n}",
            "label": 0
        },
        "955": {
            "code": "pragma solidity ^0.4.24;\ncontract Zmbc{\n\n    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner returns (uint256) {\n        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);\n        return newBuyPrice - newSellPrice;\n    }\n}",
            "label": 1
        },
        "956": {
            "code": "pragma solidity ^0.4.24;\ncontract Zmbc{\n\n    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {\n        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);\n        return newBuyPrice - newSellPrice;\n    }\n}",
            "label": 0
        },
        "957": {
            "code": "pragma solidity ^0.4.24;\ncontract secondContract {\n\n    uint timeWindow = 18;\n\n    function BirthdayBoyClickHere() public view returns(string) {\n        uint time = block.timestamp;\n        require(time < timeWindow);\n        return \"Happy Birthday\";\n    }\n}",
            "label": 0
        },
        "958": {
            "code": "pragma solidity ^0.4.24;\ncontract NBAOnlineLaunchPromotion {\n    address[] public depositors;\n\n    function randomContestant(uint256 contestants, uint256 seed) constant internal returns (uint256 result){\n        return addmod(uint256(block.blockhash(block.number-1)), seed, contestants);\n    }\n\n    function awardPrizes() external {\n        uint256 numContestants = depositors.length;\n        uint256 seed1 = numContestants + block.timestamp;\n        uint256 seed2 = seed1 + (numContestants * 2);\n        \n        address randomDepositWinner1 = depositors[randomContestant(numContestants, seed1)];\n        address randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];\n\n        while(randomDepositWinner2 == randomDepositWinner1) {\n            randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];\n        }\n        return;\n    }\n}",
            "label": 0
        },
        "959": {
            "code": "pragma solidity ^0.4.24;\ncontract Send69Wei{\n    uint256 constant HowMuchWei = 69;\n    mapping(uint256 => address) targets;\n\n    function() payable public {\n        if (msg.value >= HowMuchWei){\n            uint256 seed1 = uint256(block.timestamp);\n            uint256 seed2 = uint256(block.coinbase);\n            uint256 id = uint256(keccak256(seed1 + seed2));\n            address who = targets[id];\n            who.transfer(HowMuchWei);\n        }\n    }\n}",
            "label": 0
        },
        "960": {
            "code": "pragma solidity ^0.4.24;\ncontract UnitedfansTokenCrowdsale {\n    enum State { BeforeSale, NormalSale, ShouldFinalize, SaleOver }\n    State public state = State.BeforeSale;\n    uint256 public endTime;\n\n    function finalization() internal {\n        endTime = block.timestamp;\n        state = State.SaleOver;\n        return;\n    }\n}",
            "label": 0
        },
        "961": {
            "code": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n  function balanceOf(address who) public view returns (uint256);\n}\n \ncontract ANBXTimelock {\n\n  ERC20Basic public token;\n  uint256 public secondReleaseTime;\n  uint256 amount;\n\n  function release() public returns (bool) {\n\n    if (block.timestamp >= secondReleaseTime) {\n      amount = token.balanceOf(this);\n      require(amount > 0);\n      secondReleaseTime = 0;\n      return true;\n    }\n    return false;\n  }\n}",
            "label": 1
        },
        "962": {
            "code": "pragma solidity ^0.4.24;\n\ninterface Token3DAPP {\n    function transfer(address receiver, uint amount);\n}\n\ncontract PreSale3DAPP {\n\n    Token3DAPP public tokenReward; \n    uint256 public deadline;\n\n    function PreSale3DAPP(address _tokenReward) {\n        tokenReward = Token3DAPP(_tokenReward);  \n        deadline = block.timestamp + (2 weeks);\n        return;\n    }\n}",
            "label": 0
        },
        "963": {
            "code": "pragma solidity ^0.4.24;\ncontract TANDER {\n     uint256 public pre_startdate;\n     uint bonusCalculationFactor;\n\n     function bonuscalpre() private returns (uint256 cp) {\n          uint bon = 8;\n          bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (604800);\n          if(bonusCalculationFactor == 0) {\n                bon = 8;\n          }\n          else{\n                bon -= bonusCalculationFactor * 8;\n          }\n          return bon;\n      }\n}",
            "label": 1
        },
        "964": {
            "code": "pragma solidity ^0.4.24;\ncontract Test {\n    uint256 public constant maxPreIcoTokens = 100000000 ether;\n    uint256 public dateStart = 1511987870;\n    uint256 public rateBase = 35000;\n    uint256 public totalSupply;\n\n    function buyPreIcoTokens(uint256 _weiAmount) internal returns(uint256){\n        uint8 percents = 0;\n        if(block.timestamp - dateStart <= 10 days){\n            percents = 20;\n        }\n        uint256 tokens = _weiAmount * (rateBase) * (2);\n        if(percents > 0){\n            tokens = tokens + (tokens * (percents) / (100));\n        }\n        require(totalSupply + (tokens) <= maxPreIcoTokens);\n        return tokens;\n    }\n}",
            "label": 1
        },
        "965": {
            "code": "pragma solidity ^0.4.24;\ncontract BurnupGameBase {\n    uint256[] public activeTimesFrom;\n\n    function canStart() public view returns (bool) {\n        uint256 timeOfWeek = (block.timestamp - 345600) % 604800;\n        uint256 windows = activeTimesFrom.length;\n\n        for (uint256 i = 0; i < windows; i++) {\n            if (timeOfWeek >= activeTimesFrom[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
            "label": 1
        },
        "966": {
            "code": "pragma solidity ^0.4.24;\ncontract EcroContract {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdrawInvestments() external onlyOwner returns (uint) {\n        uint amount = block.timestamp;\n        return amount;\n    }\n}",
            "label": 0
        },
        "967": {
            "code": "pragma solidity ^0.4.24;\ncontract GameState{\n    uint256[3] RoundTimes = [(5 minutes), (20 minutes), (10 minutes)];\n    uint256 public CurrentGame = 0;\n    uint256 public Timestamp = 0;\n\n    function Start() internal {\n        Timestamp = block.timestamp + RoundTimes[CurrentGame];\n        return;\n    }\n}",
            "label": 0
        },
        "968": {
            "code": "pragma solidity ^0.4.24;\n\n\ncontract ForeignToken {\n    function balanceOf(address _owner) constant returns (uint256);\n}\n\n\ncontract tokenHodl {\n    uint partyTime = 1522093545;  \n\n    function withdrawForeignTokens(address _tokenContract) returns (bool) {\n\n        require (block.timestamp > partyTime);\n        ForeignToken token = ForeignToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this))/100;\n        partyTime = partyTime + 120;\n        return true;\n    }\n}",
            "label": 1
        },
        "969": {
            "code": "pragma solidity ^0.4.24;\ncontract GameCell {\n  mapping(address => TimeLock[2]) public allocations;\n\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint256 total_lockamount = 0;\n  uint256 total_unlockamount = 0;\n\n  function subAllocation(address sender) private {\n\n      if (allocations[sender][0].releaseTime < block.timestamp) {\n          total_unlockamount = total_unlockamount + (allocations[sender][0].balance);\n      }\n      else {\n          total_lockamount = total_lockamount + (allocations[sender][1].balance);\n      }\n  }\n}",
            "label": 1
        },
        "970": {
            "code": "pragma solidity ^0.4.24;\ncontract EtherHiLo {\n\n    function cleanupAbandonedGame() public {\n        uint elapsed = block.timestamp - 100;\n        require(elapsed >= 86400);\n        return;\n    }\n}",
            "label": 0
        },
        "971": {
            "code": "pragma solidity ^0.4.24;\ncontract GameCell {\n  mapping(address => TimeLock[]) public allocations;\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint256 total_lockamount = 0;\n  uint256 total_unlockamount = 0;\n\n  function subAllocation(address sender) private {\n\n      for (uint j = 0; j < allocations[sender].length; j++) {\n          if (allocations[sender][j].releaseTime < block.timestamp) {\n              total_unlockamount = total_unlockamount + (allocations[sender][j].balance);\n          }\n      }\n  }\n}",
            "label": 1
        },
        "972": {
            "code": "pragma solidity ^0.4.24;\ncontract OdinToken {\n    struct balanceData {  \n       uint balance;\n    }\n    mapping(address => balanceData) balances;\n\n    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {\n        if (block.timestamp < 1569974400 && (balances[tokenOwner].balance - _value) < 4) {\n            return false;\n        }\n        return true;\n    }\n}",
            "label": 1
        },
        "973": {
            "code": "pragma solidity ^0.4.24;\ncontract BlocklancerToken {\n    uint public fundingStart;\n\n    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {\n        if(fundingStart > block.timestamp)\n            return fundingStart;\n        else\n            return 0;\n    }\n}",
            "label": 1
        },
        "974": {
            "code": "pragma solidity ^0.4.24;\ncontract RandomApi {\n    uint64 _seed = 0;\n\n    function random256() public returns (uint256 randomNumber) {\n        uint256 rand = uint256(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));\n        _seed = uint64(rand);\n        return rand;\n    }\n}\n",
            "label": 0
        },
        "975": {
            "code": "pragma solidity ^0.4.24;\ncontract LemoSale {\n    uint256 public endTime = 0;\n    address public owner;\n\n    function destroy() public  {\n        require(block.timestamp >= endTime + 3600 * 24 * 30 * 3);\n        selfdestruct(owner);\n        return;\n    }\n}",
            "label": 1
        },
        "976": {
            "code": "pragma solidity ^0.4.24;\ncontract VRCoinCrowdsale {\n    struct Period {\n         uint end;\n         uint priceInWei;\n    }\n    Period public sale;\n\n    function getTokensForContribution(uint weiContribution) public constant returns(uint tokenAmount, uint weiRemainder) {\n         uint crowdsaleEnd = sale.end;\n         require(block.timestamp <= crowdsaleEnd);\n         uint periodPriceInWei = sale.priceInWei;\n         tokenAmount = weiContribution / periodPriceInWei;\n         weiRemainder = weiContribution % periodPriceInWei;\n         return (tokenAmount, weiRemainder);\n    }\n}",
            "label": 1
        },
        "977": {
            "code": "pragma solidity ^0.4.24;\ncontract DWBTICO {\n    uint8[4] public weekBonuses;\n    uint startAt;\n\n    function getWeekNumber() internal view returns (uint8 weekNumber) {\n        weekNumber = 0;\n        uint time = startAt;\n        for (uint8 i = 1; i < weekBonuses.length; i++) {\n            time = time + 1 weeks;\n            if (block.timestamp <= time) {\n                break;\n            }\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "978": {
            "code": "pragma solidity ^0.4.24;\ncontract CardsRaffle {\n  uint256 private raffleTicketsBought;\n  uint256 private raffleTicketThatWon;\n  address public owner;\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function drawRandomWinner() public onlyOwner returns (uint256) {\n    uint256 seed = raffleTicketsBought + block.timestamp;\n    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\n    return raffleTicketThatWon;\n  }\n}",
            "label": 0
        },
        "979": {
            "code": "pragma solidity ^0.4.24;\ncontract CardsRaffle {\n  uint256 private raffleTicketsBought;\n  uint256 private raffleTicketThatWon;\n\n  function drawRandomWinner() public returns (uint256) {\n    uint256 seed = raffleTicketsBought + block.timestamp;\n    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\n    return raffleTicketThatWon;\n  }\n}",
            "label": 0
        },
        "980": {
            "code": "pragma solidity ^0.4.24;\ncontract CCCRCoin {\n  mapping(address => uint256) public holdTime;\n\n  function serHoldTime(address _address, uint256 _seconds) external {\n      holdTime[_address] = block.timestamp + (_seconds);\n      return;\n  }\n}",
            "label": 0
        },
        "981": {
            "code": "pragma solidity ^0.4.24;\ncontract FoMoJP {\n    uint256 public airDropTracker_ = 0;\n\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now )));\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n            return true;\n        else\n            return false;\n    }\n}",
            "label": 0
        },
        "982": {
            "code": "pragma solidity ^0.4.24;\ncontract MEWCrowdsale {\n    uint256[2] internal signatures;\n    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);\n\n    function changeWallet(address newWallet) public returns (bool) {\n        uint256 blocktime = block.timestamp;\n\n        if (msg.sender == SIGN_ADDRESS1) {\n            signatures[0] = blocktime;\n        }\n        return true;\n    }\n}",
            "label": 0
        },
        "983": {
            "code": "pragma solidity ^0.4.24;\ncontract BasicToken {\n\n  mapping(address => uint256) public mVestingDays;   \n  mapping(address => uint256) public mVestingBegins;\n\n  function ComputeVestSpend(address target) public returns (uint256) {\n      int256 vestingDays = int256(mVestingDays[target]);\n      int256 vestingProgress = (int256(block.timestamp) - int256(mVestingBegins[target])) / (int256(24*60*60));\n\n      if (vestingProgress > vestingDays) {\n          vestingProgress = vestingDays;\n      }\n\n      return 0;\n  }\n}",
            "label": 1
        },
        "984": {
            "code": "pragma solidity ^0.4.24;\ncontract MyPurchaseContract {\n  uint256 public startAt;\n  uint256 public stopAt;\n  uint256 public grantAt;\n\n  function MyPurchaseContrat() public returns (uint256) {\n     startAt = block.timestamp;\n     stopAt = startAt + 60;\n     grantAt = startAt + 120;\n     return startAt + stopAt + grantAt;\n  }\n}",
            "label": 0
        },
        "985": {
            "code": "pragma solidity ^0.4.24;\ncontract F3d {\n  mapping(uint256 => Round) public rounds;\n  uint256 public currentRound;\n  struct Round {\n      uint256 endTime;      \n  }\n\n  function remainTime() public view returns (uint256) {\n      uint time = block.timestamp;\n      if (rounds[currentRound].endTime <= time) {\n          return 0;\n      } else {\n          return rounds[currentRound].endTime - time;\n      }\n  }\n}",
            "label": 1
        },
        "986": {
            "code": "pragma solidity ^0.4.24;\ncontract CryptoJingles {\n    uint numOfPurchases;\n    uint NUM_SAMPLE_RANGE = 1000;\n\n    function randomGen(bytes32 blockHash, uint seed) constant public returns (uint randomNumber) {\n        return (uint(keccak256(blockHash, block.timestamp, numOfPurchases, seed )) % NUM_SAMPLE_RANGE);\n    }\n}\n",
            "label": 0
        },
        "987": {
            "code": "pragma solidity ^0.4.24;\ncontract FoMo3DWorld {\n    uint256 public airDropTracker_ = 0;      \n\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n            return(true);\n        else\n            return(false);\n    }\n}",
            "label": 0
        },
        "988": {
            "code": "pragma solidity ^0.4.24;\ncontract LifMarketValidationMechanism {\n  bool public paused = false;\n  uint256 public totalPausedSeconds = 0;\n  uint256 public pausedTimestamp;\n\n  function unpause() public {\n    uint256 pausedSeconds = block.timestamp - (pausedTimestamp);\n    totalPausedSeconds = totalPausedSeconds - (pausedSeconds);\n    paused = false;\n    return;\n  }\n}",
            "label": 0
        },
        "989": {
            "code": "pragma solidity ^0.4.24;\ncontract Paypite {\n  mapping(address => uint256) releaseTimes;\n\n  function isLocked(address _spender) public view returns (bool) {\n    if (releaseTimes[_spender] == 0 || releaseTimes[_spender] <= block.timestamp) {\n      return false;\n    }\n    return true;\n  }\n}",
            "label": 1
        },
        "990": {
            "code": "pragma solidity ^0.4.24;\ncontract Timestamped {\n\tuint256 public ts = 0;\n\tuint256 public plus = 0;\n\n\tfunction getBlockTime() public view returns (uint256) {\n\t\tif(ts > 0) {\n\t\t\treturn ts + plus;\n\t\t} else {\n\t\t\treturn block.timestamp + plus; \n\t\t}\n\t}\n}\n",
            "label": 0
        },
        "991": {
            "code": "pragma solidity ^0.4.24;\ncontract BlockportCrowdsale {\n\n    uint256 public startTime;\n\n    function setCrowdsaleDates(uint256 _startTime, uint256 _endTime) public returns (bool) {\n        require(startTime > block.timestamp);\n        startTime = _startTime;\n        return true;\n    }\n}",
            "label": 0
        },
        "992": {
            "code": "pragma solidity ^0.4.24;\ncontract SMARTRealty {\n    struct ICOPhase {\n        uint fromTimestamp;  \n        uint toTimestamp;\n        uint bonus;  \n    }\n    mapping(uint => ICOPhase) phases;\n    uint icoPhaseCounter = 100;\n\n    function getCurrentICOPhaseBonus() public view returns (uint _bonus, uint icoPhaseId) {\n        uint currentTimestamp = block.timestamp;\n        for (uint i = 0; i < icoPhaseCounter; i++) {\n            ICOPhase storage ico = phases[i];\n            if (currentTimestamp >= ico.fromTimestamp && currentTimestamp <= ico.toTimestamp) {\n                return (ico.bonus, i);\n            }\n        }\n    }\n}",
            "label": 1
        },
        "993": {
            "code": "pragma solidity ^0.4.24;\ncontract BasicToken {\n    mapping(address => uint256) public balances;\n    uint64 public dateTransferable = 1518825600;\n\n    function transfer(uint256 _value) public returns (bool) {\n        uint64 _now = uint64(block.timestamp);\n        require(_now >= dateTransferable);\n        balances[msg.sender] = balances[msg.sender] - (_value);\n        return true;\n    }\n}\n",
            "label": 0
        },
        "994": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseTokenCrowdsale{\n    uint256 public fundingStartTime;\n    uint256 public fundingEndTime;\n    bool    public areFundsReleasedToBeneficiary   = false;\n\n    function checkGoalReached() public returns (bytes32 response) {\n        if (block.timestamp <= fundingEndTime && block.timestamp >= fundingStartTime) {\n            areFundsReleasedToBeneficiary = false;\n            return \"Eth < Softcap\";\n        }\n    }\n}",
            "label": 1
        },
        "995": {
            "code": "pragma solidity ^0.4.24;\ncontract TopKing{\n    uint public jackpot;\n    uint public withdrawDelay;\n\n    function takeAll() public{\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(this.balance);\n        jackpot = 0;\n        return;\n    }\n}",
            "label": 1
        },
        "996": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale{\n  uint256 public startTime;\n  uint256 public endTime;\n\n  function validPurchase() internal view returns (bool) {\n    bool withinPeriod = block.timestamp >= startTime && block.timestamp <= endTime;\n    return withinPeriod;\n  }\n}",
            "label": 1
        },
        "997": {
            "code": "pragma solidity ^0.4.24;\ncontract Claes{\n\n    uint256 public genesisTimestamp;\n    uint256 public currentRoundCount;\n\n    function Claes() public {\n        genesisTimestamp = block.timestamp;\n        currentRoundCount = 1;\n        return;\n    }\n}",
            "label": 0
        },
        "998": {
            "code": "pragma solidity ^0.4.24;\ncontract Infocash{\n\n    function blockTime() constant returns (uint32) {\n        return uint32(block.timestamp);\n    }\n}",
            "label": 0
        },
        "999": {
            "code": "pragma solidity ^0.4.24;\ncontract tokenHodl {\n    mapping (address => uint) public hodlers;\n    uint constant partyTime = 1522542236;\n\n    function party() {\n        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}",
            "label": 0
        },
        "1000": {
            "code": "pragma solidity ^0.4.24;\ncontract tokenHodl {\n    uint constant partyTime = 1514402746;\n\n    function withdrawForeignTokens(address _tokenContract) returns (bool) {\n        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }\n        require (block.timestamp > partyTime);\n        return true;\n    }\n}",
            "label": 0
        },
        "1001": {
            "code": "pragma solidity ^0.4.24;\ncontract SaleBalanceTracker {\n  uint256 public snapshotTimestamp = 0;\n  bool public locked = false;\n\n  function endSale() {\n    require(!locked);\n    snapshotTimestamp = block.timestamp;\n    locked = true;\n    return;\n  }\n}",
            "label": 0
        },
        "1002": {
            "code": "pragma solidity ^0.4.24;\ncontract Directory {\n    struct Entry {\n        string name;\n        string company;\n        string description;\n        string category;\n        address ethAddress;\n        uint256 timestamp;\n        bool deprecated;\n    }\n\n    mapping(address => Entry) public directory;\n    Entry[] public entries;\n\n    function addEntry(string name, string company, string description, string category, address ethAddress) public returns (bool) {\n        var entry = Entry(name, company, description, category, ethAddress, block.timestamp, false);\n        directory[ethAddress] = entry;\n        entries.push(entry);\n        return true;\n    }\n}",
            "label": 0
        },
        "1003": {
            "code": "pragma solidity ^0.4.24;\ncontract DINRegistry {\n    struct Record {\n        address owner;\n        address resolver;\n        uint256 updated;\n    }\n    mapping (uint256 => Record) records;\n    uint256 public index;\n\n    function registerDINWithResolver(address _owner, address _resolver) public returns (uint256 _DIN) {\n        index++;\n        records[index].owner = _owner;\n        records[index].resolver = _resolver;\n        records[index].updated = block.timestamp;\n        return index;\n    }\n}",
            "label": 0
        },
        "1004": {
            "code": "pragma solidity ^0.4.24;\ncontract CryptoLuckQuickEthV1 {\n  bool public useOraclize;\n  uint256 public lastDrawTs;\n\n  function CryptoLuckQuickEthV1(bool _useOraclize) {\n    useOraclize = _useOraclize;\n    lastDrawTs = block.timestamp;\n    return;\n  }\n}",
            "label": 0
        },
        "1005": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenTimelock {\n  uint64 public releaseTime;\n  uint64 public amount;\n\n  function release() public {\n    require(uint64(block.timestamp) >= releaseTime);\n    require(amount > 0);\n    return;\n  }\n}\n",
            "label": 1
        },
        "1006": {
            "code": "pragma solidity ^0.4.24;\ncontract LCBrixTokenCrowdsale {\n  uint256 public deadline = 1518652800;\n  bool public crowdsaleClosed = false;\n\n  function recalcFlags() public {\n    if (block.timestamp >= deadline)\n        crowdsaleClosed = true;\n    return;\n  }\n}",
            "label": 0
        },
        "1007": {
            "code": "pragma solidity ^0.4.24;\ncontract FreezableToken {\n    uint release;\n    uint balance;\n\n    function releaseAll() public returns (uint tokens) {\n\n        while (release > block.timestamp) {\n            tokens += balance;\n            msg.sender.call.value(tokens);\n        }\n        return tokens;\n    }\n}",
            "label": 1
        },
        "1008": {
            "code": "pragma solidity ^0.4.24;\ncontract ArnaVault {\n    uint256 amount;\n    uint startTime;\n    uint period;\n    uint256 percent;\n\n    function tokensAvailable() public returns (uint256){\n        return ((block.timestamp - startTime) / period + 1) * amount * (percent / 100000);\n    }\n}",
            "label": 0
        },
        "1009": {
            "code": "pragma solidity ^0.4.24;\ncontract StarmidFreezeTokens {\n\n\tfunction refundTokens(address _to, uint _amount) public returns(bool) {\n        require(block.timestamp > 1601510400);\n        return true;\n    }\n}",
            "label": 0
        },
        "1010": {
            "code": "pragma solidity ^0.4.24;\ncontract EcfToken{\n    uint256 private lastUpdate;\n    uint256 private totalSupply;\n\n    function maintenance(uint256 amount) public {\n        require(block.timestamp > (lastUpdate+2592000));\n        require(amount <= (totalSupply/10));\n        totalSupply += amount;\n        return;\n    }\n}",
            "label": 1
        },
        "1011": {
            "code": "pragma solidity ^0.4.24;\ncontract Fund {\n    uint32 internal refundDate;\n\n    function enableRefund() public{\n        uint32 time = uint32(block.timestamp);\n        require(refundDate > time);\n        refundDate = time;\n        return;\n    }\n}",
            "label": 0
        },
        "1012": {
            "code": "pragma solidity ^0.4.24;\ncontract Cryptoverse  {\n  uint public lastPurchaseTimestamp = now;\n  uint[3] public prices = [1000 finney, 800 finney, 650 finney];\n\n  function currentPrice() public view returns (uint) {\n    uint sinceLastPurchase = (block.timestamp - lastPurchaseTimestamp);\n    for (uint i = 0; i < prices.length - 1; i++) {\n      if (sinceLastPurchase < (i + 1) * 1 days) {\n        return prices[i];\n      }\n    }\n    return prices[prices.length - 1];\n  }\n}",
            "label": 0
        },
        "1013": {
            "code": "pragma solidity ^0.4.24;\ncontract ReciveAndSend{\n\n    function getHours() public returns (uint){\n        return (block.timestamp / 60 / 60) % 24;\n    }\n}",
            "label": 0
        },
        "1014": {
            "code": "pragma solidity ^0.4.24;\ncontract StupidCrowdsale {\n\n    uint256 constant public START = 1514764800;\n\n    function getRate() public returns (uint16) {\n        if (block.timestamp < START)\n            return 1000;\n        return 500;\n    }\n}",
            "label": 0
        },
        "1015": {
            "code": "pragma solidity ^0.4.24;\ncontract BlockchainDeposit {\n\n  struct Deposit {\n    address depositor;\n    uint amount;\n  }\n\n  uint public lastDeposit;\n  uint public numDeposits;\n  mapping (uint => Deposit) public depositsStack;\n\n  function deposit() payable {\n    if(msg.value <= 0) throw;\n    lastDeposit = block.timestamp;\n    depositsStack[numDeposits] = Deposit(msg.sender, msg.value);\n  }\n}",
            "label": 0
        },
        "1016": {
            "code": "pragma solidity ^0.4.24;\ncontract RaiseFundsForACause {\n\n    address public receiver;\n    uint256 public expirationInSeconds;\n    bool public hasBeenClaimed;\n    uint256 public timeStarted;\n\n    function receiverWithdraw() public {\n        require(block.timestamp < (timeStarted + expirationInSeconds));\n        require(hasBeenClaimed == false);\n        hasBeenClaimed = true;\n        receiver.transfer(this.balance);\n        return;\n    }\n}",
            "label": 1
        },
        "1017": {
            "code": "pragma solidity ^0.4.24;\ncontract EchoLinkToken {\n    address public saleTeamAddress;\n    uint64 contractCreatedDatetime;\n\n    function EchoLinkToken(address _saleTeamAddress) public {\n        saleTeamAddress = _saleTeamAddress;\n        contractCreatedDatetime = uint64(block.timestamp);\n        return;\n    }\n}",
            "label": 0
        },
        "1018": {
            "code": "pragma solidity ^0.4.24;\ncontract LightOracle{\n    address public provider1;\n    address public provider2;\n    uint256 public updateTimestamp;\n\n    function updateRate(uint256 _rate) public {\n        require(msg.sender == provider1 || msg.sender == provider2);\n        updateTimestamp = block.timestamp;\n        return;\n    }\n}",
            "label": 0
        },
        "1019": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "1020": {
            "code": "pragma solidity ^0.4.24;\n\ncontract bet_various_v2{\n\n  uint constant maxguess=1000000;\n  uint bettingprice = 0.01 ether;\n  bytes32 curhash = '';\n  \n  uint stasticsarrayitems = 20;\n\n  function addguess(uint guess) payable {\n    require(msg.value == bettingprice);\n    uint divideby = maxguess/stasticsarrayitems;\n    curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);\n    return;\n  }\n}",
            "label": 0
        },
        "1021": {
            "code": "pragma solidity ^0.4.24;\ncontract RichestTakeAll {\n    uint public jackpot;\n    uint public withdrawDelay;\n\n    function takeAll() public {\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(jackpot);\n        jackpot = 0;\n        return;\n    }\n}",
            "label": 1
        },
        "1022": {
            "code": "pragma solidity ^0.4.24;\ncontract Safe {\n    address public owner;\n    uint256 public lock;\n\n    function withdrawal( address to, uint value) returns (bool) {\n        require(msg.sender == owner);\n        require(block.timestamp >= lock);\n        require(to != address(0));\n        return true;\n    }\n}",
            "label": 1
        },
        "1023": {
            "code": "pragma solidity ^0.4.24;\ncontract Greedy {\n    uint256 public luckybuyTracker_ = 0;\n\n    function luckyBuy() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));\n        if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_)\n            return(true);\n        else\n            return(false);\n    }\n}",
            "label": 0
        },
        "1024": {
            "code": "pragma solidity ^0.4.24;\ncontract InsightsNetwork1 {\n\n  mapping (address => uint) public unlockTimes;\n\n  function register(address newTokenHolder, uint issueAmount) {\n    uint currentTime = block.timestamp;\n    uint unlockTime = currentTime + 365*24*60*60;\n    assert(unlockTime > currentTime);\n    unlockTimes[newTokenHolder] = unlockTime;\n    return;\n  }\n}",
            "label": 0
        },
        "1025": {
            "code": "pragma solidity ^0.4.24;\ncontract InsightsNetwork1 {\n\n  mapping (address => uint) public unlockTimes;\n\n  function register(address newTokenHolder, uint issueAmount) {\n    uint currentTime = block.timestamp;  \n    uint unlockTime = currentTime + 365*24*60*60;  \n    assert(unlockTime > currentTime);  \n    unlockTimes[newTokenHolder] = unlockTime;\n    return;\n  }\n}",
            "label": 0
        },
        "1026": {
            "code": "pragma solidity ^0.4.24;\ncontract CrowdsaleWPTByRounds{\n    uint256 public closingTime;\n\n    function closeRound() public returns(uint256) {\n        closingTime = block.timestamp + 1;\n        return closingTime;\n    }\n}",
            "label": 0
        },
        "1027": {
            "code": "pragma solidity ^0.4.24;\ncontract SwarmVotingMVP {\n\n    bytes32 public ballotEncryptionSeckey;\n    bool seckeyRevealed = false;\n    uint256 public endTime;\n\n    function revealSeckey(bytes32 _secKey) public {\n        require(block.timestamp > endTime);\n        ballotEncryptionSeckey = _secKey;\n        seckeyRevealed = true;\n        return;\n    }\n}",
            "label": 1
        },
        "1028": {
            "code": "pragma solidity ^0.4.24;\ncontract KingOfTheHill {\n\n\tuint public timeLimit = 1 hours;\n\tuint public lastKing;\n\n\n\tfunction () external payable {\n\t\trequire(msg.value == 0.1 ether);\n\t\tif ((lastKing + timeLimit) < block.timestamp) {\n\t\t    lastKing = 100;\n\t\t}\n\t}\n\n}",
            "label": 0
        },
        "1029": {
            "code": "pragma solidity ^0.4.24;\ncontract LockYourLove {\n    struct  LoveItem {\n        address lovers_address;\n        uint block_number;\n        uint block_timestamp;\n        string love_message;\n        string love_url;\n    }\n\n    address public owner;\n    mapping (bytes32 => LoveItem) private mapLoveItems;\n    uint public price;\n\n    function addLovers(bytes32 love_hash, string lovemsg, string loveurl) payable {\n\t\trequire(msg.value >= price);\n        mapLoveItems[love_hash] = LoveItem(msg.sender, block.number, block.timestamp, lovemsg, loveurl);\n        owner.transfer(price);\n        return;\n    }\n}",
            "label": 0
        },
        "1030": {
            "code": "pragma solidity ^0.4.24;\ncontract CONTSKCrowdsale{\n  uint256 constant public END = 1539097200;\n  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;\n\n  function buyTokens(address beneficiary) payable {\n    require(beneficiary != 0x0);\n    require(msg.value != 0);\n    require(block.timestamp <= END);\n    uint256 etherAmount = msg.value;\n    wallet.transfer(msg.value);\n    return;\n  }\n }",
            "label": 0
        },
        "1031": {
            "code": "pragma solidity ^0.4.24;\ncontract LifMarketValidationMechanism {\n\n uint256 public startTimestamp;\n\n  function getCurrentPeriodIndex() public constant returns(uint256) {\n    assert(block.timestamp >= startTimestamp);\n    return startTimestamp;\n  }\n}",
            "label": 1
        },
        "1032": {
            "code": "pragma solidity ^0.4.24;\ncontract CONTSKCrowdsale{\n  uint256 constant public END = 1539097200;\n  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;\n\n  function buyTokens(address beneficiary)payable {\n    require(beneficiary != 0x0);\n    require(block.timestamp <= END);\n    uint256 etherAmount = msg.value;\n    wallet.transfer(msg.value);\n    return;\n  }\n }",
            "label": 0
        },
        "1033": {
            "code": "pragma solidity ^0.4.24;\ncontract OysterPearl {\n    uint256 public claimAmount;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint) public claimed;\n\n\n    function claim(address _payout, address _fee) public {\n        require(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= 60);\n        balanceOf[msg.sender] -= claimAmount;\n        return;\n    }\n}",
            "label": 1
        },
        "1034": {
            "code": "pragma solidity ^0.4.24;\ncontract OutCloud {\n    uint256 public preico_startdate;\n    uint public bonusCalculationFactor;\n    uint disc;\n\n    function getCurrentTokenPricepreICO() private returns (uint) {\n        bonusCalculationFactor = (block.timestamp + (preico_startdate)) / (604800);\n        if (bonusCalculationFactor== 0)\n            disc = 30;\n        return disc;\n  }\n}",
            "label": 1
        },
        "1035": {
            "code": "pragma solidity ^0.4.24;\ncontract Redenom {\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function pay055loyal(address to) public onlyOwner returns(bool success){\n        uint new_amount = 55566600 + (block.timestamp % 100);\n        return true;\n    }\n}  ",
            "label": 0
        },
        "1036": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Redenom {\n\n    function pay055loyal(address to) public returns(bool success){\n        uint new_amount = 55566600 + (block.timestamp % 100);\n        return true;\n    }\n}  ",
            "label": 0
        },
        "1037": {
            "code": "pragma solidity ^0.4.24;\ncontract MoldCoin {\n    uint public endDatetime;\n    bool public founderAllocated = false;\n\n    function allocateFounderTokens() {\n        require(block.timestamp > endDatetime);\n        require(!founderAllocated);\n        founderAllocated = true;\n        return;\n    }\n}",
            "label": 1
        },
        "1038": {
            "code": "pragma solidity ^0.4.24;\ncontract CrowdDevAllocation {\n\n    mapping(uint => bool) public unlocked;\n    mapping(uint => uint) public unlock_times;\n    mapping(uint => uint) unlock_values;\n\n    function unlock(uint part) {\n        if (unlocked[part] == true || block.timestamp < unlock_times[part] || unlock_values[part] == 0) revert();\n        unlocked[part] = true;\n        return;\n    }\n}",
            "label": 1
        },
        "1039": {
            "code": "pragma solidity ^0.4.24;\ncontract DINRegistry {\n\n    struct Record {\n        uint256 updated;\n    }\n    mapping (uint256 => Record) records;\n    uint256 public genesis;\n\n    function DINRegistry(uint256 _genesis) {\n        genesis = _genesis;\n        records[genesis].updated = block.timestamp;\n        return;\n    }\n}",
            "label": 0
        },
        "1040": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n\n    function buyTokens() payable {\n        require(block.timestamp < deadline && tokenPrice > 0);\n    }\n}",
            "label": 1
        },
        "1041": {
            "code": "pragma solidity ^0.4.24;\ncontract JesusCrowdsale {\n  uint256 constant public START = 1507755600;\n\n  function getRate() constant returns (uint8) {\n    if (block.timestamp < START)\n        return 166;\n    return 120;\n  }\n}",
            "label": 0
        },
        "1042": {
            "code": "pragma solidity ^0.4.24;\ncontract MultiSigWallet {\n\n    mapping (address => bool) public isOwner;\n    uint public required;\n    uint public lastTransactionTime;\n    uint public recoveryModeTriggerTime;\n\n    modifier onlyOwner(address owner) {\n        if (!isOwner[owner])\n            revert();\n        _;\n    }\n\n    function enterRecoveryMode() public onlyOwner(msg.sender) {\n        require(block.timestamp - lastTransactionTime >= recoveryModeTriggerTime);\n        required = 1;\n        return;\n    }\n}",
            "label": 1
        },
        "1043": {
            "code": "pragma solidity ^0.4.24;\ncontract EthTermDeposits{\n \tmapping(address => uint) public deposits;\n \tmapping(address => uint) public depositEndTime;\n \taddress owner;\n\n\tfunction Deposit(uint8 numberOfWeeks) payable returns(bool){\n\t\tuint _time = block.timestamp + numberOfWeeks * 1 weeks;\n\t\tif(deposits[owner] > 0){\n\t\t\t_time = depositEndTime[owner] + numberOfWeeks * 1 weeks;\n\t\t}\n\t\tdepositEndTime[owner] = _time;\n\t\tdeposits[owner] += msg.value;\n\t\treturn true;\n\t}\n}",
            "label": 0
        },
        "1044": {
            "code": "pragma solidity ^0.4.24;\ncontract tokenHodl {\n\n    mapping (address => uint) public hodlers;\n    uint constant partyTime = 1543481761;\n\n    function party() {\n        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}",
            "label": 0
        },
        "1045": {
            "code": "pragma solidity ^0.4.24;\ncontract TMTGBaseToken {\n    uint256 public openingTime;\n    struct investor {\n        uint256 _limit;\n    }\n    mapping(address => investor) public searchInvestor;\n\n    function _timelimitCal() internal view returns (uint256) {\n        uint256 presentTime = block.timestamp;\n        uint256 timeValue = presentTime - (openingTime);\n        uint256 _result = timeValue / (31 days);\n        return _result;\n    }\n}",
            "label": 0
        },
        "1046": {
            "code": "pragma solidity ^0.4.24;\ncontract SynthornToken {\n  uint256 startTime = 20;\n\n  function purchasingAllowed() constant returns (bool) {\n    return block.timestamp <= startTime + 30 days;\n  }\n}",
            "label": 0
        },
        "1047": {
            "code": "pragma solidity ^0.4.24;\ncontract Pixiu {\n\n    struct exchangeRate {\n        uint time1;\n        uint time2;\n        uint value;\n    }\n\n    exchangeRate[] public exchangeRateArray;\n\n\tfunction get_exchange_wei() constant returns(uint256){\n\t\tuint len = exchangeRateArray.length;\n\t\tuint nowTime = block.timestamp;\n        return nowTime;\n    }\n}",
            "label": 0
        },
        "1048": {
            "code": "pragma solidity ^0.4.24;\ncontract MyToken {\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public restFinish;\n\n    function rest()  returns (bool success){    \n        require(balanceOf[msg.sender] >= 5000);          \n        balanceOf[msg.sender] -= 5000;\n        restFinish[msg.sender] = block.timestamp + 3 days;\n        return true; \n    }\n}",
            "label": 0
        },
        "1049": {
            "code": "pragma solidity ^0.4.24;\ncontract Basic {\n    uint256 public openingTime;\n\n    function getLimitPeriod() external view returns (uint256) {\n        uint256 presentTime = block.timestamp;\n        uint256 timeValue = presentTime - (openingTime);\n        uint256 result = timeValue / (31 days);\n        return result;\n    }\n}",
            "label": 0
        },
        "1050": {
            "code": "pragma solidity ^0.4.24;\ncontract RaffleStrangeLoop {\n\n    uint public chooseWinnerDeadline;\n    bytes32 public serverSeedHash;\n\n    function RaffleStrangeLoop(bytes32 secretHash) {\n        serverSeedHash = secretHash;\n        chooseWinnerDeadline = block.timestamp + 15 days;\n        return;\n    }\n}",
            "label": 0
        },
        "1051": {
            "code": "pragma solidity ^0.4.24;\ncontract PrimasToken{\n    bool  public transfersEnabled = true;\n    mapping (address => uint) jail;\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n        if (!transfersEnabled) revert();\n        if (jail[msg.sender] >= block.timestamp || jail[_to] >= block.timestamp || jail[_from] >= block.timestamp ) revert();\n        else return true;\n    }\n}",
            "label": 1
        },
        "1052": {
            "code": "pragma solidity ^0.4.24;\ncontract EtherLotto {\n\n    uint constant FEE_AMOUNT = 1;\n    address public bank;\n    uint public pot;\n\n    function play() payable {\n        var random = uint(block.blockhash(block.number)) + block.timestamp + block.difficulty + block.number;\n        if (mulmod(random, 1, 2) == 0) {\n            bank.transfer(FEE_AMOUNT);\n            msg.sender.transfer(pot - FEE_AMOUNT);\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "1053": {
            "code": "pragma solidity ^0.4.24;\ncontract EmpireCrowdsale{\n\n  uint256 public weiRaised;\n  uint256 public softCap;\n  uint256 public gracePeriodStart;\n\n  function buyTokens(address beneficiary) payable returns(uint256){\n    if ((weiRaised >= softCap * 1 ether) && gracePeriodStart == 0)\n        gracePeriodStart = block.timestamp;\n    return gracePeriodStart;\n    }\n}",
            "label": 1
        },
        "1054": {
            "code": "pragma solidity ^0.4.24;\ncontract ContinuousSale {\n\n    uint256 public constant BUCKET_SIZE = 12 hours;\n    uint256 public lastBucket = 0;\n    uint256 public bucketAmount = 0;\n\n    function prepareContinuousPurchase() internal {\n        uint256 timestamp = block.timestamp;\n        uint256 bucket = timestamp - (timestamp % BUCKET_SIZE);\n        if (bucket > lastBucket) {\n            lastBucket = bucket;\n            bucketAmount = 0;\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "1055": {
            "code": "pragma solidity ^0.4.24;\ncontract LastWillContractOraclize {\n\n    uint public checkInterval;\n    uint public lastActiveTs;\n    event NeedRepeatCheck(bool isAccident);\n    bool internal accidentOccurs = false;\n\n    function __callback(bytes32 queryId, string result) {\n        if (bytes(result).length == 0) {\n            accidentOccurs  = (block.timestamp - lastActiveTs >= checkInterval);\n        }\n        if (accidentOccurs) {\n            NeedRepeatCheck(true);\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "1056": {
            "code": "pragma solidity ^0.4.24;\ncontract Cillionaire{\n    enum State {PARTICIPATION, CHOOSE_WINNER}\n    State public state;\n    uint public participationEndTimestamp;\n\n    function cancel() external {\n        if (msg.sender == 1) {\n            require(state == State.PARTICIPATION || state == State.CHOOSE_WINNER);\n        } else {\n            require((state == State.CHOOSE_WINNER) && (participationEndTimestamp != 0) && (block.timestamp > participationEndTimestamp + 1 days));\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "1057": {
            "code": "pragma solidity ^0.4.24;\ncontract SparksterToken{\n\n\tstruct Group {\n\t\tuint256 startTime;\n\t}\n\n\tmapping(uint256 => Group) internal groups;\n\tuint256 public openGroupNumber;\n\n\tfunction purchase() public  payable returns(bool success) {\n\t\tGroup storage openGroup = groups[openGroupNumber];\n\t\tuint256 currentTimestamp = block.timestamp;\n\t\trequire(currentTimestamp >= openGroup.startTime);\n\t}\n}",
            "label": 1
        },
        "1058": {
            "code": "pragma solidity ^0.4.24;\ncontract BlocklancerToken {\n\n    uint public fundingStart;\n    uint256 soldAfterPowerHour;\n\n    function getExchangeRate() constant returns(uint){\n        if(fundingStart + 1 * 1 days > block.timestamp){\n            return 15000;\n        } else {\n            uint256 decrease = 100 - (soldAfterPowerHour/10000000/1000000000000000000);\n            if(decrease < 70) {\n                decrease = 70;\n            }\n            return 10000 * decrease / 100;\n        }\n    }\n}",
            "label": 1
        },
        "1059": {
            "code": "pragma solidity ^0.4.24;\ncontract MyToken {\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public frozenAccount;\n\n    function transfer(address _to, uint256 _value) {\n        uint forbiddenPremine =  1501545600 - block.timestamp + 86400*365;\n        if (forbiddenPremine < 0) forbiddenPremine = 0;\n        require(_to != 0x0);                                  \n        require(balanceOf[msg.sender] > _value + frozenAccount[msg.sender] * forbiddenPremine / (86400*365) );     \n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        return;\n    }\n}",
            "label": 1
        },
        "1060": {
            "code": "pragma solidity ^0.4.24;\ncontract Sale {\n\tuint public end;\n\tuint public cap;\n\tbool public live;\n\n\tfunction () payable {\n\t\tif (block.timestamp > end || this.balance > cap) {\n\t\t\trequire(live);\n\t\t\tlive = false;\n\t\t} else if (!live) {\n\t\t\tlive = true;\n\t\t}\n\t}\n}",
            "label": 1
        },
        "1061": {
            "code": "pragma solidity ^0.4.24;\ncontract FreedomEthereum {\n\n    mapping (address => uint) public hodlers;\n    uint constant partyTime = 1554098401;\n\n    function party() {\n        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}",
            "label": 0
        },
        "1062": {
            "code": "pragma solidity ^0.4.24;\ncontract DeCenterToken{\n    uint public cTime = 0;\n\n    function time() constant returns (uint) {\n        if(cTime > 0) {\n            return cTime;\n        }\n        return block.timestamp;\n    }\n}",
            "label": 0
        },
        "1063": {
            "code": "pragma solidity ^0.4.24;\ncontract InternetWall {\n    struct Message{\n        uint timestamp;\n    }\n\n    Message[10] messages;\n    uint messagesIndex;\n\n    function addMessage() payable returns(uint) {\n        Message memory newMsg;\n        newMsg.timestamp = block.timestamp;\n        messages[messagesIndex] = newMsg;\n        messagesIndex++;\n        return messagesIndex;\n    }\n}",
            "label": 0
        },
        "1064": {
            "code": "pragma solidity ^0.4.24;\ncontract myTime {\n\n    function getBlockTime() constant returns (uint) {\n        return block.timestamp;\n    }\n}",
            "label": 0
        },
        "1065": {
            "code": "pragma solidity ^0.4.24;\ncontract Pixel {\n    struct Section {\n        address owner;\n        uint image_id;\n        string md5;\n        uint last_update;\n        uint16 index;\n    }\n\n    Section[10000] public sections;\n\n    function setImageDataCloud(uint _section_index, uint _image_id, string _md5) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.image_id = _image_id;\n        section.md5 = _md5;\n        section.last_update = block.timestamp;\n        return;\n    }\n}",
            "label": 0
        },
        "1066": {
            "code": "pragma solidity ^0.4.24;\ncontract CardboardUnicornAssembler {\n\n  address public owner = msg.sender;\n  uint public pricePerUnicorn = 1 finney;\n  uint public lastPriceSetDate = 0;\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function setPrice(uint _newPrice) onlyOwner {\n    pricePerUnicorn = _newPrice;\n    lastPriceSetDate = block.timestamp;\n    return;\n  }\n}",
            "label": 0
        },
        "1067": {
            "code": "pragma solidity ^0.4.24;\ncontract FunFairSale {\n    uint public deadline =  1499436000;  \n    uint public startTime = 1498140000;  \n    uint constant MAX_GAS_PRICE = 50 * 1024 * 1024 * 1024 wei;\n\n    function () payable {\n    \tif (tx.gasprice > MAX_GAS_PRICE) throw;\n        if (block.timestamp < startTime || block.timestamp >= deadline) throw;\n        return;\n    }\n}",
            "label": 0
        },
        "1068": {
            "code": "pragma solidity ^0.4.24;\ncontract TimeBank {\n\n    struct Holder {\n        uint withdrawTime;\n    }\n\n    mapping (address => Holder) holders;\n\n    function withdrawFunds() {\n        require(holders[msg.sender].withdrawTime < block.timestamp);\n        holders[msg.sender].withdrawTime = 0;\n        return;\n    }\n}",
            "label": 0
        },
        "1069": {
            "code": "pragma solidity ^0.4.24;\ncontract TimeSource {\n  uint32 private mockNow;\n\n  function currentTime() public constant returns (uint32) {\n    return mockNow > 0 ? mockNow : uint32(block.timestamp);\n  }\n}\n",
            "label": 0
        },
        "1070": {
            "code": "pragma solidity ^0.4.24;\ncontract FunFairSale {\n\n    uint public deadline;\n    uint public capAmount;\n\n    function () payable {\n        if (this.balance >= capAmount) throw;\n        if (this.balance + msg.value >= capAmount) {\n            deadline = block.timestamp;\n        }\n    }\n}",
            "label": 0
        },
        "1071": {
            "code": "pragma solidity ^0.4.24;\ncontract hodlEthereum {\n\n    mapping (address => uint) hodlers;\n    uint constant partyTime = 1596067200;\n\n    function party() {\n        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}",
            "label": 0
        },
        "1072": {
            "code": "pragma solidity ^0.4.24;\ncontract holdEthereum {\n\n    mapping (address => uint) holders;\n    uint constant partyTime = 1596067200;\n\n    function party() {\n        if (block.timestamp < partyTime) throw;\n        uint value = holders[msg.sender];\n        holders[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}",
            "label": 0
        },
        "1073": {
            "code": "pragma solidity ^0.4.24;\ncontract ICO {\n\n    uint public priceToBuyInFinney;\n    mapping (uint => uint[3]) public priceChange;\n\n    function ICO() {\n        priceToBuyInFinney = 0;\n        priceChange[0] = [priceToBuyInFinney, block.number, block.timestamp];\n        return;\n    }\n}",
            "label": 0
        },
        "1074": {
            "code": "pragma solidity ^0.4.24;\ncontract ProofOfExistence {\n\n  mapping (string => uint) private proofs;\n\n  function notarize(string sha256) {\n    if ( bytes(sha256).length == 64 ){\n      if ( proofs[sha256] == 0 ){\n        proofs[sha256] = block.timestamp;\n      }\n    }\n    return;\n  }\n}",
            "label": 0
        },
        "1075": {
            "code": "pragma solidity ^0.4.24;\ncontract HorseFutures {\n\n    mapping(bytes32 => address) owner;\n\n    function sellOffer(uint256 amount, uint256 price, address race, bytes32 horse) external returns (bytes32) {\n        bytes32 id = keccak256(abi.encodePacked(amount,price,race,horse,true,block.timestamp));\n        require(owner[id] == address(0));\n        return id;\n    }\n\n}",
            "label": 1
        },
        "1076": {
            "code": "pragma solidity ^0.4.24;\ncontract ProofOfExistence {\n  mapping (string => uint) private proofs;\n\n  function notarize(string sha256) {\n      if ( proofs[sha256] != 0 ){\n        proofs[sha256] = block.timestamp;\n        return;\n      }\n      return;\n  }\n}",
            "label": 0
        },
        "1077": {
            "code": "pragma solidity ^0.4.24;\ncontract ProofOfExistence {\n  mapping (string => uint) private proofs;\n\n  function storeProof(string sha256) {\n        proofs[sha256] = block.timestamp;\n        return;\n  }\n}",
            "label": 0
        },
        "1078": {
            "code": "pragma solidity ^0.4.24;\ncontract SmartRoulette {\n\n   address profitDistributionContract;\n   uint256 bankrolLimit;\n   uint256 profitLimit;\n   uint256 lastDateDistributedProfit;\n\n   function distributeProfits(uint256 gasValue){\n      if (profitDistributionContract > 0 && this.balance >= (bankrolLimit + profitLimit)) {\n         lastDateDistributedProfit = block.timestamp;\n         return;\n      }\n   }\n}",
            "label": 0
        },
        "1079": {
            "code": "pragma solidity ^0.4.24;\ncontract LegendsCrowdfund {\n    uint public start;\n    uint public limitVIP;\n    mapping (address => uint) public recipientVIP;\n    uint public totalVIP;\n\n\n    function purchaseMembership(address recipient) external payable returns(uint){\n        uint VIP = msg.value * 10;\n        if (block.timestamp - start < 2 weeks) {\n            VIP = (VIP * 10) / 9;\n        }\n        recipientVIP[recipient] += VIP;\n        totalVIP += VIP;\n        if (totalVIP > limitVIP) { throw; }\n        return VIP;\n    }\n}",
            "label": 1
        },
        "1080": {
            "code": "pragma solidity ^0.4.24;\ncontract Omnipurse {\n  struct Contribution {\n    address sender;\n    uint value;\n    bool refunded;\n    uint256 timestamp;\n  }\n  struct Purse {\n    uint8 status;\n    uint numContributions;\n    mapping (uint => Contribution) contributions;\n  }\n  mapping (uint => Purse) purses;\n\n  function contributeToPurse(uint purseId) payable {\n    Purse p = purses[purseId];\n    if (p.status != 1) { throw; }\n    p.contributions[p.numContributions++] = Contribution(msg.sender, msg.value, false, block.timestamp);\n    return;\n  }\n}",
            "label": 0
        },
        "1081": {
            "code": "pragma solidity ^0.4.24;\ncontract Saturn {\n    struct LuckyPending {\n        uint64 block;  \n    }\n    LuckyPending[] public luckyPendings;\n    uint256 public luckyPendingIndex;\n\n    function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {\n        if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n            uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));\n            return _seed > 0;\n        }\n    }\n}",
            "label": 1
        },
        "1082": {
            "code": "pragma solidity ^0.4.24;\ncontract PPBC_API {\n    uint256 private lastBlock;\n    uint256 private lastRandom;\n\n    function createRandomNumber(uint maxnum) returns (uint256) {\n        uint cnt;\n        for (cnt = 0; cnt < lastRandom % 5; cnt++){\n            lastBlock = lastBlock - block.timestamp;\n        }\n        return lastBlock;\n    }\n}",
            "label": 0
        },
        "1083": {
            "code": "pragma solidity ^0.4.24;\ncontract ExpiringMarket{\n\n    function getTime() constant returns (uint) {\n        return block.timestamp;\n    }\n}",
            "label": 0
        },
        "1084": {
            "code": "pragma solidity ^0.4.24;\ncontract Vault {\n    address public owner;\n    uint public withdrawTime;\n\n    function lock(uint duration) public  {\n        withdrawTime = withdrawTime>(block.timestamp + duration) ? withdrawTime:(block.timestamp+duration);\n        return;\n    }\n}",
            "label": 0
        },
        "1085": {
            "code": "pragma solidity ^0.4.24;\ncontract Vault {\n    address public owner;\n    uint public withdrawTime;\n    uint public withdrawAmount;\n    modifier onlyOwner() {\n        if(msg.sender != owner) throw;\n        _;\n    }\n\n    function withdraw() onlyOwner {\n        if(block.timestamp < withdrawTime || withdrawAmount == 0) throw;\n        uint amount = withdrawAmount;\n        withdrawAmount = 0;\n        if(!owner.send(amount)) throw;\n        return;\n    }\n}",
            "label": 1
        },
        "1086": {
            "code": "pragma solidity ^0.4.24;\ncontract ExpiringMarket {\n\n    function getTime() constant returns (uint) {\n        return block.timestamp;\n    }\n}",
            "label": 0
        },
        "1087": {
            "code": "pragma solidity ^0.4.24;\ncontract BirthdayGift {\n    address public recipient;\n    uint public birthday;\n\n    function Take () {\n        if (msg.sender != recipient) throw;\n        if (block.timestamp < birthday) throw;\n        if (!recipient.send (this.balance)) throw;\n        return;\n    }\n}",
            "label": 1
        },
        "1088": {
            "code": "pragma solidity ^0.4.24;\ncontract EscrowContract {\n\n    address public buyer;\n    uint256 public amount;\n    uint256 public fee;\n    uint256 public dispute_end;\n\n    function fifty_fifty() public {\n        if (block.timestamp < dispute_end) throw;\n        uint256 buyer_amount = uint256(amount * 50)/100;\n        buyer_amount = buyer_amount + fee;\n        if (buyer_amount > 0)\n            if (!buyer.send(buyer_amount)) throw;\n        return;\n    }\n}\n",
            "label": 1
        },
        "1089": {
            "code": "pragma solidity ^0.4.24;\ncontract PRNG_Challenge {\n    uint256 public constant lucky_number = 108435827775939881852079940206236050880764931249577763315065068000725104274235;\n    address public winner;\n\n    function challenge() private {\n        address participant = msg.sender;\n        uint64 shift_32 = uint64(4294967296);  \n        uint32 hash32 = uint32(sha3(msg.value,participant,participant.balance,block.blockhash(block.number-1),block.timestamp,block.number));  \n        uint64 hash64 = uint64(hash32) * shift_32 + uint32(sha3(hash32));\n        if (hash64 == lucky_number) {\n            if (!participant.send(this.balance)) throw;\n            winner = participant;\n        }\n        return;\n    }\n}",
            "label": 1
        },
        "1090": {
            "code": "pragma solidity ^0.4.24;\ncontract tickingBomb {\n    struct team {\n        string name;\n        uint lastUpdate;\n        address[] members;\n        uint nbrMembers;\n    }\n    team public red;\n    team public blue;\n\n    function newRound() private {\n        red.name = \"Red team\";\n        blue.name = \"Blue team\";\n        red.lastUpdate = block.timestamp;\n        red.nbrMembers = 0;\n        blue.nbrMembers = 0;\n        red.members = new address[](0);\n        blue.members = new address[](0);\n        return;\n    }\n}",
            "label": 0
        },
        "1091": {
            "code": "pragma solidity ^0.4.24;\ncontract GameOfThrones {\n    address public trueGods;\n    address public jester;\n    uint public lastCollection;\n    uint public kingCost;\n    uint32 public totalCitizens;\n    address public madKing;\n    uint public amountAlreadyPaidBack;\n    uint public amountInvested;\n\n    function GameOfThrones() {\n        trueGods = msg.sender;\n        madKing = msg.sender;\n        jester = msg.sender;\n        lastCollection = block.timestamp;\n        kingCost = 1 ether;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n        return;\n    }\n}",
            "label": 0
        },
        "1092": {
            "code": "pragma solidity ^0.4.24;\ncontract JackPot {\n    uint[] public contributions;\n    address[] public contributors;\n\n    struct Win {\n        address winner;\n        uint timestamp;\n        uint contribution;\n\t\tuint amountWon;\n    }\n\n    Win[] public recentWins;\n    uint recentWinsCount;\n\n    function recordWin(uint winner_index, uint amount) internal {\n        if(recentWins.length < recentWinsCount) {\n            recentWins.length++;\n        }\n        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);\n    }\n}",
            "label": 1
        },
        "1093": {
            "code": "pragma solidity ^0.4.24;\ncontract LastIsMe {\n  address public lastPlayer;\n  uint    public jackpot;\n  uint    public startedAt;\n\n  function buyTicket(address _ref) {\n      if(lastPlayer != 0x0 ) {\n        lastPlayer.send(jackpot);\n        startedAt  = block.timestamp;\n        return;\n      }\n      return;\n  }\n}\n\n",
            "label": 1
        },
        "1094": {
            "code": "pragma solidity ^0.4.24;\ncontract timegame {\n  uint constant TWELEVE_HOURS = 12 * 60 * 60;\n  uint public regeneration;\n\n  function enter() {\n    if (regeneration + TWELEVE_HOURS < block.timestamp) {\n        if (msg.value < 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n    }\n  }\n}\n",
            "label": 1
        },
        "1095": {
            "code": "pragma solidity ^0.4.24;\ncontract Consulting {\n    address public engineer;\n    uint public updatedTime;\n     \n    function payout() returns (bool _success) {\n        if(msg.sender == engineer ) {\n             engineer.send(this.balance / 2);\n             updatedTime = block.timestamp;\n             _success = true;\n        }\n    }\n}",
            "label": 1
        },
        "1096": {
            "code": "pragma solidity ^0.4.24;\ncontract CoinLock {\n    uint public expiration;\n\n    function lock(uint _expiration) returns (bool) {\n        if (_expiration > block.timestamp && expiration == 0) {\n            expiration = _expiration;\n            return true;\n        }\n        return false;\n    }\n}",
            "label": 0
        },
        "1097": {
            "code": "pragma solidity ^0.4.24;\ncontract UselessEthereumToken {\n\n    function() payable {\n        if (msg.value >= 10 finney) {\n            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);\n\n            if (bonusHash[0] == 0) {\n                uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);\n                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;\n            }\n        }\n    }\n}",
            "label": 0
        },
        "1098": {
            "code": "pragma solidity ^0.4.24;\ncontract BZRXv1ConverterMock {\n    uint256 public currentTime;\n\n    function _getTimestamp() internal view returns (uint256){\n        if (currentTime != 0) {\n            return currentTime;\n        } else {\n            return block.timestamp;\n        }\n    }\n}",
            "label": 0
        },
        "1099": {
            "code": "pragma solidity ^0.4.24;\ncontract CollateralManagerState {\n    uint[] public borrowRates;\n    uint public borrowRatesLastUpdated;\n\n    function updateBorrowRates(uint rate) external {\n        borrowRates.push(rate);\n        borrowRatesLastUpdated = block.timestamp;\n        return;\n    }\n}\n",
            "label": 0
        },
        "1100": {
            "code": "pragma solidity ^0.4.24;\ncontract CrowdsaleBase {\n  uint public startsAt;\n  bool public finalized;\n  enum State{ PreFunding, Failure, Finalized}\n\n  function getState() public constant returns (State) {\n    if(finalized) return State.Finalized;\n    else if (block.timestamp < startsAt) return State.PreFunding;\n    else return State.Failure;\n  }\n}\n",
            "label": 1
        },
        "1101": {
            "code": "pragma solidity ^0.4.24;\ncontract DappRegistry {\n    mapping (address => bytes32) public enabledRegistryIds;\n    mapping (uint8 => mapping (address => bytes32)) public authorisations;\n\n    function isAuthorised(address _wallet, address _spender, address _to) external view returns (bool) {\n        uint registries = uint(enabledRegistryIds[_wallet]);\n        for(uint registryId = 0; registryId == 0 || (registries >> registryId) > 0; registryId++) {\n            bool isEnabled = (((registries >> registryId) & 1) > 0) ;\n            if(isEnabled) {\n                uint auth = uint(authorisations[uint8(registryId)][_spender]);\n                uint validAfter = auth & 0xffffffffffffffff;\n\n                if (0 < validAfter && validAfter <= block.timestamp) {\n                    address filter = address(uint160(auth >> 64));\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
            "label": 1
        },
        "1102": {
            "code": "pragma solidity ^0.4.24;\ncontract DebtCache{\n\n    function takeDebtSnapshot() external returns(bool){\n        uint _cacheTimestamp = block.timestamp;\n        if(_cacheTimestamp >= 10)\n            return true;\n        return false;\n    }\n}\n",
            "label": 0
        },
        "1103": {
            "code": "pragma solidity ^0.4.24;\ncontract DeflatingERC20 {\n    address recoveredAddress;\n\n    function permit(address owner, uint deadline) external {\n        require(deadline >= block.timestamp, 'EXPIRED');\n        require(recoveredAddress != address(0) && recoveredAddress == owner);\n    }\n}\n",
            "label": 1
        },
        "1104": {
            "code": "pragma solidity ^0.4.24;\ncontract ExampleSlidingWindowOracle {\n\n    uint public  windowSize;\n    uint public  periodSize;\n\n    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        uint timeElapsed = block.timestamp - 10;\n        require(timeElapsed <= windowSize);\n        require(timeElapsed >= windowSize - periodSize * 2);\n    }\n}\n",
            "label": 1
        },
        "1105": {
            "code": "pragma solidity ^0.4.24;\ncontract UserAuth {\n    address public owner;\n    address public pendingOwner;\n    uint public claimOnwershipTime = 5;\n\n    function setOwner() public {\n        require(pendingOwner != address(0));\n        require(block.timestamp > claimOnwershipTime);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n",
            "label": 0
        },
        "1106": {
            "code": "pragma solidity ^0.4.24;\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        address etherAddress;\n        string name;\n        uint claimPrice;\n        uint coronationTimestamp;\n    }\n    address wizardAddress;\n    uint constant startingClaimPrice = 100 finney;\n    uint public currentClaimPrice;\n    Monarch public currentMonarch;\n\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(wizardAddress, \"[Vacant]\", 0, block.timestamp);\n    }\n}\n",
            "label": 0
        },
        "1107": {
            "code": "pragma solidity ^0.4.24;\ncontract Kleros{\n    uint[5] public timePerPeriod;\n    uint public lastPeriodChange = 2;\n    uint public period = 1;\n\n    function passPeriod() public {\n        require(block.timestamp - lastPeriodChange >= timePerPeriod[uint8(period)]);\n    }\n}\n",
            "label": 1
        },
        "1108": {
            "code": "pragma solidity ^0.4.24;\ncontract LoanOpenings {\n\n    function _finalizeOpen(){\n        uint256 startTimestamp = now;\n        uint256 isTorqueLoan = 4;\n        uint256 collateralToLoanRate = 5;\n        uint256 startRate;\n\n        if (startTimestamp == block.timestamp) {\n            if (isTorqueLoan != 0) {\n               startRate = collateralToLoanRate;\n            } else {\n               startRate = 0;\n            }\n        }\n    }\n}\n",
            "label": 0
        },
        "1109": {
            "code": "pragma solidity ^0.4.24;\ncontract LoanTokenLogicStandard{\n\n    function tokenPrice()public view returns (uint256)  {\n        uint256 lastSettleTime_;\n        if (lastSettleTime_ != uint88(block.timestamp)) {\n            return lastSettleTime_;\n        }\n        return 0;\n    }\n}",
            "label": 1
        },
        "1110": {
            "code": "pragma solidity ^0.4.24;\ncontract LockedTokenVault{\n    uint256 public _START_RELEASE_TIME_;\n\n    function isReleaseStart() external view returns (bool) {\n        return block.timestamp >= _START_RELEASE_TIME_;\n    }\n}\n",
            "label": 1
        },
        "1111": {
            "code": "pragma solidity ^0.4.24;\ncontract mockOVM_CrossDomainMessenger{\n    struct ReceivedMessage {\n        uint256 timestamp;\n        address sender;\n    }\n    ReceivedMessage[] internal fullReceivedMessages;\n    uint256 internal lastRelayedMessage;\n    uint256 internal delay;\n    address  public xDomainMessageSender;\n\n    function relayNextMessage() public {\n        ReceivedMessage memory nextMessage = fullReceivedMessages[lastRelayedMessage];\n        require(nextMessage.timestamp + delay < block.timestamp);\n        xDomainMessageSender = nextMessage.sender;\n        lastRelayedMessage += 1;\n    }\n}\n",
            "label": 1
        },
        "1112": {
            "code": "pragma solidity ^0.4.24;\n contract NBUNIERC20 {\n\n    uint256 public contractStartTimestamp = now;\n\n    function getSecondsLeftInLiquidityGenerationEvent() public view returns (uint256) {\n         return contractStartTimestamp + (7 days) - (block.timestamp);\n    }\n}\n",
            "label": 0
        },
        "1113": {
            "code": "pragma solidity ^0.4.24;\ncontract SaiVox {\n\n    function era() public view returns (uint) {\n        return block.timestamp;\n    }\n}\n",
            "label": 0
        },
        "1114": {
            "code": "pragma solidity ^0.4.24;\ncontract ShortingRewards{\n    uint256 public rewardRate = 2;\n    uint256 public periodFinish = 0;\n    uint256 rewardsDuration = 2;\n\n    function notifyRewardAmount(uint256 reward) public {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            rewardRate = (reward + 100) / (rewardsDuration);\n        }\n        return;\n    }\n}\n",
            "label": 0
        },
        "1115": {
            "code": "pragma solidity ^0.4.24;\ncontract StakingV1 {\n\n    function vestedBalanceForAmount(uint256 vestingEndTime) public view returns (uint256 vested){\n        vestingEndTime = vestingEndTime - block.timestamp;\n        vested = vestingEndTime * 20;\n        return vested;\n    }\n}\n",
            "label": 0
        },
        "1116": {
            "code": "pragma solidity ^0.4.24;\ncontract TimeLockedToken {\n\n    uint256 constant LOCK_START = 1595609911;\n    uint256 constant FIRST_EPOCH_DELAY = 30 days;\n    uint256 constant EPOCH_DURATION = 90 days;\n    uint256 constant TOTAL_EPOCHS = 8;\n\n    function epochsPassed() public view returns (uint256) {\n        uint256 timePassed = block.timestamp - LOCK_START;\n        if (timePassed < FIRST_EPOCH_DELAY) {\n            return 0;\n        }\n        uint256 totalEpochsPassed =(timePassed-FIRST_EPOCH_DELAY)/(EPOCH_DURATION);\n        if (totalEpochsPassed > TOTAL_EPOCHS) {\n            return TOTAL_EPOCHS;\n        }\n        return totalEpochsPassed;\n    }\n\n}\n",
            "label": 0
        },
        "1117": {
            "code": "pragma solidity ^0.4.24;\ncontract TmpAdminInterestSettlemen {\n    uint256 endTimestamp =10;\n    uint256 itemCount = 4;\n\n    function tmpSettleFeeRewards () returns (bool){\n        uint256 interestTime = block.timestamp;\n        if (interestTime > endTimestamp) {\n            interestTime = endTimestamp;\n            itemCount++;\n        }\n        if (itemCount > 0) {\n            return true;\n        }\n    }\n}\n",
            "label": 0
        },
        "1118": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenPriceRegistry{\n    uint256 public minPriceUpdatePeriod = 10;\n\n    function setPriceForTokenList() {\n        uint64 updatedAt = 10;\n        require(updatedAt == 0 || block.timestamp >= updatedAt + minPriceUpdatePeriod);\n    }\n}",
            "label": 0
        },
        "1119": {
            "code": "pragma solidity ^0.4.24;\ncontract TransactionManager{\n\n    function addToWhitelist(address _wallet, address _target) returns (uint256){\n        uint256 whitelistPeriod = 10;\n        uint256 whitelistAfter = block.timestamp + whitelistPeriod;\n        return whitelistAfter;\n    }\n}",
            "label": 0
        },
        "1120": {
            "code": "pragma solidity ^0.4.24;\ncontract SnooKarma {\n    uint public totalSupply = 0;\n\n    function redeem(uint karma, uint sigExp) public returns (uint) {\n        require(block.timestamp < sigExp);\n        totalSupply = totalSupply + karma;\n        return totalSupply;\n    }\n}",
            "label": 0
        },
        "1121": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable {\n    uint256 public totalAmount;\n\n    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {\n        require(block.timestamp < _timestamp);\n        totalAmount = totalAmount + _value;\n        return totalAmount;\n    }\n}",
            "label": 0
        },
        "1122": {
            "code": "pragma solidity ^0.4.24;\ncontract DSNote {\n\n    function time() public constant returns (uint) {\n        return block.timestamp;\n    }\n}",
            "label": 0
        },
        "1123": {
            "code": "pragma solidity ^0.4.24;\ncontract CrowdsaleExt {\n    uint public startsAt;\n    enum State {PreFunding, Failure}\n\n    function getState() public constant returns (State) {\n        if (block.timestamp < startsAt) return State.PreFunding;\n        else return State.Failure;\n    }\n}",
            "label": 1
        },
        "1124": {
            "code": "pragma solidity ^0.4.24;\ncontract TydoIco {\n  uint256[] public bonuses;\n  uint256[] public bonusEnds;\n\n  function getBonus() public view returns(uint256 _currentBonus) {\n    uint256 curTime = block.timestamp;\n    for(uint8 i = 0; i < bonuses.length; i++) {\n      if(bonusEnds[i] > curTime) {\n        return bonuses[i];\n      }\n    }\n    return 0;\n  }\n}",
            "label": 1
        },
        "1125": {
            "code": "pragma solidity ^0.4.24;\ncontract TimedCrowdsale  {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "1126": {
            "code": "pragma solidity ^0.4.24;\ncontract MMOToken{\n    mapping (address => uint256) public lockAddress;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {\n       if(_value > block.timestamp) {\n            lockAddress[_to] = _value;\n            return true;\n       }\n       return false;\n    }\n}",
            "label": 1
        },
        "1127": {
            "code": "pragma solidity ^0.4.24;\ncontract MMOToken{\n    mapping (address => uint256) public lockAddress;\n\n    function lockTime(address _to,uint256 _value) public returns (bool) {\n       if(_value > block.timestamp) {\n            lockAddress[_to] = _value;\n            return true;\n       }\n       return false;\n    }\n}",
            "label": 0
        },
        "1128": {
            "code": "pragma solidity ^0.4.24;\ncontract TMTG {\n    uint256 public openingTime;\n\n    function setOpeningTime() public returns (bool) {\n        openingTime = block.timestamp;\n        return true;\n    }\n}",
            "label": 0
        },
        "1129": {
            "code": "pragma solidity ^0.4.24;\ncontract TMTG {\n    uint256 public openingTime;\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setOpeningTime() onlyOwner public returns(bool) {\n        openingTime = block.timestamp;\n        return false;\n    }\n}",
            "label": 0
        },
        "1130": {
            "code": "pragma solidity ^0.4.24;\ncontract GameTestToken {\n  mapping(address => TimeLock[]) public allocations;\n  \n  struct TimeLock {\n      uint time;\n      uint256 balance;\n  }\n\n  function subAllocation(address sender) private returns(bool){\n      for (uint j = 0; j < allocations[sender].length; j++) {\n          if (allocations[sender][j].time < block.timestamp) {\n                allocations[sender][j].balance = 0;\n                return true;\n          }\n      }\n      return false;\n  }\n}",
            "label": 0
        },
        "1131": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenTimelock {\n\n  uint256 public releaseTime;\n\n  function release() public returns (bool) {\n    require(block.timestamp >= releaseTime);\n    return true;\n  }\n}\n",
            "label": 1
        },
        "1132": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC20 {\n  function balanceOf(address to) public returns (uint256);\n}\n\ncontract TokenLocker {\n    \n    ERC20 public token = ERC20(0x611171923b84185e9328827CFAaE6630481eCc7a);\n    uint256 public releaseTimeFund = 1537833600;  \n    uint public ReserveFundAmount = 18600000 ether;\n    \n    function unlockFund () public returns (bool){\n        require(releaseTimeFund <= block.timestamp);\n        require(ReserveFundAmount > 0);\n        uint tokenBalance = token.balanceOf(this);\n        require(tokenBalance >= ReserveFundAmount);\n        return false;\n    }\n}",
            "label": 1
        },
        "1133": {
            "code": "pragma solidity ^0.4.24;\ncontract Eurufly {\n      uint256 public prePreIcoStartAt;\n      address public owner;\n\n      modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n      }\n\n    enum STATE{ PREPREICO }\n\n    STATE public state;\n\n    function startPrePreIco() public onlyOwner returns (STATE) {\n        prePreIcoStartAt = block.timestamp;\n        state = STATE.PREPREICO;\n        return state;\n    }\n}",
            "label": 0
        },
        "1134": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenTimelockVault {\n    mapping(address => TimeEnvoy) internal owners;\n\n    struct TimeEnvoy {\n        uint releaseTime;\n        uint balance;\n    }\n\n    function releasableAmount(address _owner) public view returns (uint256){\n        TimeEnvoy storage owner = owners[_owner];\n        if (block.timestamp >= owner.releaseTime) {\n            return owner.balance;\n        }\n    }\n}",
            "label": 1
        },
        "1135": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n\n    function buyTokens() payable returns (bool){\n        require(block.timestamp < deadline && tokenPrice > 0);\n        return true;\n    }\n}",
            "label": 1
        },
        "1136": {
            "code": "pragma solidity ^0.4.24;\ncontract DaddyToken{\n    uint256 public totalBonusTokensIssued = 0;\n\n    function() payable public {\n        bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);\n        if (bonusHash[0] == 0) {\n            uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);\n            uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;\n            totalBonusTokensIssued += bonusTokensIssued;\n        }\n    }\n}",
            "label": 0
        },
        "1137": {
            "code": "pragma solidity ^0.4.24;\n\ncontract Crowdsale {\n\n    uint256 public bonusDeliverTime;\n    uint256 public bonusUnsold;\n\n    function returnBonus() external returns (uint) {\n        require(block.timestamp > bonusDeliverTime);\n        require(bonusUnsold > 0);\n        return bonusUnsold;\n    }\n\n}",
            "label": 1
        },
        "1138": {
            "code": "pragma solidity ^0.4.24;\n contract DividendPool {\n\n    uint256 public totalDividents = 0;\n\n    function startDividents(uint256 from, uint256 amount) external {\n      require(from > block.timestamp);\n      require(amount > 0);\n      totalDividents = amount;\n    }\n}",
            "label": 0
        },
        "1139": {
            "code": "pragma solidity ^0.4.24;\ncontract UniswapV2Pair {\n\n    uint32  private blockTimestampLast;  \n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n        if (timeElapsed > 0 ) {\n            price0CumulativeLast += _reserve0 * timeElapsed;\n            price1CumulativeLast += _reserve1 * timeElapsed;\n        }\n    }\n}",
            "label": 1
        },
        "1140": {
            "code": "pragma solidity ^0.4.24;\ncontract UniswapV2Pair {\n\n    uint112 private reserve0;            \n    uint112 private reserve1;            \n    uint32  private blockTimestampLast;  \n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            price0CumulativeLast += _reserve0 * timeElapsed;\n            price1CumulativeLast += _reserve1 * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        return;\n    }\n}",
            "label": 1
        },
        "1141": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenMintPoD {\n\n  uint256 public lockTime;\n\n  function getBalanceOfToken() public constant returns (uint256) {\n    if (block.timestamp <= lockTime)\n        return lockTime;\n  }\n}\n",
            "label": 1
        },
        "1142": {
            "code": "pragma solidity ^0.4.24;\ncontract EtherFarm {\n\n    struct User {\n        uint256 payouts;\n        uint256 deposit_amount;\n        uint256 deposit_payouts;\n    }\n\n    mapping(address => User) public users;\n    uint256 public divisor = 60;\n\n    function payoutOf(address _addr) view external returns(uint256 payout, uint256 max_payout) {\n        max_payout = 100;\n\n        if(users[_addr].deposit_payouts < max_payout) {\n            payout = (users[_addr].deposit_amount * block.timestamp / 1 days) ;\n\n            if(users[_addr].deposit_payouts + payout > max_payout) {\n                payout = max_payout - users[_addr].deposit_payouts;\n            }\n        }\n    }\n}",
            "label": 1
        },
        "1143": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC200 {\n\n    struct InvestorLock {\n        uint amount;\n    }\n\n    uint startsAt;\n\n    mapping(address => InvestorLock) private _investorLocks;\n    uint investorLockedAmount = 0;\n\n    function getInvestorLockedAmount(address account) public view returns (uint) {\n        uint amount = _investorLocks[account].amount;\n        if (amount > 0) {\n          uint timestamp = block.timestamp;\n          if (timestamp <= startsAt) {\n            return investorLockedAmount;\n          }\n        }\n    }\n}\n",
            "label": 1
        },
        "1144": {
            "code": "pragma solidity ^0.4.24;\n\ncontract DutchSwapAuction  {\n    uint256 public startDate;\n    uint256 public priceDrop;\n\n    function _currentPrice() private view returns (uint256) {\n        uint256 elapsed = block.timestamp - startDate;\n        uint256 priceDiff = elapsed * priceDrop;\n        return priceDiff;\n    }\n}",
            "label": 0
        },
        "1145": {
            "code": "pragma solidity ^0.4.24;\n\ncontract KingOfTheHill {\n    uint public withdrawDelay;\n\n    function takeAll() public {\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(this.balance);\n    }\n}",
            "label": 1
        },
        "1146": {
            "code": "pragma solidity ^0.4.24;\ncontract ShortingRewards{\n    uint256 public rewardRate = 2;\n    uint256 public periodFinish = 0;\n    uint256 rewardsDuration = 2;\n\n    function notifyRewardAmount(uint256 reward) public {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            rewardRate = (reward + rewardRate) / (rewardsDuration);\n        }\n    }\n}\n",
            "label": 0
        },
        "1147": {
            "code": "pragma solidity ^0.4.24;\ncontract COD {\n\n    mapping(address => uint) balances;\n\n    function burn (uint256 _burntAmount) public returns (bool success) {\n    \trequire(balances[msg.sender] >= _burntAmount && block.timestamp > 10);\n    \treturn true;\n\t}\n}",
            "label": 1
        },
        "1148": {
            "code": "pragma solidity ^0.4.24;\n\ncontract TokenTimelock {\n\n    uint256 public cliffPeriod;\n    uint256 public chunksAlreadyVested;\n\n   function release() public returns (uint256){\n    uint256 chunksNeeded = (block.timestamp - (cliffPeriod));\n    if (chunksNeeded > 10) {\n        chunksNeeded = 10;\n    }\n    chunksAlreadyVested = chunksNeeded;\n    return chunksAlreadyVested;\n  }\n}",
            "label": 1
        },
        "1149": {
            "code": "pragma solidity ^0.4.24;\ncontract ParkadeCoinCrowdsale {\n  uint256 public firstBonusRate = 1838;\n  uint256 public normalRate = 1470;\n  uint256 public firstBonusEnds = 1535155200;\n\n  function currentRate() public view returns (uint256) {\n    if (block.timestamp < firstBonusEnds) {\n        return firstBonusRate;\n    }\n    else {\n         return normalRate;\n    }\n  }\n}",
            "label": 0
        },
        "1150": {
            "code": "pragma solidity ^0.4.24;\ncontract Lock {\n\n    mapping(address => uint256) public teamLockTime;\n\n    function teamAvailable(address _to) internal constant returns (uint256) {\n\n        uint256 now1 = block.timestamp;\n        uint256 lockTime = teamLockTime[_to];\n        uint256 time = now1 - (lockTime);\n        uint256 percent = 0;\n\n        if(time >= 365 days) {\n           percent = (time / (30 days)) + (1);\n        }\n\n        uint256 avail = avail * (percent) / (12) ;\n        return avail;\n    }\n}",
            "label": 1
        },
        "1151": {
            "code": "pragma solidity ^0.4.24;\ncontract DSEasyMultisig {\n\n    struct action {\n        uint confirmations;  \n        uint expiration;  \n    }\n    mapping( uint => action ) actions;\n\n    function trigger(uint action_id) returns (bool){\n        var a = actions[action_id];\n        if(block.timestamp > a.expiration) { throw; }\n        return true;\n    }\n}",
            "label": 1
        },
        "1152": {
            "code": "pragma solidity ^0.4.24;\ncontract game {\n\n    mapping (address => uint) readyTime;\n\n    function view_readyTime(address _address) view public returns(uint _readyTime){\n        uint time = block.timestamp;\n\n        if (time >= readyTime[_address]){\n            return 0 ;\n        }\n        else{\n            return readyTime[_address] - time ;\n        }\n    }\n}",
            "label": 1
        },
        "1153": {
            "code": "pragma solidity ^0.4.24;\ncontract FanCrowdsale {\n  uint256 public closingTime;\n\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}",
            "label": 1
        },
        "1154": {
            "code": "pragma solidity ^0.4.24;\ncontract ERC20Like {\n    mapping(address => Account) internal accounts;\n\n    struct DirectDebitInfo {\n        uint256 startTime;\n    }\n    struct DirectDebit {\n        DirectDebitInfo info;\n        uint256 epoch;\n    }\n    struct Instrument {\n        DirectDebit directDebit;\n    }\n    struct Account {\n        mapping (address => Instrument) instruments;\n    }\n\n    function withdrawDirectDebit(address debtor) public returns (bool) {\n        Account storage debtorAccount = accounts[debtor];\n        DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n        uint256 epoch = (block.timestamp - debit.info.startTime) + 1;\n        uint256 amount = epoch - (debit.epoch);\n        require(amount > 0);\n        return true;\n    }\n}",
            "label": 1
        },
        "1155": {
            "code": "pragma solidity ^0.4.24;\ncontract FreyrTokenLocker {\n\n    uint256 public releaseTime;\n\n    function secondsRemaining() public constant returns (uint timestamp) {\n        if (block.timestamp < releaseTime)\n            return releaseTime;\n        else\n            return 0;\n    }\n}",
            "label": 1
        },
        "1156": {
            "code": "pragma solidity ^0.4.24;\ncontract NGOTVesting {\n    uint256 public lockStartTime;\n    mapping(address => uint256) public stageSettings;\n\n    function vestStage() public view returns(uint256){\n        uint256 stage = block.timestamp - lockStartTime;\n\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}",
            "label": 1
        },
        "1157": {
            "code": "pragma solidity ^0.4.24;\ncontract ProVisionRaffle {\n    address[] public Raffle_Entries;\n\n    function random() private view returns (uint8) {\n        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % Raffle_Entries.length);\n    }\n}",
            "label": 0
        },
        "1158": {
            "code": "pragma solidity ^0.4.24;\ncontract JadeCoin {\n\n  uint256 public nextSnapshotTime;\n\n  function snapshotDailyGooResearchFunding() external returns (bool){\n    nextSnapshotTime = block.timestamp + 24 hours;\n    return true;\n  }\n}",
            "label": 0
        },
        "1159": {
            "code": "pragma solidity ^0.4.24;\ncontract BulletinBoard {\n    struct Message {\n        address sender;\n        string text;\n        uint timestamp;\n        uint amount;\n    }\n\n    Message[] public messages;\n    function addMessage(string text) public payable returns (bool) {\n        messages.push(Message(msg.sender, text, block.timestamp, msg.value));\n        return true;\n    }\n}",
            "label": 0
        },
        "1160": {
            "code": "pragma solidity ^0.4.24;\ncontract MINEA {\n\n    uint private randomNumber;\n    mapping (address => uint256) public successesOf;\n\n    function () external payable {\n        randomNumber += block.timestamp;\n        uint minedAtBlock = uint(block.blockhash(block.number - 1));\n        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber)) % 10000000;\n        if (block.timestamp < minedHashRel) {\n            successesOf[msg.sender]++;\n        }\n    }\n}",
            "label": 1
        },
        "1161": {
            "code": "pragma solidity ^0.4.24;\ncontract VestingToken {\n\n  struct Vesting {\n    uint256 start;           \n    uint256 cliff;\n  }\n  mapping(address => Vesting) public vestings;\n\n  function vestedAmount(address _beneficiary) public view returns (uint256) {\n    Vesting storage vesting = vestings[_beneficiary];\n\n    if (block.timestamp < vesting.start + vesting.cliff) {\n        return block.timestamp;\n    }\n  }\n}",
            "label": 1
        },
        "1162": {
            "code": "pragma solidity ^0.4.24;\ncontract VestingToken {\n\n  struct Vesting {\n    uint256 start;           \n    uint256 totalAmount;\n  }\n\n  mapping(address => Vesting) public vestings;\n\n  function vestedAmount(address _beneficiary) public view returns (uint256) {\n    Vesting storage vesting = vestings[_beneficiary];\n    uint time = block.timestamp;\n\n    if (time >= vesting.start) {\n        return vesting.totalAmount * time;\n    }\n  }\n}",
            "label": 1
        },
        "1163": {
            "code": "pragma solidity ^0.4.24;\ncontract JadeCoin {\n  mapping(address => uint256) public jadeBalance;\n  mapping(address => uint256) public lastJadeSaveTime;  \n\n  function updatePlayersCoinByOut(address player) external returns (bool){\n    lastJadeSaveTime[player] = block.timestamp;\n    jadeBalance[player] = jadeBalance[player] + 100;\n    return true;\n  }\n}",
            "label": 0
        },
        "1164": {
            "code": "pragma solidity ^0.4.24;\ncontract DutchAuction {\n\tevent BidSubmission(\n        address indexed sender,\n        uint amount,\n        uint missingFunds,\n        uint timestamp\n    );\n\n    function bid() public payable returns (bool){\n        uint missingFunds = 100;\n        BidSubmission(msg.sender, msg.value, missingFunds, block.timestamp);\n        return true;\n    }\n}",
            "label": 0
        },
        "1165": {
            "code": "pragma solidity ^0.4.24;\ncontract LemoCoin {\n    struct FreezingNode {\n        uint end_stamp;\n    }\n    mapping(address => FreezingNode[]) internal c_freezing_list;\n    uint total_lemos = 100;\n\n    function validBalanceOf(address addr) constant public returns (uint) {\n        FreezingNode[] memory nodes = c_freezing_list[addr];\n        for (uint i = 0; i < nodes.length; ++i) {\n            if (nodes[i].end_stamp > block.timestamp) {\n                total_lemos = total_lemos - nodes[i].end_stamp;\n            }\n        }\n        return total_lemos;\n    }\n}",
            "label": 1
        },
        "1166": {
            "code": "pragma solidity ^0.4.24;\ncontract DVPlock {\n  address public sponsor;\n  mapping (address => uint256) public balances;\n  mapping (address => uint256) public withdrawAmounts;\n  uint256 _amount = 0;\n  uint256 lock_quarter = 0;\n\n  function release() public returns (bool) {\n    uint256 released_times = block.timestamp / (60*60*24*30*3);\n\n    if (released_times >= lock_quarter) {\n        _amount = balances[msg.sender];\n    } else {\n        _amount = balances[msg.sender] - (withdrawAmounts[msg.sender] * lock_quarter);\n    }\n    return true;\n  }\n}",
            "label": 1
        },
        "1167": {
            "code": "pragma solidity ^0.4.24;\ncontract DVPlock {\n  uint256 public releaseTime;\n  \n  function release() public returns (bool) {\n    require(block.timestamp >= releaseTime);\n    return true;\n  }\n}",
            "label": 1
        },
        "1168": {
            "code": "pragma solidity ^0.4.24;\ncontract XTVToken {\n  uint public endTime;\n  uint public XTVBurned;\n  mapping(address => uint256) balances;\n\n  function burnTokens() public returns (uint){\n    require(block.timestamp > endTime);\n    uint256 remaining = balances[address(0)];\n    XTVBurned = remaining;\n    return XTVBurned;\n  }\n}",
            "label": 1
        },
        "1169": {
            "code": "pragma solidity ^0.4.24;\ncontract CryptualProjectToken {\n  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];\n  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];\n  uint256 currentCap = 0;\n\n  function getCrowdsaleUserCap() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - (100);\n\n    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {\n      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])\n        continue;\n      currentCap = crowdsaleUserCaps[i];\n    }\n    return currentCap;\n  }\n}",
            "label": 0
        },
        "1170": {
            "code": "pragma solidity ^0.4.24;\n\ncontract ERC20TokenInterface {\n    function balanceOf (address tokenOwner) external constant returns (uint balance);\n}\n\n \ncontract TwoYearDreamTokensVesting {\n\n    uint256 public vestingStartUnixTimestamp;\n\n    function initializeVestingFor (address account) external returns (uint256) {\n        vestingStartUnixTimestamp = block.timestamp;\n        return vestingStartUnixTimestamp;\n    }\n}",
            "label": 0
        },
        "1171": {
            "code": "pragma solidity ^0.4.24;\ncontract PitEur{\n  mapping(address => uint256) releaseTimes;\n\n  function isLocked(address _spender) public view returns (bool) {\n    if (releaseTimes[_spender] <= block.timestamp) {\n        return false;\n    }\n    return true;\n  }\n}",
            "label": 1
        },
        "1172": {
            "code": "pragma solidity ^0.4.24;\ncontract H2OC {\n    uint256 public totalToken;\n\n    function burn (uint256 _burntAmount) public returns (bool success) {\n    \ttotalToken = totalToken - _burntAmount + block.timestamp;\n    \treturn true;\n\t}\n}",
            "label": 0
        },
        "1173": {
            "code": "pragma solidity ^0.4.24;\ncontract FENIX {\n    uint256 public ico_startdate;\n    uint bonusCalculationFactor;\n    uint price_tokn;\n\n    function getCurrentTokenPrice() private returns (uint) {\n\n        bonusCalculationFactor = (block.timestamp - (ico_startdate)) / (3600);\n\n        if (bonusCalculationFactor== 0) \n            price_tokn = 70;\n            return price_tokn;\n     }\n}",
            "label": 1
        },
        "1174": {
            "code": "pragma solidity ^0.4.24;\ncontract KcashVesting {\n    uint256 public lockStartTime;\n\n    mapping(address => uint256) public stageSettings;\n    mapping(address => uint256) public timeLockDurations;\n\n    function vestStage() public view returns(uint256){\n        uint256 vestingMonths = 100;\n        uint256 stage = (block.timestamp - (lockStartTime)) / (vestingMonths);\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}",
            "label": 1
        },
        "1175": {
            "code": "pragma solidity ^0.4.24;\ncontract Token {\n    mapping(address => uint256) public balances;\n\n    function unfreezeFoundingTeamBalance() public returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return 0;\n    }\n}\n",
            "label": 0
        },
        "1176": {
            "code": "pragma solidity ^0.4.24;\ncontract Token {\n    address public owner;\n    mapping(address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner || msg.sender == 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8);\n        _;\n    }\n\n    function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];\n    }\n}\n",
            "label": 1
        },
        "1177": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale {\n    uint256 constant public MAXSALESCAP = 126000 ether;\n    uint256 public weiRaised;\n\n    enum State { Funded }\n    State public state;\n\n    function buyTokens() public payable returns (bool success) {\n        if (weiRaised >= MAXSALESCAP || block.timestamp >= MAXSALESCAP) {\n            state = State.Funded;\n        }\n        return true;\n    }\n}",
            "label": 1
        },
        "1178": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale {\n    uint256 constant public STARTDATE = 1533686401;\n\n    function buyTokens() public payable returns (bool success) {\n        assert(block.timestamp >= STARTDATE);\n        return true;\n    }\n}",
            "label": 0
        },
        "1179": {
            "code": "pragma solidity ^0.4.24;\ncontract SponsoredItemGooRaffle {\n    uint256 private raffleTicketsBought;\n    uint256 private raffleTicketThatWon;\n\n    function drawRandomWinner() public returns (uint256) {\n        uint256 seed = raffleTicketsBought + block.timestamp;\n        raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1));\n        return raffleTicketThatWon;\n    }\n}",
            "label": 0
        },
        "1180": {
            "code": "pragma solidity ^0.4.24;\ncontract GStarCrowdsale {\n    uint256 constant public startTime = 1532260800;\n    uint256 rate = 100;\n\n    function getRate() public view returns (uint256) {\n        if (block.timestamp <= startTime) {\n            return ((rate / 100) * 120);\n        }\n        return rate;\n    }\n}",
            "label": 0
        },
        "1181": {
            "code": "pragma solidity ^0.4.24;\ncontract EtheremonEnergy {\n    \n    struct Energy {\n        uint lastClaim;\n    }\n    \n    mapping(address => Energy) energyData;\n    uint public claimTime = 30 * 60;\n    uint public claimAmount = 1;\n\n    function getClaimableAmount(address _trainer) constant external returns(uint) {\n        Energy storage energy = energyData[_trainer];\n        uint period = block.timestamp + energy.lastClaim;\n        uint energyAmount = (period / claimTime) * claimAmount;\n        if (energyAmount > claimAmount)\n            energyAmount = claimAmount;\n        return energyAmount;\n    }\n}",
            "label": 1
        },
        "1182": {
            "code": "pragma solidity ^0.4.24;\ncontract MLBNFT {\n    uint public isAttached = 10;\n\n    function requestDetachment(uint256 _tokenId) public returns (uint) {\n        if(isAttached > 1) {\n            require(isAttached == 1);\n        } else {\n            isAttached = block.timestamp;\n        }\n        return isAttached;\n    }\n}",
            "label": 0
        },
        "1183": {
            "code": "pragma solidity ^0.4.24;\ncontract MLBNFT {\n    uint32 public detachmentTime = 0;\n    uint public isAttached = 10;\n\n    function requestDetachment(uint256 _tokenId) public returns (uint) {\n        if(block.timestamp - isAttached > detachmentTime) {\n            isAttached = 0;\n        } else {\n            require (isAttached == 1);\n        }\n        return isAttached;\n    }\n}",
            "label": 0
        },
        "1184": {
            "code": "pragma solidity ^0.4.24;\ncontract ESSENTIA_PE {\n    uint256 public pubEnd = 0;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function EMGwithdraw(uint256 weiValue) external onlyOwner returns (bool){\n        require(block.timestamp > pubEnd);           \n        require(weiValue > 0);\n        return true;\n    }\n}",
            "label": 1
        },
        "1185": {
            "code": "pragma solidity ^0.4.24;\ncontract ESSENTIA_PE {\n    uint256 public pubEnd = 0;\n\n    function EMGwithdraw(uint256 weiValue) external returns (bool){\n        require(block.timestamp > pubEnd);           \n        require(weiValue > 0);\n        return true;\n    }\n}",
            "label": 0
        },
        "1186": {
            "code": "pragma solidity ^0.4.24;\ncontract tipbot {\n    struct transferInStruct{\n        uint256 amount;\n        uint64 time;\n    }\n\n    mapping(address => uint256) balances;\n    mapping(address => transferInStruct[]) transferIns;\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        uint64 _now = uint64(block.timestamp);\n        transferIns[_from].push(transferInStruct(uint256(balances[_from]),_now));\n        transferIns[_to].push(transferInStruct(uint256(_value),_now));\n        return true;\n    }\n}",
            "label": 0
        },
        "1187": {
            "code": "pragma solidity ^0.4.24;\ncontract Inner4WithEth {\n    uint256 someValue;\n\n    function doSomething() public payable {\n        someValue = block.timestamp;\n    }\n}",
            "label": 0
        },
        "1188": {
            "code": "pragma solidity ^0.4.24;\ncontract CHAltar {\n  uint256 public genesis;\n\n  function _getCurrentAltarRecordId() internal view returns (uint256) {\n    return (block.timestamp - genesis) / 86400;\n  }\n}",
            "label": 0
        },
        "1189": {
            "code": "pragma solidity ^0.4.24;\ncontract Fomo {\n    uint256 public airDropTracker_ = 0;\n\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / (now) )));\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n            return(true);\n        else\n            return(false);\n    }\n}",
            "label": 0
        },
        "1190": {
            "code": "pragma solidity ^0.4.24;\ncontract YunMint {\n    uint    public cycleCount = 0;\n    uint256 public firstReleaseAmount;\n    uint256 public createTime = 0;\n\n    function YunMin(address _operator) public returns(uint256){\n        createTime = block.timestamp;\n        cycleCount = createTime;\n        firstReleaseAmount = 200000 * (10 ** 8);\n        return firstReleaseAmount + cycleCount;\n    }\n}",
            "label": 0
        },
        "1191": {
            "code": "pragma solidity ^0.4.24;\ncontract TokenOffering {\n\n    uint256 public startTime;\n    uint256 public endTime;\n\n    function updateStartTime(uint256 _startTime) public {\n        require(_startTime <= endTime);\n        require(_startTime >= block.timestamp);\n    }\n}",
            "label": 1
        },
        "1192": {
            "code": "pragma solidity ^0.4.24;\ncontract RakuRakuEth {\n  function getCurrentTimestamp () external view returns (uint256) {\n    return block.timestamp;\n  }\n}",
            "label": 0
        },
        "1193": {
            "code": "pragma solidity ^0.4.24;\ncontract wbcSale {\n    function blockTime() public view returns (uint32) {\n        return uint32(block.timestamp);\n    }\n}",
            "label": 0
        },
        "1194": {
            "code": "pragma solidity ^0.4.24;\ncontract Crowdsale {\n  uint public startsAt;\n\n  function getCurrentFgcCap() public constant returns (uint) {\n    uint timeSinceStart = block.timestamp - (startsAt);\n    uint currentPeriod = timeSinceStart / (1 days) + (1);\n\n    if (currentPeriod < 2) {\n        return 5000 * 10** currentPeriod;\n    }\n    return 0;\n  }\n}",
            "label": 1
        },
        "1195": {
            "code": "pragma solidity ^0.4.24;\ncontract Tokenlock {\n    uint256 public interval;\n    uint256 public releaseTime;\n\n    function start() external returns (uint256){\n        uint time = block.timestamp;\n        releaseTime = time + interval;\n        return releaseTime;\n    }\n}",
            "label": 0
        },
        "1196": {
            "code": "pragma solidity ^0.4.24;\ncontract PGOMonthlyInternalVault {\n\n    uint256 public cliff;\n    uint256 vested = 0;\n\n    function vestedAmount() public view returns (uint256) {\n\n        uint256 timme = block.timestamp;\n        if (timme >= cliff) {\n            uint256 time = timme - (cliff);\n            uint256 elapsedOffsets = time / (21);\n            vested = vested + (elapsedOffsets);\n        }\n        return vested;\n    }\n}",
            "label": 1
        },
        "1197": {
            "code": "pragma solidity ^0.4.24;\ncontract Ownable1 {\n    function started() public view returns(bool) {\n        if (block.timestamp >= 100) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
            "label": 0
        },
        "1198": {
            "code": "pragma solidity ^0.4.24;\ncontract DiceRoll {\n\n    uint64 nextJackpotTime;\n\n    function createWinner() public {\n        uint64 tmNow = uint64(block.timestamp);\n        require(tmNow >= nextJackpotTime);\n    }\n}",
            "label": 1
        },
        "1199": {
            "code": "pragma solidity ^0.4.24;\ncontract IncreasingTokenPriceCrowdsale {\n  uint256 public openingTime = 10;\n   \n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - (openingTime);\n    return elapsedTime;\n  }\n}",
            "label": 0
        },
        "1200": {
            "code": "pragma solidity ^0.4.24;\ncontract dappVolumeAd {\n\tuint256 public purchaseTimestamp;\n\n\tfunction updateAd() public payable {\n\t\tpurchaseTimestamp = block.timestamp;\n\t\trequire(purchaseTimestamp > 10);\n\t}\n}",
            "label": 0
        },
        "1201": {
            "code": "pragma solidity ^0.4.24;\ncontract SimpleBet {\n\tfunction random() view returns (uint8) {\n        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 256);\n    }\n}",
            "label": 0
        },
        "1202": {
            "code": "pragma solidity ^0.4.24;\ncontract CrowdsaleRC {\n    uint public createdTimestamp;\n\n    function CrowdsaleRC () public {\n        createdTimestamp = block.timestamp;\n    }\n}",
            "label": 0
        },
        "1203": {
            "code": "pragma solidity ^0.4.24;\ncontract PLCRVoting {\n\n    function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {\n        uint commitEndDate = block.timestamp + (_commitDuration);\n        uint revealEndDate = commitEndDate + (_revealDuration);\n        return revealEndDate;\n    }\n}",
            "label": 0
        },
        "1204": {
            "code": "pragma solidity ^0.4.24;\ncontract DSNote {\n    function time() constant returns (uint) {\n        return block.timestamp;\n    }\n}",
            "label": 0
        }
    }
}